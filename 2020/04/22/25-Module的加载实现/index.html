<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="前言本文主要内容：  浏览器加载 ES6 模块与 CommonJS 模块的差异 Node.js 加载 循环加载">
<meta property="og:type" content="article">
<meta property="og:title" content="Module的加载实现">
<meta property="og:url" content="http://yoursite.com/2020/04/22/25-Module%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0/index.html">
<meta property="og:site_name" content="若只如初见">
<meta property="og:description" content="前言本文主要内容：  浏览器加载 ES6 模块与 CommonJS 模块的差异 Node.js 加载 循环加载">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-04-22T00:00:00.000Z">
<meta property="article:modified_time" content="2020-04-22T09:22:50.000Z">
<meta property="article:author" content="lyy">
<meta property="article:tag" content="ES6">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2020/04/22/25-Module%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Module的加载实现 | 若只如初见</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">若只如初见</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">书籍是人类进步的阶梯</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">12</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">12</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">128</span></a>

  </li>
        <li class="menu-item menu-item-疫情地图">

    <a href="http://joyli.net.cn/covid19-map/" rel="noopener" target="_blank"><i class="map fa-fw"></i>疫情地图</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/22/25-Module%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="lyy">
      <meta itemprop="description" content="世间所有的相遇，都是久别重逢">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="若只如初见">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Module的加载实现
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-22 00:00:00 / 修改时间：09:22:50" itemprop="dateCreated datePublished" datetime="2020-04-22T00:00:00Z">2020-04-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ES6/" itemprop="url" rel="index"><span itemprop="name">ES6</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/04/22/25-Module%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/04/22/25-Module%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要内容：</p>
<ul>
<li>浏览器加载</li>
<li>ES6 模块与 CommonJS 模块的差异</li>
<li>Node.js 加载</li>
<li>循环加载<a id="more"></a>
<h2 id="浏览器加载"><a href="#浏览器加载" class="headerlink" title="浏览器加载"></a>浏览器加载</h2></li>
</ul>
<h3 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h3><p>HTML 网页中，浏览器通过<code>&lt;script&gt;</code>标签加载 JavaScript 脚本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 页面内嵌的脚本 --&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;application&#x2F;javascript&quot;&gt;</span><br><span class="line">  &#x2F;&#x2F; module code</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 外部脚本 --&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;application&#x2F;javascript&quot; src&#x3D;&quot;path&#x2F;to&#x2F;myModule.js&quot;&gt;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码中，由于浏览器脚本的默认语言是 JavaScript，因此<code>type=&quot;application/javascript&quot;</code>可以省略。</p>
<p><font style = "color:blue"><strong>默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到<code>&lt;script&gt;</code>标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。</strong></font></p>
<p>如果脚本体积很大，下载和执行的时间就会很长，因此<strong>造成浏览器堵塞</strong>，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，<font style = "color:blue">所以浏览器允许脚本异步加载，下面就是两种异步加载的语法。</font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;path&#x2F;to&#x2F;myModule.js&quot; defer&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;path&#x2F;to&#x2F;myModule.js&quot; async&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<font style = "color:blue"><code>&lt;script&gt;</code>标签打开<code>defer</code>或<code>async</code>属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。</font></p>
<ul>
<li><font style = "color:blue"><strong><code>defer</code>与<code>async</code>的区别是</strong></font>：<code>defer</code>要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；<code>async</code>一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，<strong><code>defer</code>是“渲染完再执行”，<code>async</code>是“下载完就执行”</strong>。另外，如果有多个<code>defer</code>脚本，会按照它们在页面出现的<strong>顺序加载</strong>，而多个<code>async</code>脚本是不能保证加载顺序的。</li>
</ul>
<h2 id="加载规则"><a href="#加载规则" class="headerlink" title="加载规则"></a>加载规则</h2><p>浏览器加载 ES6 模块，也使用<code>&lt;script&gt;</code>标签，但是要加入<code>type=&quot;module&quot;</code>属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;module&quot; src&#x3D;&quot;.&#x2F;foo.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码在网页中插入一个模块<code>foo.js</code>，由于<code>type</code>属性设为<code>module</code>，所以浏览器知道这是一个 ES6 模块。</p>
<ul>
<li>浏览器对于带有<code>type=&quot;module&quot;</code>的<code>&lt;script&gt;</code>，都是<strong>异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了<code>&lt;script&gt;</code>标签的<code>defer</code>属性。</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;module&quot; src&#x3D;&quot;.&#x2F;foo.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;!-- 等同于 --&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;module&quot; src&#x3D;&quot;.&#x2F;foo.js&quot; defer&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>如果网页有多个<code>&lt;script type=&quot;module&quot;&gt;</code>，它们会按照在页面出现的<strong>顺序依次执行</strong>。</p>
<p><code>&lt;script&gt;</code>标签的<code>async</code>属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;module&quot; src&#x3D;&quot;.&#x2F;foo.js&quot; async&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>一旦使用了<code>async</code>属性，<code>&lt;script type=&quot;module&quot;&gt;</code>就不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块。</p>
<p>ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;module&quot;&gt;</span><br><span class="line">  import utils from &quot;.&#x2F;utils.js&quot;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; other code</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>举例来说，jQuery 就支持模块加载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;module&quot;&gt;</span><br><span class="line">  import $ from &quot;.&#x2F;jquery&#x2F;src&#x2F;jquery.js&quot;;</span><br><span class="line">  $(&#39;#message&#39;).text(&#39;Hi from jQuery!&#39;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>对于外部的模块脚本（上例是foo.js），有几点需要注意。</p>
<ul>
<li>代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。</li>
<li>模块脚本自动采用严格模式，不管有没有声明<code>use strict</code>。</li>
<li>模块之中，可以使用<code>import</code>命令加载其他模块（.js后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用<code>export</code>命令输出对外接口。</li>
<li><strong>模块之中，顶层的<code>this</code>关键字返回<code>undefined</code></strong>，而不是指向<code>window</code>。也就是说，在模块顶层使用<code>this</code>关键字，是无意义的。</li>
<li>同一个模块如果加载多次，将只执行一次。</li>
</ul>
<p>下面是一个示例模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import utils from &#39;https:&#x2F;&#x2F;example.com&#x2F;js&#x2F;utils.js&#39;;</span><br><span class="line"></span><br><span class="line">const x &#x3D; 1;</span><br><span class="line"></span><br><span class="line">console.log(x &#x3D;&#x3D;&#x3D; window.x); &#x2F;&#x2F;false</span><br><span class="line">console.log(this &#x3D;&#x3D;&#x3D; undefined); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>利用顶层的<code>this</code>等于<code>undefined</code>这个语法点，可以侦测当前代码是否在 ES6 模块之中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const isNotModuleScript &#x3D; this !&#x3D;&#x3D; undefined;</span><br></pre></td></tr></table></figure>

<h2 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h2><p>讨论 Node.js 加载 ES6 模块之前，必须了解 ES6 模块与 CommonJS 模块完全不同。</p>
<p>它们有两个重大<strong>差异</strong>。</p>
<ul>
<li><code>CommonJS</code>模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li>
<li><code>CommonJS</code> 模块是运行时加载，<strong>ES6 模块是编译时输出接口</strong>。</li>
<li>第二个差异是因为 <code>CommonJS</code> 加载的是一个对象（即<code>module.exports</code>属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</li>
</ul>
<p>下面重点解释第一个差异。</p>
<p><code>CommonJS</code> 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个模块文件lib.js的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; lib.js</span><br><span class="line">var counter &#x3D; 3;</span><br><span class="line">function incCounter() &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  counter: counter,</span><br><span class="line">  incCounter: incCounter,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码输出内部变量<code>counter</code>和改写这个变量的内部方法i<code>ncCounter</code>。然后，在<code>main.js</code>里面加载这个模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; main.js</span><br><span class="line">var mod &#x3D; require(&#39;.&#x2F;lib&#39;);</span><br><span class="line"></span><br><span class="line">console.log(mod.counter);  &#x2F;&#x2F; 3</span><br><span class="line">mod.incCounter();</span><br><span class="line">console.log(mod.counter); &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>

<p>上面代码说明，<code>lib.js</code>模块加载以后，它的内部变化就影响不到输出的<code>mod.counter</code>了。这是因为<code>mod.counter</code>是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; lib.js</span><br><span class="line">var counter &#x3D; 3;</span><br><span class="line">function incCounter() &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  get counter() &#123;</span><br><span class="line">    return counter</span><br><span class="line">  &#125;,</span><br><span class="line">  incCounter: incCounter,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，输出的counter属性实际上是一个取值器函数。现在再执行main.js，就可以正确读取内部变量counter的变动了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node main.js</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>ES6 模块的运行机制与 <code>CommonJS</code> 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的<code>import</code>有点像 <code>Unix</code> 系统的“符号连接”，原始值变了，<code>import</code>加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</p>
<p>还是举上面的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; lib.js</span><br><span class="line">export let counter &#x3D; 3;</span><br><span class="line">export function incCounter() &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; main.js</span><br><span class="line">import &#123; counter, incCounter &#125; from &#39;.&#x2F;lib&#39;;</span><br><span class="line">console.log(counter); &#x2F;&#x2F; 3</span><br><span class="line">incCounter();</span><br><span class="line">console.log(counter); &#x2F;&#x2F; 4</span><br></pre></td></tr></table></figure>

<p>上面代码说明，ES6 模块输入的变量counter是活的，完全反应其所在模块lib.js内部的变化。</p>
<p>再举一个出现在<code>export</code>一节中的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; m1.js</span><br><span class="line">export var foo &#x3D; &#39;bar&#39;;</span><br><span class="line">setTimeout(() &#x3D;&gt; foo &#x3D; &#39;baz&#39;, 500);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; m2.js</span><br><span class="line">import &#123;foo&#125; from &#39;.&#x2F;m1.js&#39;;</span><br><span class="line">console.log(foo);</span><br><span class="line">setTimeout(() &#x3D;&gt; console.log(foo), 500);</span><br></pre></td></tr></table></figure>

<p>上面代码中，m1.js的变量foo，在刚加载时等于bar，过了 500 毫秒，又变为等于baz。</p>
<p>让我们看看，m2.js能否正确读取这个变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ babel-node m2.js</span><br><span class="line"></span><br><span class="line">bar</span><br><span class="line">baz</span><br></pre></td></tr></table></figure>

<p>上面代码表明，<strong>ES6 模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块。</strong></p>
<p>由于 ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; lib.js</span><br><span class="line">export let obj &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; main.js</span><br><span class="line">import &#123; obj &#125; from &#39;.&#x2F;lib&#39;;</span><br><span class="line"></span><br><span class="line">obj.prop &#x3D; 123; &#x2F;&#x2F; OK</span><br><span class="line">obj &#x3D; &#123;&#125;; &#x2F;&#x2F; TypeError</span><br></pre></td></tr></table></figure>

<p>上面代码中，main.js从lib.js输入变量obj，可以对obj添加属性，但是重新赋值就会报错。因为变量obj指向的地址是只读的，不能重新赋值，这就好比main.js创造了一个名为obj的const变量。</p>
<p>最后，<code>export</code>通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; mod.js</span><br><span class="line">function C() &#123;</span><br><span class="line">  this.sum &#x3D; 0;</span><br><span class="line">  this.add &#x3D; function () &#123;</span><br><span class="line">    this.sum +&#x3D; 1;</span><br><span class="line">  &#125;;</span><br><span class="line">  this.show &#x3D; function () &#123;</span><br><span class="line">    console.log(this.sum);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export let c &#x3D; new C();</span><br></pre></td></tr></table></figure>

<p>上面的脚本mod.js，输出的是一个C的实例。不同的脚本加载这个模块，得到的都是同一个实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; x.js</span><br><span class="line">import &#123;c&#125; from &#39;.&#x2F;mod&#39;;</span><br><span class="line">c.add();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; y.js</span><br><span class="line">import &#123;c&#125; from &#39;.&#x2F;mod&#39;;</span><br><span class="line">c.show();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; main.js</span><br><span class="line">import &#39;.&#x2F;x&#39;;</span><br><span class="line">import &#39;.&#x2F;y&#39;;</span><br></pre></td></tr></table></figure>

<p>现在执行main.js，输出的是1。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ babel-node main.js</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>这就证明了x.js和y.js加载的都是C的同一个实例。</p>
<h2 id="Node-js-加载"><a href="#Node-js-加载" class="headerlink" title="Node.js 加载"></a>Node.js 加载</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code>Node.js</code>对 ES6 模块的处理比较麻烦，因为它有自己的 <code>CommonJS</code>模块格式，与 ES6 模块格式是不兼容的。目前的解决方案是，将两者分开，ES6 模块和 <code>CommonJS</code> 采用各自的加载方案。从 v13.2 版本开始，<code>Node.js</code> 已经默认打开了 ES6 模块支持。</p>
<p><code>Node.js</code> 要求 ES6 模块采用<code>.mjs</code>后缀文件名。也就是说，只要脚本文件里面使用<code>import</code>或者<code>export</code>命令，那么就必须采用<code>.mjs</code>后缀名。<code>Node.js</code> 遇到<code>.mjs</code>文件，就认为它是 ES6 模块，默认启用严格模式，不必在每个模块文件顶部指定<code>&quot;use strict&quot;</code>。</p>
<p>如果不希望将后缀名改成<code>.mjs</code>，可以在项目的<code>package.json</code>文件中，指定<code>type</code>字段为<code>module</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;type&quot;: &quot;module&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦设置了以后，该目录里面的 JS 脚本，就被解释用 ES6 模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#解释成 ES6 模块</span><br><span class="line"></span><br><span class="line">&#96;$ node my-app.js&#96;</span><br></pre></td></tr></table></figure>

<p>如果这时还要使用 <code>CommonJS</code> 模块，那么需要将 <code>CommonJS</code> 脚本的后缀名都改成<code>.cjs</code>。如果没有<code>type</code>字段，或者<code>type</code>字段为<code>commonjs</code>，则<code>.js</code>脚本会被解释成 <code>CommonJS</code> 模块。</p>
<blockquote>
<p>总结为一句话：<code>.mjs</code>文件总是以 ES6 模块加载，<code>.cjs</code>文件总是以 <code>CommonJS</code> 模块加载，<code>.js</code>文件的加载取决于<code>package.json</code>里面<code>type</code>字段的设置。</p>
</blockquote>
<blockquote>
<p>注意，ES6 模块与 CommonJS 模块尽量不要混用。<code>require</code>命令不能加载<code>.mjs</code>文件，会报错，只有<code>import</code>命令才可以加载<code>.mjs</code>文件。反过来，<code>.mjs</code>文件里面也不能使用<code>requir</code>e命令，必须使用<code>import</code>。</p>
</blockquote>
<h3 id="main-字段"><a href="#main-字段" class="headerlink" title="main 字段"></a>main 字段</h3><p><code>package.json</code>文件有两个字段可以指定模块的入口文件：<code>main</code>和<code>exports</code>。比较简单的模块，可以只使用<code>main</code>字段，指定模块加载的入口文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; .&#x2F;node_modules&#x2F;es-module-package&#x2F;package.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;: &quot;module&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;.&#x2F;src&#x2F;index.js&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码指定项目的入口脚本为<code>./src/index.js</code>，它的格式为 ES6 模块。如果没有type字段，<code>index.js</code>就会被解释为 CommonJS 模块。</p>
<p>然后，<code>import</code>命令就可以加载这个模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; .&#x2F;my-app.mjs</span><br><span class="line"></span><br><span class="line">import &#123; something &#125; from &#39;es-module-package&#39;;</span><br><span class="line">&#x2F;&#x2F; 实际加载的是 .&#x2F;node_modules&#x2F;es-module-package&#x2F;src&#x2F;index.js</span><br></pre></td></tr></table></figure>

<p>上面代码中，运行该脚本以后，<code>Node.js</code> 就会到<code>./node_modules</code>目录下面，寻找<code>es-module-package</code>模块，然后根据该模块<code>package.json</code>的<code>main</code>字段去执行入口文件。</p>
<p>这时，如果用 CommonJS 模块的<code>require()</code>命令去加载<code>es-module-package</code>模块会报错，因为 CommonJS 模块不能处理<code>export</code>命令。</p>
<h3 id="exports-字段"><a href="#exports-字段" class="headerlink" title="exports 字段"></a>exports 字段</h3><p><code>exports</code>字段的优先级高于<code>main</code>字段。它有多种用法。</p>
<p>（1）子目录别名</p>
<p><code>package.json</code>文件的<code>exports</code>字段可以指定脚本或子目录的别名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; .&#x2F;node_modules&#x2F;es-module-package&#x2F;package.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;exports&quot;: &#123;</span><br><span class="line">    &quot;.&#x2F;submodule&quot;: &quot;.&#x2F;src&#x2F;submodule.js&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码指定<code>src/submodule.js</code>别名为<code>submodule</code>，然后就可以从别名加载这个文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import submodule from &#39;es-module-package&#x2F;submodule&#39;;</span><br><span class="line">&#x2F;&#x2F; 加载 .&#x2F;node_modules&#x2F;es-module-package&#x2F;src&#x2F;submodule.js</span><br></pre></td></tr></table></figure>

<p>下面是子目录别名的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; .&#x2F;node_modules&#x2F;es-module-package&#x2F;package.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;exports&quot;: &#123;</span><br><span class="line">    &quot;.&#x2F;features&#x2F;&quot;: &quot;.&#x2F;src&#x2F;features&#x2F;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import feature from &#39;es-module-package&#x2F;features&#x2F;x.js&#39;;</span><br><span class="line">&#x2F;&#x2F; 加载 .&#x2F;node_modules&#x2F;es-module-package&#x2F;src&#x2F;features&#x2F;x.js</span><br></pre></td></tr></table></figure>

<p>如果没有指定别名，就不能用“模块+脚本名”这种形式加载脚本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 报错</span><br><span class="line">import submodule from &#39;es-module-package&#x2F;private-module.js&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 不报错</span><br><span class="line">import submodule from &#39;.&#x2F;node_modules&#x2F;es-module-package&#x2F;private-module.js&#39;;</span><br></pre></td></tr></table></figure>

<p>（2）main 的别名</p>
<p><code>exports</code>字段的别名如果是.，就代表模块的主入口，优先级高于<code>main</code>字段，并且可以直接简写成<code>exports</code>字段的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;exports&quot;: &#123;</span><br><span class="line">    &quot;.&quot;: &quot;.&#x2F;main.js&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">&#123;</span><br><span class="line">  &quot;exports&quot;: &quot;.&#x2F;main.js&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>exports</code>字段只有支持 ES6 的 <code>Node.js</code> 才认识，所以可以用来兼容旧版本的 <code>Node.js</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;main&quot;: &quot;.&#x2F;main-legacy.cjs&quot;,</span><br><span class="line">  &quot;exports&quot;: &#123;</span><br><span class="line">    &quot;.&quot;: &quot;.&#x2F;main-modern.cjs&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，老版本的 <code>Node.js</code> （不支持 ES6 模块）的入口文件是<code>main-legacy.cjs</code>，新版本的 Node.js 的入口文件是<code>main-modern.cjs</code>。</p>
<p>（3）条件加载</p>
<p>利用<code>.</code>这个别名，可以为 ES6 模块和 CommonJS <strong>指定不同的入口</strong>。目前，这个功能需要在 <code>Node.js</code> 运行的时候，打开<code>--experimental-conditional-exports</code>标志。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;: &quot;module&quot;,</span><br><span class="line">  &quot;exports&quot;: &#123;</span><br><span class="line">    &quot;.&quot;: &#123;</span><br><span class="line">      &quot;require&quot;: &quot;.&#x2F;main.cjs&quot;,</span><br><span class="line">      &quot;default&quot;: &quot;.&#x2F;main.js&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，别名<code>.</code>的<code>require</code>条件指定<code>require()</code>命令的入口文件（即 CommonJS 的入口），<code>default</code>条件指定其他情况的入口（即 ES6 的入口）。</p>
<p>上面的写法可以简写如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;exports&quot;: &#123;</span><br><span class="line">    &quot;require&quot;: &quot;.&#x2F;main.cjs&quot;,</span><br><span class="line">    &quot;default&quot;: &quot;.&#x2F;main.js&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，如果同时还有其他别名，就不能采用简写，否则或报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F; 报错</span><br><span class="line">  &quot;exports&quot;: &#123;</span><br><span class="line">    &quot;.&#x2F;feature&quot;: &quot;.&#x2F;lib&#x2F;feature.js&quot;,</span><br><span class="line">    &quot;require&quot;: &quot;.&#x2F;main.cjs&quot;,</span><br><span class="line">    &quot;default&quot;: &quot;.&#x2F;main.js&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ES6-模块加载-CommonJS-模块"><a href="#ES6-模块加载-CommonJS-模块" class="headerlink" title="ES6 模块加载 CommonJS 模块"></a>ES6 模块加载 CommonJS 模块</h3><p>目前，一个模块同时支持 ES6 和 CommonJS 两种格式的常见方法是，<code>package.json</code>文件的<code>main</code>字段指定 CommonJS 入口，给 <code>Node.js</code> 使用；<code>module</code>字段指定 ES6 模块入口，给打包工具使用，因为 <code>Node.js</code> 不认识<code>module</code>字段。</p>
<p>有了上一节的条件加载以后，<code>Node.js</code> 本身就可以同时处理两种模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; .&#x2F;node_modules&#x2F;pkg&#x2F;package.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;: &quot;module&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;.&#x2F;index.cjs&quot;,</span><br><span class="line">  &quot;exports&quot;: &#123;</span><br><span class="line">    &quot;require&quot;: &quot;.&#x2F;index.cjs&quot;,</span><br><span class="line">    &quot;default&quot;: &quot;.&#x2F;wrapper.mjs&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码指定了 CommonJS 入口文件<code>index.cjs</code>，下面是这个文件的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; .&#x2F;node_modules&#x2F;pkg&#x2F;index.cjs</span><br><span class="line">exports.name &#x3D; &#39;value&#39;;</span><br></pre></td></tr></table></figure>

<p>然后，ES6 模块可以加载这个文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; .&#x2F;node_modules&#x2F;pkg&#x2F;wrapper.mjs</span><br><span class="line">import cjsModule from &#39;.&#x2F;index.cjs&#39;;</span><br><span class="line">export const name &#x3D; cjsModule.name;</span><br></pre></td></tr></table></figure>

<p>注意，<code>import</code>命令加载 CommonJS 模块，只能整体加载，不能只加载单一的输出项。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 正确</span><br><span class="line">import packageMain from &#39;commonjs-package&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 报错</span><br><span class="line">import &#123; method &#125; from &#39;commonjs-package&#39;;</span><br></pre></td></tr></table></figure>

<p>还有一种变通的加载方法，就是使用 <code>Node.js</code> 内置的<code>module.createRequire()</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; cjs.cjs</span><br><span class="line">module.exports &#x3D; &#39;cjs&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; esm.mjs</span><br><span class="line">import &#123; createRequire &#125; from &#39;module&#39;;</span><br><span class="line"></span><br><span class="line">const require &#x3D; createRequire(import.meta.url);</span><br><span class="line"></span><br><span class="line">const cjs &#x3D; require(&#39;.&#x2F;cjs.cjs&#39;);</span><br><span class="line">cjs &#x3D;&#x3D;&#x3D; &#39;cjs&#39;; &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>上面代码中，ES6 模块通过<code>module.createRequire()</code>方法可以加载 CommonJS 模块</p>
<h3 id="CommonJS-模块加载-ES6-模块"><a href="#CommonJS-模块加载-ES6-模块" class="headerlink" title="CommonJS 模块加载 ES6 模块"></a>CommonJS 模块加载 ES6 模块</h3><p>CommonJS 的<code>require</code>命令不能加载 ES6 模块，会报错，只能使用<code>import()</code>这个方法加载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(async () &#x3D;&gt; &#123;</span><br><span class="line">  await import(&#39;.&#x2F;my-app.mjs&#39;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>上面代码可以在 CommonJS 模块中运行。</p>
<h3 id="Node-js-的内置模块"><a href="#Node-js-的内置模块" class="headerlink" title="Node.js 的内置模块"></a>Node.js 的内置模块</h3><p><code>Node.js</code> 的内置模块可以整体加载，也可以加载指定的输出项。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 整体加载</span><br><span class="line">import EventEmitter from &#39;events&#39;;</span><br><span class="line">const e &#x3D; new EventEmitter();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 加载指定的输出项</span><br><span class="line">import &#123; readFile &#125; from &#39;fs&#39;;</span><br><span class="line">readFile(&#39;.&#x2F;foo.txt&#39;, (err, source) &#x3D;&gt; &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">    console.error(err);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(source);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="加载路径"><a href="#加载路径" class="headerlink" title="加载路径"></a>加载路径</h4><p>ES6 模块的加载路径必须给出脚本的完整路径，<strong>不能省略脚本的后缀名</strong>。<code>import</code>命令和<code>package.json</code>文件的<code>main</code>字段如果省略脚本的后缀名，会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ES6 模块中将报错</span><br><span class="line">import &#123; something &#125; from &#39;.&#x2F;index&#39;;</span><br></pre></td></tr></table></figure>

<p>为了与浏览器的<code>import</code>加载规则相同，<code>Node.js</code> 的<code>.mjs</code>文件支持 URL 路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#39;.&#x2F;foo.mjs?query&#x3D;1&#39;; &#x2F;&#x2F; 加载 .&#x2F;foo 传入参数 ?query&#x3D;1</span><br></pre></td></tr></table></figure>

<p>上面代码中，脚本路径带有参数<code>?query=1</code>，Node 会按 URL 规则解读。同一个脚本只要参数不同，就会被加载多次，并且保存成不同的缓存。由于这个原因，只要文件名中含有<code>:、%、#、?</code>等特殊字符，最好对这些字符进行转义。</p>
<p>目前，Node.js 的<code>import</code>命令只支持加载本地模块（file:协议）和data:协议，不支持加载远程模块。另外，脚本路径只支持相对路径，不支持绝对路径（即以/或//开头的路径）。</p>
<p>最后，<strong>Node 的<code>import</code>命令是异步加载</strong>，这一点与浏览器的处理方法相同。</p>
<h4 id="内部变量"><a href="#内部变量" class="headerlink" title="内部变量"></a>内部变量</h4><p>ES6 模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。为了达到这个目标，Node 规定 ES6 模块之中不能使用 CommonJS 模块的特有的一些内部变量。</p>
<p>首先，就是<code>this</code>关键字。ES6 模块之中，顶层的<code>this</code>指向<code>undefined</code>；CommonJS 模块的顶层<code>this</code>指向当前模块，这是两者的一个重大差异。</p>
<p>其次，以下这些顶层变量在 ES6 模块之中都是不存在的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arguments</span><br><span class="line">require</span><br><span class="line">module</span><br><span class="line">exports</span><br><span class="line">__filename</span><br><span class="line">__dirname</span><br></pre></td></tr></table></figure>

<h2 id="循环加载"><a href="#循环加载" class="headerlink" title="循环加载"></a>循环加载</h2><p>“循环加载”（circular dependency）指的是，a脚本的执行依赖b脚本，而b脚本的执行又依赖a脚本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a.js</span><br><span class="line">var b &#x3D; require(&#39;b&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; b.js</span><br><span class="line">var a &#x3D; require(&#39;a&#39;);</span><br></pre></td></tr></table></figure>

<p>通常，“循环加载”表示存在强耦合，如果处理不好，还可能导致递归加载，使得程序无法执行，因此应该避免出现。</p>
<p>但是实际上，这是很难避免的，尤其是依赖关系复杂的大项目，很容易出现a依赖b，b依赖c，c又依赖a这样的情况。这意味着，模块加载机制必须考虑“循环加载”的情况。</p>
<p>对于 JavaScript 语言来说，目前最常见的两种模块格式 CommonJS 和 ES6，处理“循环加载”的方法是不一样的，返回的结果也不一样。</p>
<h3 id="CommonJS-模块的加载原理"><a href="#CommonJS-模块的加载原理" class="headerlink" title="CommonJS 模块的加载原理"></a>CommonJS 模块的加载原理</h3><p>介绍 ES6 如何处理“循环加载”之前，先介绍目前最流行的 CommonJS 模块格式的加载原理。</p>
<p>CommonJS 的一个模块，就是一个脚本文件。<code>require</code>命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  id: &#39;...&#39;,</span><br><span class="line">  exports: &#123; ... &#125;,</span><br><span class="line">  loaded: true,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码就是 Node 内部加载模块后生成的一个对象。该对象的<code>id</code>属性是模块名，<code>exports</code>属性是模块输出的各个接口，<code>loaded</code>属性是一个布尔值，表示该模块的脚本是否执行完毕。其他还有很多属性，这里都省略了。</p>
<p>以后需要用到这个模块的时候，就会到<code>exports</code>属性上面取值。即使再次执行<code>require</code>命令，也不会再次执行该模块，而是到缓存之中取值。也就是说，CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。</p>
<h3 id="CommonJS-模块的循环加载"><a href="#CommonJS-模块的循环加载" class="headerlink" title="CommonJS 模块的循环加载"></a>CommonJS 模块的循环加载</h3><p>CommonJS 模块的重要特性是<strong>加载时执行</strong>，即脚本代码在<code>require</code>的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。</p>
<p>让我们来看，Node 官方文档里面的例子。脚本文件a.js代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exports.done &#x3D; false;</span><br><span class="line">var b &#x3D; require(&#39;.&#x2F;b.js&#39;);</span><br><span class="line">console.log(&#39;在 a.js 之中，b.done &#x3D; %j&#39;, b.done);</span><br><span class="line">exports.done &#x3D; true;</span><br><span class="line">console.log(&#39;a.js 执行完毕&#39;);</span><br></pre></td></tr></table></figure>

<p>上面代码之中，<code>a.js</code>脚本先输出一个<code>done</code>变量，然后加载另一个脚本文件<code>b.js</code>。注意，此时<code>a.js</code>代码就停在这里，等待<code>b.js</code>执行完毕，再往下执行。</p>
<p>再看<code>b.js</code>的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exports.done &#x3D; false;</span><br><span class="line">var a &#x3D; require(&#39;.&#x2F;a.js&#39;);</span><br><span class="line">console.log(&#39;在 b.js 之中，a.done &#x3D; %j&#39;, a.done);</span><br><span class="line">exports.done &#x3D; true;</span><br><span class="line">console.log(&#39;b.js 执行完毕&#39;);</span><br></pre></td></tr></table></figure>

<p>上面代码之中，<code>b.js</code>执行到第二行，就会去加载<code>a.js</code>，这时，就发生了“循环加载”。系统会去a.js模块对应对象的<code>exports</code>属性取值，可是因为<code>a.js</code>还没有执行完，从<code>exports</code>属性只能取回已经执行的部分，而不是最后的值。</p>
<p><code>a.js</code>已经执行的部分，只有一行。</p>
<p><code>exports.done = false;</code></p>
<p>因此，对于<code>b.js</code>来说，它从<code>a.js</code>只输入一个变量<code>done</code>，值为<code>false</code>。</p>
<p>然后，<code>b.js</code>接着往下执行，等到全部执行完毕，再把执行权交还给<code>a.js</code>。于是，<code>a.js</code>接着往下执行，直到执行完毕。我们写一个脚本<code>main.js</code>，验证这个过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; require(&#39;.&#x2F;a.js&#39;);</span><br><span class="line">var b &#x3D; require(&#39;.&#x2F;b.js&#39;);</span><br><span class="line">console.log(&#39;在 main.js 之中, a.done&#x3D;%j, b.done&#x3D;%j&#39;, a.done, b.done);</span><br></pre></td></tr></table></figure>

<p>执行<code>main.js</code>，运行结果如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ node main.js</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在 &#96;b.js&#96; 之中，&#96;a.done &#x3D; false&#96;</span><br><span class="line"></span><br><span class="line">&#96;b.js&#96; 执行完毕</span><br><span class="line">在 a.js 之中，b.done &#x3D; true</span><br><span class="line">a.js 执行完毕</span><br><span class="line">在 main.js 之中, a.done&#x3D;true, b.done&#x3D;true</span><br></pre></td></tr></table></figure>
<p>上面的代码证明了两件事。一是，在<code>b.js</code>之中，<code>a.js</code>没有执行完毕，只执行了第一行。二是，<code>main.js</code>执行到第二行时，不会再次执行<code>b.js</code>，而是输出缓存的<code>b.js</code>的执行结果，即它的第四行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exports.done &#x3D; true;</span><br></pre></td></tr></table></figure>

<p>总之，CommonJS 输入的是被输出值的拷贝，不是引用。</p>
<p>另外，由于 CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; require(&#39;a&#39;); &#x2F;&#x2F; 安全的写法</span><br><span class="line">var foo &#x3D; require(&#39;a&#39;).foo; &#x2F;&#x2F; 危险的写法</span><br><span class="line"></span><br><span class="line">exports.good &#x3D; function (arg) &#123;</span><br><span class="line">  return a.foo(&#39;good&#39;, arg); &#x2F;&#x2F; 使用的是 a.foo 的最新值</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">exports.bad &#x3D; function (arg) &#123;</span><br><span class="line">  return foo(&#39;bad&#39;, arg); &#x2F;&#x2F; 使用的是一个部分加载时的值</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，如果发生循环加载，<code>require(&#39;a&#39;).foo</code>的值很可能后面会被改写，改用<code>require(&#39;a&#39;)</code>会更保险一点。</p>
<h3 id="ES6-模块的循环加载"><a href="#ES6-模块的循环加载" class="headerlink" title="ES6 模块的循环加载"></a>ES6 模块的循环加载</h3><p>ES6 处理“循环加载”与 CommonJS 有本质的不同。ES6 模块是动态引用，如果使用<code>import</code>从一个模块加载变量（即<code>import foo from &#39;foo&#39;</code>），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。</p>
<p>请看下面这个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a.mjs</span><br><span class="line">import &#123;bar&#125; from &#39;.&#x2F;b&#39;;</span><br><span class="line">console.log(&#39;a.mjs&#39;);</span><br><span class="line">console.log(bar);</span><br><span class="line">export let foo &#x3D; &#39;foo&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; b.mjs</span><br><span class="line">import &#123;foo&#125; from &#39;.&#x2F;a&#39;;</span><br><span class="line">console.log(&#39;b.mjs&#39;);</span><br><span class="line">console.log(foo);</span><br><span class="line">export let bar &#x3D; &#39;bar&#39;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>a.mjs</code>加载<code>b.mjs</code>，<code>b.mjs</code>又加载<code>a.mjs</code>，构成循环加载。执行<code>a.mjs</code>，结果如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node --experimental-modules a.mjs</span><br><span class="line">b.mjs</span><br><span class="line">ReferenceError: foo is not defined</span><br></pre></td></tr></table></figure>

<p>上面代码中，执行<code>a.mjs</code>以后会报错，<code>foo</code>变量未定义，这是为什么？</p>
<p>让我们一行行来看，ES6 循环加载是怎么处理的。首先，执行<code>a.mjs</code>以后，引擎发现它加载了<code>b.mjs</code>，因此会优先执行<code>b.mjs</code>，然后再执行<code>a.mjs</code>。接着，执行<code>b.mjs</code>的时候，已知它从<code>a.mjs</code>输入了<code>foo</code>接口，这时不会去执行<code>a.mjs</code>，而是认为这个接口已经存在了，继续往下执行。执行到第三行<code>console.log(foo)</code>的时候，才发现这个接口根本没定义，因此报错。</p>
<p>解决这个问题的方法，就是让<code>b.mjs</code>运行的时候，foo已经有定义了。这可以通过将<code>foo</code>写成函数来解决。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a.mjs</span><br><span class="line">import &#123;bar&#125; from &#39;.&#x2F;b&#39;;</span><br><span class="line">console.log(&#39;a.mjs&#39;);</span><br><span class="line">console.log(bar());</span><br><span class="line">function foo() &#123; return &#39;foo&#39; &#125;</span><br><span class="line">export &#123;foo&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; b.mjs</span><br><span class="line">import &#123;foo&#125; from &#39;.&#x2F;a&#39;;</span><br><span class="line">console.log(&#39;b.mjs&#39;);</span><br><span class="line">console.log(foo());</span><br><span class="line">function bar() &#123; return &#39;bar&#39; &#125;</span><br><span class="line">export &#123;bar&#125;;</span><br></pre></td></tr></table></figure>

<p>这时再执行<code>a.mjs</code>就可以得到预期结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ node --experimental-modules a.mjs</span><br><span class="line">b.mjs</span><br><span class="line">foo</span><br><span class="line">a.mjs</span><br><span class="line">bar</span><br></pre></td></tr></table></figure>

<p>这是因为函数具有提升作用，在执行<code>import {bar} from &#39;./b&#39;</code>时，函数<code>foo</code>就已经有定义了，所以<code>b.mjs</code>加载的时候不会报错。这也意味着，如果把函数<code>foo</code>改写成函数表达式，也会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a.mjs</span><br><span class="line">import &#123;bar&#125; from &#39;.&#x2F;b&#39;;</span><br><span class="line">console.log(&#39;a.mjs&#39;);</span><br><span class="line">console.log(bar());</span><br><span class="line">const foo &#x3D; () &#x3D;&gt; &#39;foo&#39;;</span><br><span class="line">export &#123;foo&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码的第四行，改成了函数表达式，就不具有提升作用，执行就会报错。</p>
<p>我们再来看 ES6 模块加载器SystemJS给出的一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; even.js</span><br><span class="line">import &#123; odd &#125; from &#39;.&#x2F;odd&#39;</span><br><span class="line">export var counter &#x3D; 0;</span><br><span class="line">export function even(n) &#123;</span><br><span class="line">  counter++;</span><br><span class="line">  return n &#x3D;&#x3D;&#x3D; 0 || odd(n - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; odd.js</span><br><span class="line">import &#123; even &#125; from &#39;.&#x2F;even&#39;;</span><br><span class="line">export function odd(n) &#123;</span><br><span class="line">  return n !&#x3D;&#x3D; 0 &amp;&amp; even(n - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>even.js</code>里面的函数even有一个参数n，只要不等于 0，就会减去 1，传入加载的odd()。odd.js也会做类似操作。</p>
<p>运行上面这段代码，结果如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ babel-node</span><br><span class="line">&gt; import * as m from &#39;.&#x2F;even.js&#39;;</span><br><span class="line">&gt; m.even(10);</span><br><span class="line">true</span><br><span class="line">&gt; m.counter</span><br><span class="line">6</span><br><span class="line">&gt; m.even(20)</span><br><span class="line">true</span><br><span class="line">&gt; m.counter</span><br><span class="line">17</span><br></pre></td></tr></table></figure>

<p>上面代码中，参数n从 10 变为 0 的过程中，even()一共会执行 6 次，所以变量counter等于 6。第二次调用even()时，参数n从 20 变为 0，even()一共会执行 11 次，加上前面的 6 次，所以变量counter等于 17。</p>
<p>这个例子要是改写成 CommonJS，就根本无法执行，会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; even.js</span><br><span class="line">var odd &#x3D; require(&#39;.&#x2F;odd&#39;);</span><br><span class="line">var counter &#x3D; 0;</span><br><span class="line">exports.counter &#x3D; counter;</span><br><span class="line">exports.even &#x3D; function (n) &#123;</span><br><span class="line">  counter++;</span><br><span class="line">  return n &#x3D;&#x3D; 0 || odd(n - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; odd.js</span><br><span class="line">var even &#x3D; require(&#39;.&#x2F;even&#39;).even;</span><br><span class="line">module.exports &#x3D; function (n) &#123;</span><br><span class="line">  return n !&#x3D; 0 &amp;&amp; even(n - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，even.js加载odd.js，而odd.js又去加载even.js，形成“循环加载”。这时，执行引擎就会输出even.js已经执行的部分（不存在任何结果），所以在odd.js之中，变量even等于undefined，等到后面调用even(n - 1)就会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; var m &#x3D; require(&#39;.&#x2F;even&#39;);</span><br><span class="line">&gt; m.even(10)</span><br><span class="line">TypeError: even is not a function</span><br></pre></td></tr></table></figure>
    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章推荐</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2020/04/22/24-Module的语法/" rel="bookmark">Module的语法</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2020/04/18/03-let和const/" rel="bookmark">let和const</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2020/04/18/04-变量的解构赋值/" rel="bookmark">变量的解构赋值</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2020/04/18/05-字符串的扩展/" rel="bookmark">字符串的拓展</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2020/04/18/06-字符串的新增方法/" rel="bookmark">字符串的新增方法</a></div>
    </li>
  </ul>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>lyy
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://yoursite.com/2020/04/22/25-Module%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0/" title="Module的加载实现">http://yoursite.com/2020/04/22/25-Module的加载实现/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/ES6/" rel="tag"># ES6</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/04/18/01-CSS%E5%B1%9E%E6%80%A7%EF%BC%9A%E5%AD%97%E4%BD%93%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%87%E6%9C%AC%E5%B1%9E%E6%80%A7/" rel="prev" title="CSS属性：字体属性和文本属性">
      <i class="fa fa-chevron-left"></i> CSS属性：字体属性和文本属性
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/04/22/24-Module%E7%9A%84%E8%AF%AD%E6%B3%95/" rel="next" title="Module的语法">
      Module的语法 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#浏览器加载"><span class="nav-number">1.1.</span> <span class="nav-text">浏览器加载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#传统方法"><span class="nav-number">1.1.1.</span> <span class="nav-text">传统方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#加载规则"><span class="nav-number">1.2.</span> <span class="nav-text">加载规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ES6-模块与-CommonJS-模块的差异"><span class="nav-number">1.3.</span> <span class="nav-text">ES6 模块与 CommonJS 模块的差异</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Node-js-加载"><span class="nav-number">1.4.</span> <span class="nav-text">Node.js 加载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述"><span class="nav-number">1.4.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#main-字段"><span class="nav-number">1.4.2.</span> <span class="nav-text">main 字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exports-字段"><span class="nav-number">1.4.3.</span> <span class="nav-text">exports 字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ES6-模块加载-CommonJS-模块"><span class="nav-number">1.4.4.</span> <span class="nav-text">ES6 模块加载 CommonJS 模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CommonJS-模块加载-ES6-模块"><span class="nav-number">1.4.5.</span> <span class="nav-text">CommonJS 模块加载 ES6 模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Node-js-的内置模块"><span class="nav-number">1.4.6.</span> <span class="nav-text">Node.js 的内置模块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#加载路径"><span class="nav-number">1.4.6.1.</span> <span class="nav-text">加载路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部变量"><span class="nav-number">1.4.6.2.</span> <span class="nav-text">内部变量</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#循环加载"><span class="nav-number">1.5.</span> <span class="nav-text">循环加载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CommonJS-模块的加载原理"><span class="nav-number">1.5.1.</span> <span class="nav-text">CommonJS 模块的加载原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CommonJS-模块的循环加载"><span class="nav-number">1.5.2.</span> <span class="nav-text">CommonJS 模块的循环加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ES6-模块的循环加载"><span class="nav-number">1.5.3.</span> <span class="nav-text">ES6 模块的循环加载</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="lyy"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">lyy</p>
  <div class="site-description" itemprop="description">世间所有的相遇，都是久别重逢</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/lyylyylyylyy" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lyylyylyylyy" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zju.edu.cn/" title="ZJU → https:&#x2F;&#x2F;www.zju.edu.cn&#x2F;" rel="noopener" target="_blank"><i class="fa fa-graduation-cap fa-fw"></i>ZJU</a>
      </span>
  </div>



    <div class="links-of-blogroll motion-element links-of-blogroll-block">
      <div class="links-of-blogroll-title">
        <!-- modify icon to fire by szw -->
        <i class="fa fa-history fa-" aria-hidden="true"></i>
        近期文章
      </div>
      <ul class="links-of-blogroll-list">
        
        
          <li>
            <a href="/2020/08/08/47.%20Permutations%20II/" title="47. Permutations II" target="_blank">47. Permutations II</a>
          </li>
        
          <li>
            <a href="/2020/08/07/766.%20Toeplitz%20Matrix/" title="766. Toeplitz Matrix" target="_blank">766. Toeplitz Matrix</a>
          </li>
        
          <li>
            <a href="/2020/08/05/456.%20132%20Pattern/" title="456. 132 Pattern" target="_blank">456. 132 Pattern</a>
          </li>
        
          <li>
            <a href="/2020/08/05/131.%20Palindrome%20Partitioning/" title="131. Palindrome Partitioning" target="_blank">131. Palindrome Partitioning</a>
          </li>
        
          <li>
            <a href="/2020/08/02/215.%20Kth%20Largest%20Element%20in%20an%20Array/" title="215. Kth Largest Element in an Array" target="_blank">215. Kth Largest Element in an Array</a>
          </li>
        
      </ul>
    </div>

      </div>
      <a href="https://clustrmaps.com/site/1b75d" target="_blank" rel="noopener"  title="Visit tracker"><img src="//www.clustrmaps.com/map_v2.png?d=MSgeNXm-y8DMM6r6hBqJa2IyTlI7gYrIkTQGt57lgv8&cl=ffffff" /></a>
  </aside>
    </div>
    
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fab fa-android"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lyy</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js"></script>
  <script size="300" alpha="0.6" zIndex="-1" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-ribbon@1/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'mxQ2lQFuJOjoaYkjNciana8G-gzGzoHsz',
      appKey     : 'AWuAvmWCK2rLASObQlsdeX2W',
      placeholder: "Your comment makes this site better!",
      avatar     : 'identicon',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
