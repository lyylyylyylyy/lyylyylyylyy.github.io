{"meta":{"title":"若只如初见","subtitle":"书籍是人类进步的阶梯","description":"世间所有的相遇，都是久别重逢","author":"lyy","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于我","date":"2020-03-17T21:23:47.000Z","updated":"2020-04-21T04:22:58.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"前端爱好者，初学者，发布一些前端学习笔记，学习心得，以及平时做的一些小项目，欢迎大家给我star，哈哈哈项目链接： 仿Boss直聘: https://ancient-oasis-26939.herokuapp.com/#/login YelpCamp: https://infinite-tor-30747.herokuapp.com/"},{"title":"分类","date":"2020-02-04T12:52:57.000Z","updated":"2020-04-21T04:34:24.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-02-04T12:52:57.000Z","updated":"2020-04-21T04:34:24.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"83. Remove Duplicates from Sorted List","slug":"83. Remove Duplicates from Sorted List","date":"2020-08-12T22:44:40.000Z","updated":"2020-08-12T15:21:15.714Z","comments":true,"path":"2020/08/13/83. Remove Duplicates from Sorted List/","link":"","permalink":"http://yoursite.com/2020/08/13/83.%20Remove%20Duplicates%20from%20Sorted%20List/","excerpt":"问题描述Given a sorted linked list, delete all duplicates such that each element appear only once. Example 1: 12Input: 1-&gt;1-&gt;2Output: 1-&gt;2","text":"问题描述Given a sorted linked list, delete all duplicates such that each element appear only once. Example 1: 12Input: 1-&gt;1-&gt;2Output: 1-&gt;2 Example 2: 12Input: 1-&gt;1-&gt;2-&gt;3-&gt;3Output: 1-&gt;2-&gt;3 解题思路 从链表的head开始，向后寻找，直到找到一个与当前head处不相等的值，head = head.next 代码如下： 12345678910111213141516171819202122/** * Definition for singly-linked list. * function ListNode(val, next) &#123; * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var deleteDuplicates = function(head) &#123; var lead = head; while(lead &amp;&amp; lead.next) &#123; while (lead &amp;&amp; lead.next &amp;&amp; lead.next.val === lead.val ) &#123; lead.next = lead.next.next; &#125; lead = lead.next; &#125; return head&#125;; 时间复杂度：O(n)空间复杂度：O(n)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/tags/Leetcode/"}]},{"title":"62. Unique Paths","slug":"62. Unique Paths","date":"2020-08-11T22:44:40.000Z","updated":"2020-08-11T12:33:47.398Z","comments":true,"path":"2020/08/12/62. Unique Paths/","link":"","permalink":"http://yoursite.com/2020/08/12/62.%20Unique%20Paths/","excerpt":"问题描述A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). How many possible unique paths are there?","text":"问题描述A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). How many possible unique paths are there? Example 1: 1234567Input: m &#x3D; 3, n &#x3D; 2Output: 3Explanation:From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:1. Right -&gt; Right -&gt; Down2. Right -&gt; Down -&gt; Right3. Down -&gt; Right -&gt; Right Example 2: 12Input: m &#x3D; 7, n &#x3D; 3Output: 28 Constraints: 1 &lt;= m, n &lt;= 100 It’s guaranteed that the answer will be less than or equal to 2 * 10 ^ 9. 解题思路 含义：当机器人从左上角走到(i, j) 这个位置时，一共有 dp[i] [j] 种路径。 关系：由于机器人可以向下走或者向右走，所以有两种方式到达一种是从 (i-1, j) 这个位置走一步到达一种是从(i, j - 1) 这个位置走一步到达因为是计算所有可能的步骤，所以是把所有可能走的路径都加起来，所以关系式是 dp[i] [j] = dp[i-1] [j] + dp[i] [j-1]。 初始值：初始值是计算出所有的 dp[0] [0….n-1] 和所有的 dp[0….m-1] [0]。 代码如下： 12345678910111213141516171819202122232425262728/** * @param &#123;number&#125; m * @param &#123;number&#125; n * @return &#123;number&#125; */var uniquePaths = function(m, n) &#123; if (m&lt;=0 || n&lt;=0) &#123; return 0; &#125; var dp = new Array(m).fill(new Array(n)); // 初始化 for (var i=0;i&lt;m;i++) &#123; dp[i][0] = 1; &#125; for (var i=0;i&lt;n;i++) &#123; dp[0][i] = 1; &#125; for (var i=1;i&lt;m;i++) &#123; for (var j=1;j&lt;n;j++) &#123; dp[i][j]=dp[i-1][j]+dp[i][j-1]; &#125; &#125; return dp[m-1][n-1];&#125;; 时间复杂度：O(nm)空间复杂度：O(nm)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/tags/Leetcode/"}]},{"title":"49. Group Anagrams","slug":"49. Group Anagrams","date":"2020-08-09T00:00:00.000Z","updated":"2020-08-09T10:03:39.373Z","comments":true,"path":"2020/08/09/49. Group Anagrams/","link":"","permalink":"http://yoursite.com/2020/08/09/49.%20Group%20Anagrams/","excerpt":"问题描述Given an array of strings, group anagrams together. Example: 1234567Input: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],Output:[ [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] Note: All inputs will be in lowercase.The order of your output does not matter.","text":"问题描述Given an array of strings, group anagrams together. Example: 1234567Input: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],Output:[ [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] Note: All inputs will be in lowercase.The order of your output does not matter. 解题思路 将数组strs中的字符串元素排序后连成新的字符串； 使用hash表记录，排序后的字符串； 若是属于同一组的字符串，经过排序后的到的字符串是完全相同的，将相同排序的字符串压入统一key对应的value； 返回hash表的所有value即为目标。 代码入戏： 1234567891011121314151617/** * @param &#123;string[]&#125; strs * @return &#123;string[][]&#125; */var groupAnagrams = function(strs) &#123; var map = &#123;&#125;; for (let str of strs) &#123; var key = [...str].sort().join(''); if (!map[key]) &#123; map[key] = []; &#125; map[key].push(str) &#125; return Object.values(map)&#125;; 时间复杂度：O(n2)空间复杂度：O(n2)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/categories/Leetcode/"}],"tags":[{"name":"Leetcode; JavaScript","slug":"Leetcode-JavaScript","permalink":"http://yoursite.com/tags/Leetcode-JavaScript/"}]},{"title":"47. Permutations II","slug":"47. Permutations II","date":"2020-08-08T00:00:00.000Z","updated":"2020-08-08T12:57:42.217Z","comments":true,"path":"2020/08/08/47. Permutations II/","link":"","permalink":"http://yoursite.com/2020/08/08/47.%20Permutations%20II/","excerpt":"问题描述Given a collection of numbers that might contain duplicates, return all possible unique permutations. Example: 1234567Input: [1,1,2]Output:[ [1,1,2], [1,2,1], [2,1,1]]","text":"问题描述Given a collection of numbers that might contain duplicates, return all possible unique permutations. Example: 1234567Input: [1,1,2]Output:[ [1,1,2], [1,2,1], [2,1,1]] 解题思路思路如下： 因为这个问题中包含重复元素，所以一个简单的处理方法是，先将输入的nums排序，这样重复元素就会到一块。然后，我们采用递归回溯的思想就可以解决。 借助一个数组visited，来记录某元素是否被访问过，若是访问过，则不被记录。 创建一个数组current，来记录某个可能的排列，若是current数组长度达到最大，则推入result数组。 通过nums[i] == nums[i-1]来去处重复的排列。 代码如下： 123456789101112131415161718192021222324252627/** * @param &#123;number[]&#125; nums * @return &#123;number[][]&#125; */var permuteUnique = function(nums) &#123; let result = []; let visited = new Array(nums.length).fill(false); nums.sort((a, b) =&gt; a - b); function dfs(nums, current, visited) &#123; if(current.length == nums.length) &#123; result.push(current); return; &#125; for (let i = 0; i &lt; nums.length; i++) &#123; if (visited[i] || (i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; !visited[i-1]))&#123; continue; &#125; visited[i] = true; dfs(nums, current.concat(nums[i]), visited); visited[i] = false; &#125; &#125; dfs(nums, [], visited); return result;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/tags/Leetcode/"}]},{"title":"766. Toeplitz Matrix","slug":"766. Toeplitz Matrix","date":"2020-08-06T22:44:40.000Z","updated":"2020-08-06T14:53:02.054Z","comments":true,"path":"2020/08/07/766. Toeplitz Matrix/","link":"","permalink":"http://yoursite.com/2020/08/07/766.%20Toeplitz%20Matrix/","excerpt":"问题描述A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element. Now given an M x N matrix, return True if and only if the matrix is Toeplitz.","text":"问题描述A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element. Now given an M x N matrix, return True if and only if the matrix is Toeplitz. Example 1: 1234567891011Input:matrix &#x3D; [ [1,2,3,4], [5,1,2,3], [9,5,1,2]]Output: TrueExplanation:In the above grid, the diagonals are:&quot;[9]&quot;, &quot;[5, 5]&quot;, &quot;[1, 1, 1]&quot;, &quot;[2, 2, 2]&quot;, &quot;[3, 3]&quot;, &quot;[4]&quot;.In each diagonal all elements are the same, so the answer is True. Example 2: 12345678Input:matrix &#x3D; [ [1,2], [2,2]]Output: FalseExplanation:The diagonal &quot;[1, 2]&quot; has different elements. Note: matrix will be a 2D array of integers. matrix will have a number of rows and columns in range [1, 20]. matrix[i][j] will be integers in range [0, 99]. Follow up: What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once? What if the matrix is so large that you can only load up a partial row into the memory at once? 解题思路 从matrix最后一行第一个元素开始，逐步向上对角线处探寻； 若是对角线上元素相等，继续，直到到达matrix最上层； 若是不相等，返回false； 遍历结束后，上三角未遍历到，故，需要再次遍历； 此过程同上几步； 结束。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041/** * @param &#123;number[][]&#125; matrix * @return &#123;boolean&#125; */var isToeplitzMatrix = function(matrix) &#123; var n = matrix.length; var len = matrix[0].length; if (len===1) return true; for (var i=1;i&lt;len;i++) &#123; var j=n-1; var k = i; while (k&gt;0 &amp;&amp; j&gt;0) &#123; // console.log(matrix[j-1][k-1]) if (matrix[j][k] === matrix[j-1][k-1]) &#123; j = j-1; k = k-1; // console.log(j) &#125; else &#123; return false; &#125; &#125; &#125; for (var i=n-2; i&gt;0; i--) &#123; var j = len -1; var k = i; console.log(matrix[k][j]) while (k&gt;0 &amp;&amp; j&gt;0) &#123; // console.log(matrix[k][j]) if (matrix[k][j] === matrix[k-1][j-1]) &#123; k--; j--; &#125; else &#123; return false; &#125; &#125; &#125; return true;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/tags/Leetcode/"}]},{"title":"456. 132 Pattern","slug":"456. 132 Pattern","date":"2020-08-05T00:00:00.000Z","updated":"2020-08-05T13:32:31.627Z","comments":true,"path":"2020/08/05/456. 132 Pattern/","link":"","permalink":"http://yoursite.com/2020/08/05/456.%20132%20Pattern/","excerpt":"问题描述Given a sequence of n integers a1, a2, …, an, a 132 pattern is a subsequence ai, aj, ak such that i &lt; j &lt; k and ai &lt; ak &lt; aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list. Note: n will be less than 15,000. 123456Example 1:Input: [1, 2, 3, 4]Output: FalseExplanation: There is no 132 pattern in the sequence.","text":"问题描述Given a sequence of n integers a1, a2, …, an, a 132 pattern is a subsequence ai, aj, ak such that i &lt; j &lt; k and ai &lt; ak &lt; aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list. Note: n will be less than 15,000. 123456Example 1:Input: [1, 2, 3, 4]Output: FalseExplanation: There is no 132 pattern in the sequence. Example 2: 123456789Input: [3, 1, 4, 2]Output: TrueExplanation: There is a 132 pattern in the sequence: [1, 4, 2].Example 3:Input: [-1, 3, 2, 0]Output: True Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0]. 解题思路 定义一个栈，倒序遍历存储一个新数的时候，弹出里面所有比它小的数字。弹出的这些数就会成为s3的可能选择，记为min 我们维护s3的最大选择（它一定是从栈中最后一个被弹出的数字）； 一旦我们遇到一个比s3小的数，就说明我们找到了合法的序列s1 &lt; s3。由于s2 &gt; s3，所以一定可以推导出s1 &lt; s2。 代码如下： 1234567891011121314151617181920/** * @param &#123;number[]&#125; nums * @return &#123;boolean&#125; */var find132pattern = function(nums) &#123; if (nums.length &lt; 3) return false; var stack = []; var min = -Infinity; for (var i=nums.length-1; i&gt;=0;i--) &#123; if (nums[i] &lt; min) return true; while (stack.length&gt;0 &amp;&amp; nums[i]&gt; stack[stack.length-1]) &#123; min = stack.pop(); &#125; stack.push(nums[i]); &#125; return false;&#125;; 时间复杂度：O(n)空间复杂度：O(n)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/tags/Leetcode/"}]},{"title":"131. Palindrome Partitioning","slug":"131. Palindrome Partitioning","date":"2020-08-04T22:44:40.000Z","updated":"2020-08-04T15:00:35.083Z","comments":true,"path":"2020/08/05/131. Palindrome Partitioning/","link":"","permalink":"http://yoursite.com/2020/08/05/131.%20Palindrome%20Partitioning/","excerpt":"问题描述Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s. Example: 123456Input: &quot;aab&quot;Output:[ [&quot;aa&quot;,&quot;b&quot;], [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]]","text":"问题描述Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s. Example: 123456Input: &quot;aab&quot;Output:[ [&quot;aa&quot;,&quot;b&quot;], [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]] 解题思路 dfs进行遍历，将所有可能性压入result； 遍历字符串，通过索引i将字符串分为两部分进行看待； 判断i前面的部分是否为回文串，若是，压入存储数组arr； 索引i后半部分，进行回溯，用dfs方法遍历i后半部分字符串中是否包含回文串，列出所有可能性； 遍历到str末尾，将存储数组压入result中； 返回result即为目标所得。 代码如下： 12345678910111213141516171819202122232425262728293031/** * @param &#123;string&#125; s * @return &#123;string[][]&#125; */var partition = function(s) &#123; function isPalindrome(str) &#123; let left = 0, right = str.length-1; while(left &lt; right) &#123; if(str[left] !== str[right]) return false left++; right--; &#125; return true; &#125; function dfs(arr, str) &#123; if(!str.length) result.push(arr); for(let i = 1; i &lt;= str.length; i++) &#123; const subStr = str.slice(0, i); if(isPalindrome(subStr)) &#123; dfs([...arr, subStr], str.slice(i)); &#125; &#125; &#125; const result = []; dfs([], s); return result;&#125;; 时间复杂度：O(2^n) 空间复杂度：O(n)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/tags/Leetcode/"}]},{"title":"215. Kth Largest Element in an Array","slug":"215. Kth Largest Element in an Array","date":"2020-08-02T00:00:00.000Z","updated":"2020-08-02T12:42:48.190Z","comments":true,"path":"2020/08/02/215. Kth Largest Element in an Array/","link":"","permalink":"http://yoursite.com/2020/08/02/215.%20Kth%20Largest%20Element%20in%20an%20Array/","excerpt":"问题描述Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. 1234Example 1:Input: [3,2,1,5,6,4] and k &#x3D; 2Output: 5","text":"问题描述Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. 1234Example 1:Input: [3,2,1,5,6,4] and k &#x3D; 2Output: 5 Example 2: 12Input: [3,2,3,1,2,4,5,5,6] and k &#x3D; 4Output: 4 Note:You may assume k is always valid, 1 ≤ k ≤ array’s length. 解题思路排序后，第k-1个元素即是目标元素。 代码如下： 12345678910&#x2F;** * @param &#123;number[]&#125; nums * @param &#123;number&#125; k * @return &#123;number&#125; *&#x2F;var findKthLargest &#x3D; function(nums, k) &#123; nums.sort((a, b) &#x3D;&gt; &#123;return b-a&#125;); console.log(nums) return nums[k-1]&#125;; 时间复杂度：//空间复杂度：O(1)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/tags/Leetcode/"}]},{"title":"653. Two Sum IV - Input is a BST","slug":"653. Two Sum IV - Input is a BST","date":"2020-08-02T00:00:00.000Z","updated":"2020-08-02T12:42:04.317Z","comments":true,"path":"2020/08/02/653. Two Sum IV - Input is a BST/","link":"","permalink":"http://yoursite.com/2020/08/02/653.%20Two%20Sum%20IV%20-%20Input%20is%20a%20BST/","excerpt":"题目描述Given a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target. Example 1: 12345678910Input: 5 &#x2F; \\ 3 6 &#x2F; \\ \\2 4 7Target &#x3D; 9Output: True","text":"题目描述Given a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target. Example 1: 12345678910Input: 5 &#x2F; \\ 3 6 &#x2F; \\ \\2 4 7Target &#x3D; 9Output: True Example 2: 12345678910Input: 5 &#x2F; \\ 3 6 &#x2F; \\ \\2 4 7Target &#x3D; 28Output: False 解题思路对二叉搜索树进行深度遍历，题中要求为，2个元素相加为target，所以新建一个set，保存遍历的每一个数据，同时在遍历过程中，用target-root.val，若set中存在target-root.val，则满足题目条件，最后，分别到左右子树继续进行遍历。 代码如下： 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @param &#123;number&#125; k * @return &#123;boolean&#125; */var findTarget = function(root, k) &#123; let set = new Set(); return dfs(root); function dfs(root) &#123; if(!root) &#123; return false; &#125; if(set.has(k - root.val)) return true; set.add(root.val); return dfs(root.left) || dfs(root.right); &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(n)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/tags/Leetcode/"}]},{"title":"1395. Count Number of Teams","slug":"1395. Count Number of Teams ","date":"2020-07-31T00:00:00.000Z","updated":"2020-07-31T15:12:16.440Z","comments":true,"path":"2020/07/31/1395. Count Number of Teams /","link":"","permalink":"http://yoursite.com/2020/07/31/1395.%20Count%20Number%20of%20Teams%20/","excerpt":"问题描述There are n soldiers standing in a line. Each soldier is assigned a unique rating value. You have to form a team of 3 soldiers amongst them under the following rules: Choose 3 soldiers with index (i, j, k) with rating (rating[i], rating[j], rating[k]).A team is valid if: (rating[i] &lt; rating[j] &lt; rating[k]) or (rating[i] &gt; rating[j] &gt; rating[k]) where (0 &lt;= i &lt; j &lt; k &lt; n).Return the number of teams you can form given the conditions. (soldiers can be part of multiple teams). Example 1: 123Input: rating &#x3D; [2,5,3,4,1]Output: 3Explanation: We can form three teams given the conditions. (2,3,4), (5,4,1), (5,3,1).","text":"问题描述There are n soldiers standing in a line. Each soldier is assigned a unique rating value. You have to form a team of 3 soldiers amongst them under the following rules: Choose 3 soldiers with index (i, j, k) with rating (rating[i], rating[j], rating[k]).A team is valid if: (rating[i] &lt; rating[j] &lt; rating[k]) or (rating[i] &gt; rating[j] &gt; rating[k]) where (0 &lt;= i &lt; j &lt; k &lt; n).Return the number of teams you can form given the conditions. (soldiers can be part of multiple teams). Example 1: 123Input: rating &#x3D; [2,5,3,4,1]Output: 3Explanation: We can form three teams given the conditions. (2,3,4), (5,4,1), (5,3,1). Example 2: 123Input: rating &#x3D; [2,1,3]Output: 0Explanation: We can&#39;t form any team given the conditions. Example 3: 12Input: rating &#x3D; [1,2,3,4]Output: 4 Constraints: n == rating.length 1 &lt;= n &lt;= 200 1 &lt;= rating[i] &lt;= 10^5 解题思路暴力解法 1234567891011121314var numTeams = function(rating) &#123; var n = rating.length; var result = 0; for (var i = 0; i &lt; n; ++i) &#123; for (var j = i + 1; j &lt; n; ++j) &#123; for (var k = j + 1; k &lt; n; ++k) &#123; if (rating[i] &lt; rating[j] &amp;&amp; rating[j] &lt; rating[k] || rating[i] &gt; rating[j] &amp;&amp; rating[j] &gt; rating[k]) &#123; result++; &#125; &#125; &#125; &#125; return result;&#125;; 时间复杂度：O(n3)空间复杂度：O(1)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/tags/Leetcode/"}]},{"title":"287. Find the Duplicate Number","slug":"287. Find the Duplicate Number","date":"2020-07-30T00:00:00.000Z","updated":"2020-07-30T14:08:06.832Z","comments":true,"path":"2020/07/30/287. Find the Duplicate Number/","link":"","permalink":"http://yoursite.com/2020/07/30/287.%20Find%20the%20Duplicate%20Number/","excerpt":"问题描述Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one. Example 1: 12Input: [1,3,4,2,2]Output: 2 Example 2: 12Input: [3,1,3,4,2]Output: 3","text":"问题描述Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one. Example 1: 12Input: [1,3,4,2,2]Output: 2 Example 2: 12Input: [3,1,3,4,2]Output: 3 Note: You must not modify the array (assume the array is read only). You must use only constant, O(1) extra space. Your runtime complexity should be less than O(n2). There is only one duplicate number in the array, but it could be repeated more than once. 解题思路二分法 数组中的数范围是确定的，并且，给定一个数k，如果小于等于k的数的个数是大于k的，那么说明重复的数一定在[left,k]中。 对于一个数k而言，如果[left,k]中没有重复元素的话，小于等于该元素的个数最多有k个，如果多余k个说明一定存在重复元素。 即定义一个中位数，值为选定nums集合内最大值和最小值的平均值。如果：小于等于 4 的个数如果严格大于 4 个，此时重复元素一定出现在 [1, 4] 区间里。 代码入戏： 12345678910111213141516171819202122var findDuplicate = function(nums) &#123; let low = 1 let high = nums.length - 1 while (low &lt; high)&#123; let count = 0 const mid = low + (high-low) / 2 for (let num of nums)&#123; if (num&lt;=mid)&#123; count++ &#125; &#125; if (count &lt;= mid)&#123; low = mid + 1 &#125; else &#123; high = mid &#125; &#125; return Math.floor(low)&#125;; 时间复杂度：O(nlg(n));空间复杂度：O(1)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/tags/Leetcode/"}]},{"title":"53. Maximum Subarray","slug":"53-Maximum-Subarray","date":"2020-07-29T22:44:40.000Z","updated":"2020-07-29T14:56:55.109Z","comments":true,"path":"2020/07/30/53-Maximum-Subarray/","link":"","permalink":"http://yoursite.com/2020/07/30/53-Maximum-Subarray/","excerpt":"题目描述Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Example: 123456Input: [-2,1,-3,4,-1,2,1,-5,4],Output: 6Explanation: [4,-1,2,1] has the largest sum &#x3D; 6.Follow up:If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.","text":"题目描述Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Example: 123456Input: [-2,1,-3,4,-1,2,1,-5,4],Output: 6Explanation: [4,-1,2,1] has the largest sum &#x3D; 6.Follow up:If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. 解题思路 目标是获取连续子数组的最大和； 进行累加的过程中，选择维护两个变量，累加和sum以及最大值max； 解题过程中，需要保持sum最大，max最大； 当前索引idx处，进行累加运算，此操作可能使sum变小，或者变大； sum变小情况下，需进行维护sum最大操作，sum最大值在sum与nums[idx]中产生； 即将sum与数组nums[i]值进行比较，使得sum总能保持累加的过程中最大，且可保证连续； 将sum与最大值max比较，取最大者，最后得到target值。 代码如下： 123456789101112131415/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var maxSubArray = function(nums) &#123; var sum = 0; var max = -Number.MAX_VALUE; for (var i=0;i&lt;nums.length;i++) &#123; sum = sum + nums[i]; sum = Math.max(sum, nums[i]); max = Math.max(sum, max); &#125; return max;&#125;; 时间复杂度：O(n)空间复杂度：O(1)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/tags/Leetcode/"}]},{"title":"55. Jump Game","slug":"55. Jump Game","date":"2020-07-28T00:00:00.000Z","updated":"2020-07-29T14:45:40.439Z","comments":true,"path":"2020/07/28/55. Jump Game/","link":"","permalink":"http://yoursite.com/2020/07/28/55.%20Jump%20Game/","excerpt":"题目描述Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. Example 1: 123Input: nums &#x3D; [2,3,1,1,4]Output: trueExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2: 123Input: nums &#x3D; [3,2,1,0,4]Output: falseExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.","text":"题目描述Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. Example 1: 123Input: nums &#x3D; [2,3,1,1,4]Output: trueExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2: 123Input: nums &#x3D; [3,2,1,0,4]Output: falseExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index. Constraints: 1 &lt;= nums.length &lt;= 3 * 10^4 0 &lt;= nums[i][j] &lt;= 10^5 解题思路递归法12345678910111213141516171819var canJump = function(nums) &#123; if (nums.length === 1) return true; if (nums[0] == 0) return false; return jump(nums,0);&#125;;var jump = function(nums, start) &#123; var index = nums.length - 1; for (var i=1; i&lt;=nums[start];i++) &#123; if (i+start&gt;=index) &#123; return true; &#125;; if (jump(nums,i+start)) return true; &#125; return false;&#125; 时间复杂度：O(n!)空间复杂度: O(1) 贪心算法每在一个位置，都有可以到达的最远的距离，在最远距离的范围内进行循环，判断是否可以到达最后，如果最远距离大于等于最后位置的索引，表示可以到达末尾，并且不断更新最远的距离。 1234567891011121314var canJump = function(nums) &#123; var len = nums.length - 1; var max_pos = 0; var current_idx = 0; while(current_idx &lt;= max_pos) &#123; max_pos = Math.max(nums[current_idx]+current_idx, max_pos); if (max_pos &gt;= len) return true; current_idx++; &#125; return false;&#125; 时间复杂度：O(n)空间复杂度：O(1)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/tags/Leetcode/"}]},{"title":"73. Set Matrix Zeroes","slug":"73. Set Matrix Zeroes ","date":"2020-07-28T00:00:00.000Z","updated":"2020-07-28T14:04:36.678Z","comments":true,"path":"2020/07/28/73. Set Matrix Zeroes /","link":"","permalink":"http://yoursite.com/2020/07/28/73.%20Set%20Matrix%20Zeroes%20/","excerpt":"","text":"题目描述Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place. Example 1: 123456789101112Input: [ [1,1,1], [1,0,1], [1,1,1]]Output: [ [1,0,1], [0,0,0], [1,0,1]] Example 2: 123456789101112Input: [ [0,1,2,0], [3,4,5,2], [1,3,1,5]]Output: [ [0,0,0,0], [0,4,5,0], [0,3,1,0]] Follow up: A straight forward solution using O(mn) space is probably a bad idea.A simple improvement uses O(m + n) space, but still not the best solution.Could you devise a constant space solution? 解题思路通过两个数组记录matrix中0出现为止的行列索引，之后进行二次遍历，所在行/列出现过0，即设为0，可得到目标matrix。 代码如下： 12345678910111213141516171819202122var setZeroes = function(matrix) &#123; if (matrix.length === 0) return []; var line = []; var row = []; for (var i=0;i&lt;matrix.length;i++) &#123; for (var j=0;j&lt;matrix[i].length;j++) &#123; if (matrix[i][j] == 0) &#123; row.push(i); line.push(j); &#125; &#125; &#125; for (var i=0;i&lt;matrix.length;i++) &#123; for (var j=0;j&lt;matrix[i].length;j++) &#123; if (line.indexOf(j) !=-1 || row.indexOf(i) !=-1) matrix[i][j] = 0; &#125; &#125; return matrix&#125;; 时间复杂度：O(n2)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/tags/Leetcode/"}]},{"title":"31. Next Permutation","slug":"31. Next Permutation","date":"2020-07-25T00:00:00.000Z","updated":"2020-07-26T16:19:15.684Z","comments":true,"path":"2020/07/25/31. Next Permutation/","link":"","permalink":"http://yoursite.com/2020/07/25/31.%20Next%20Permutation/","excerpt":"问题描述Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1231,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1","text":"问题描述Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1231,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 解题思路以[1，2，7，4，3，1]为例： 我们要找下一个更大的数字，通过观察问题描述中的例子，可以简单的发现，解题步骤中会发生数字的交换，那么怎样找到两个要交换的数字呢？交换后，数组是否需要进行一些处理呢？ 下面以[1，2，7，4，3，1]为例： 下一个排列为： 11 3 1 2 4 7 通过结果反向推演可以看到过程如下； 12345671 2 7 4 3 11 2 7 4 3 11 3 7 4 2 11 3 1 2 4 7 可以发现，如果从末尾往前看，数字逐渐变大，到了2时才减小的，然后再从后往前找第一个比2大的数字，是3，那么我们交换2和3，再把此时3后面的所有数字转置一下即可。 代码JavaScript 123456789101112131415161718192021222324252627282930&#x2F;** * @param &#123;number[]&#125; nums * @return &#123;void&#125; Do not return anything, modify nums in-place instead. *&#x2F;var nextPermutation &#x3D; function(nums) &#123; var index &#x3D; nums.length - 2; while(index&gt;&#x3D;0 &amp;&amp; nums[index+1] &lt;&#x3D; nums[index]) --index; if (index&gt;&#x3D;0) &#123; var key &#x3D; nums.length - 1; while(key&lt; nums.length &amp;&amp; nums[key] &lt;&#x3D; nums[index]) key--; swap(key, index); &#125; reverse(index+1); function swap(i, j) &#123; let temp &#x3D; nums[i]; nums[i] &#x3D; nums[j]; nums[j] &#x3D; temp; &#125; function reverse(start) &#123; let end &#x3D; nums.length - 1; while (start &lt; end) &#123; swap(start, end); start++; end--; &#125; &#125;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/tags/Leetcode/"}]},{"title":"29. Divide Two Integers","slug":"29. Divide Two Integers","date":"2020-07-25T00:00:00.000Z","updated":"2020-07-26T16:30:34.623Z","comments":true,"path":"2020/07/25/29. Divide Two Integers/","link":"","permalink":"http://yoursite.com/2020/07/25/29.%20Divide%20Two%20Integers/","excerpt":"题目描述Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. Return the quotient after dividing dividend by divisor. The integer division should truncate toward zero, which means losing its fractional part. For example, truncate(8.345) = 8 and truncate(-2.7335) = -2. Example 1: 1234Input: dividend &#x3D; 10, divisor &#x3D; 3Output: 3Explanation: 10&#x2F;3 &#x3D; truncate(3.33333..) &#x3D; 3.Example 2: 123Input: dividend &#x3D; 7, divisor &#x3D; -3Output: -2Explanation: 7&#x2F;-3 &#x3D; truncate(-2.33333..) &#x3D; -2.","text":"题目描述Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. Return the quotient after dividing dividend by divisor. The integer division should truncate toward zero, which means losing its fractional part. For example, truncate(8.345) = 8 and truncate(-2.7335) = -2. Example 1: 1234Input: dividend &#x3D; 10, divisor &#x3D; 3Output: 3Explanation: 10&#x2F;3 &#x3D; truncate(3.33333..) &#x3D; 3.Example 2: 123Input: dividend &#x3D; 7, divisor &#x3D; -3Output: -2Explanation: 7&#x2F;-3 &#x3D; truncate(-2.33333..) &#x3D; -2. Note: Both dividend and divisor will be 32-bit signed integers. The divisor will never be 0. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For the purpose of this problem, assume that your function returns 231 − 1 when the division result overflows. 解题思路二分法时间复杂度：O(lg(n)) 1234567891011121314151617181920212223242526272829303132333435var divide &#x3D; function(dividend, divisor) &#123; if (dividend&#x3D;&#x3D;&#x3D;2147483647 &amp;&amp; divisor&#x3D;&#x3D;1) return 2147483647; if (dividend&#x3D;&#x3D;&#x3D;-2147483648 &amp;&amp; divisor&#x3D;&#x3D;1) return -2147483648; if (dividend&#x3D;&#x3D;0) return 0; if (Math.abs(dividend) &lt; Math.abs(divisor)) return 0; if (dividend*divisor&gt;0) &#123; var isPositive &#x3D; 1; &#125; else &#123; var isPositive &#x3D; -1; &#125; var result &#x3D; 1; var left &#x3D; 0; var right &#x3D; Math.abs(dividend); dividend &#x3D; Math.abs(dividend); divisor &#x3D; Math.abs(divisor); var middle &#x3D; Math.floor((left+right)&#x2F;2); while(left+1&lt;right) &#123; if (divisor*middle &#x3D;&#x3D; dividend) return isPositive*middle; if(divisor*middle &lt; dividend) &#123; left &#x3D; middle; &#125; else &#123; right &#x3D; middle; &#125; result &#x3D; middle; if(right-left &lt;&#x3D; 1) &#123; result &#x3D; left; &#125; middle &#x3D; Math.floor((left+right)&#x2F;2); &#125; return isPositive*result; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/tags/Leetcode/"}]},{"title":"异步I/O","slug":"异步IO","date":"2020-07-25T00:00:00.000Z","updated":"2020-07-26T16:26:52.810Z","comments":true,"path":"2020/07/25/异步IO/","link":"","permalink":"http://yoursite.com/2020/07/25/%E5%BC%82%E6%AD%A5IO/","excerpt":"","text":"前言在众多高级编程语言或运行平台中，将异步作为主要编程方式和设计理念的Node是首个。 伴随着异步I/O的还有事件驱动和单线程，他们构成Node的基调。 Node是全方位的，既可以作为服务器端去处理客户端带来的大量并发请求，也能作为客户端向网络中的各个应用进行并发请求。 异步I/O的原因这与Node面向网络设计有关。 用户体验在浏览器中，JavaScript在单线程上执行，而且它还与UI渲染共用一个线程。这意味着，JavaScript在执行的时候UI渲染和响应是处于停滞状态的。 通过异步可以消除UI阻塞的现象，但是前端获取资源的速度也取决于后端响应的速度。 只有后端能够快速响应资源，才能让前端的体验更好。 资源分配假设业务场景中有一组互不相关的任务需要完成，现行的主流方法有以下两种。 单线程串行依次执行 多线程并行完成 多线程的代价在于，创建线程和执行期线程上下文的切换开销较大。此外，在复杂的业务中，多线程编程经常面临死锁、状态同步等问题，但是多线程在多核CPU上能够有效提升CPU的利用率。 单线程同步编程模型会因阻塞I/O导致硬件资源得不到更优的使用。 添加硬件资源是一种提升服务质量的方式，但它不是唯一的方式。 Node在两者之间给出了它的方案：利用单线程，远离多线程死锁、状态同步等问题；利用异步I/O，让单线程远离阻塞，以更好的使用CPU。 为了弥补单线程无法利用多核cpu的缺点，Node提供了类似前端浏览器中Web Workers的子进程，该子进程可以通过工作进程高效的利用CPU和I/O。 异步I/O实现异步I/O与非阻塞I/O从计算机内核I/O而言，异步/同步和阻塞/非阻塞实际上是两回事。 操作系统内核对于I/O只有两种方式：阻塞与非阻塞。在调用阻塞I/O时，应用程序需要等待I/O完成才返回结果。非阻塞I/O和阻塞I/O的差别为调用后会立即返回。 操作系统对计算机进行了抽象，将所有输入输出设备抽象为文件。内核在进行文件I/O操作时，通过文件描述符进行管理，而文件描述符类似于应用程序与系统内核之间的凭证。应用程序如果需要进行I/O调用，需要先打开文件描述符，然后再根据文件描述符去实现文件的数据读写。*此处非阻塞I/O与阻塞I/O的区别在于阻塞I/O完成整个获取数据的过程，而非阻塞I/O则不带数据直接返回，要获取数据，还需要通过文件描述符再次读取。*** 非阻塞I/O返回后，CPU的时间片可以用来处理其他事物，此时的性能提升是明显的。 由于完成的I/O并没有完成，立即返回的并不是业务层期望的数据，而仅仅是当前调用的状态。为了获取完整的数据，应用程序需要重复调用I/O操作来确认是否完成。 这种重复调用判断操作是否完成的技术叫做轮询。 非阻塞带来的麻烦却是需要轮询去确认是否完全完成数据获取，它会让CPU处理状态判断，是对CPU资源的浪费。 现存的轮询技术主要有以下这些： read 它是最原始，性能最低的一种，通过反复调用来检查I/O的状态来完成数据饿读取。在得到最终数据前，CPU一直耗用在等待上。 select 它是在read基础上改进的一种方案，通过对文件描述符上的事件状态来进行判断。 poll 该方案较select有所改进，采用链表的方式避免数组长度的限制，其次他能避免不必要的检查。 epoll 该方案是Linux下效率最高的I/O事件通知机制，在进入轮询的时候如果没有检查到I/O事件，将会进行休眠，直到事件发生将它唤醒。它是真实利用了事件通知、执行回调的方式，而不是遍历查询，所以不会浪费CPU，执行效率较高。 轮询技术满足了非阻塞I/O确保获取完整数据的需求，但是对于应用程序来说，它仍然只能算是一种同步，因为应用程序仍然需要等待I/O完全返回。 理想的非阻塞异步I/O现实的非阻塞异步I/O通过让部分线程进行阻塞I/O或者非阻塞I/O加轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将I/O得到的数据进行传递，这就轻松实现了异步I/O。 glibc的AIO是典型的线程池模拟异步I/O，但是它存在一些难以忍受的缺陷和bug。 Windows下的IOCP，也是一种异步I/O解决方案，它在某种程度上提供了理想的异步I/O：调用异步方法，等待I/O完成之后的通知，执行回调，用户无需考虑轮询。它的内部依旧是线程池原理。 由于Windows和nix平台的差异，*node提供了libuv作为抽象封装层**，使得所有平台兼容性的判断都由这一层来完成，并保证上层的node与下层的自定义线程池及IOCP之间各自独立。 注意⚠️： 我们时常提到Node是单线程的，这里的单线程指的仅仅只是JavaScript执行在单线程中，在Node中，无论是Windows还是*nix，内部完成I/O任务的另有线程池。 Node的异步I/O事件循环Node自身的执行模型——事件循环，正是它使得回调函数十分普遍。 在进程启动时，Node便会创建一个类似于while(true)的循环，每执行一次循环体的过程成为Tick。每个Tick的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调函数。。如果存在关联的回调函数，就执行它们。然后进入下个循环，如果不再有事件处理，就退出进程。 观察者 引入一个概念：观察者 每个事件循环中有一个或者多个观察者，而判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件。 浏览器采用了类似的机制。事件可能来自用户的点击或家在某些文件时产生，这些事件都由对应的观察者。 在Node中，事件主要来源于网络请求、文件I/O等，这些事件对应的观察者有文件I/O观察者、网络I/O观察者等。 观察者将事件进行了分类。 请求对象JavaScript代码到系统内核之间发生了什么。 对于一般的回调函数，函数由我们自行调用，对于Node的异步I/O来说，回调函数却不由开发者来调用。从Javascipt发起调用到内核执行完I/O操作的过渡过程中，存在一种中间产物，它叫做请求对象。 JavaScript层面的代码通过调用C++核心模块进行下层的操作。 从JavaScript调用Node的核心模块，核心模块调用C++内建模块，内建模块通过libuv进行系统调用，这是Node里经典的调用方式。 至此，JavaScript调用立即返回，由JavaScript层面发起的异步调用的第一阶段就此结束。JavaScript线程可以继续执行当前任务的后续操作。当前I/O操作在线程池中等待执行，不管是否阻塞I/O，都不会影响到JavaScript的后续执行，如此就达到了异步的目的。 请求对象是异步I/O过程中的重要产物，所有的状态都保存在这个对象中，包括送入线程池等待执行以及I/O操作完毕后的回调处理。 执行回调组装好请求对象、送入I/O线程池等待执行，实际上完成了异步I/O的第一部分，回调通知是第二部分。 线程池中的I/O操作调用完毕后，会将获取的结果储存在req-&gt;result属性上，然后调用PostQueuedCompletionStatus()通知IOCP，告知当前对象操作以已经完成。 1PostQueuedCompletionStatus((loop) -&gt; iocp, 0, 0, &amp;((req)-&gt;overlapped)) PostQueuedCompletionStatus()方法的作用是向IOCP提交执行状态，并将线程归还线程池，可以通过GetQueuedCompletionStatus()获取提交的状态。 此过程中，还动用了事件循环的I/O观察者。在每次Tick的执行中，它会调用IOCP相关的GetQueuedCompletionStatus()方法检查线程池中是否有执行完的请求，若有，会将请求对象加入到I/O观察者的队列中，然后将其当作事件处理。 I/O观察者回调函数的行为就是取出请求对象的result属性作为参数，取出oncomplete_sym属性作为方法，然后调用执行，以此达到调用JavaScript中传入的回调函数的目的。 事件循环、观察者、请求对象、I/O线程池这四者构成了Node异步I/O模型的基本要素。 非I/O的异步APIsetTimeout()、setInterval()、setImmediate()、process.nextTick() 定时器setTimeout()和setInterval()的实现原理与异步I/O的实现比较类似，但是没有线程池的参与。 setTimeout()和setInterval()创建的定时器会被插入到定时器观察者内部的一个红黑树中。每次Tick执行时，会从该红黑树中迭代取出定时器对象，检查超过是否超过定时时间，如果超过，就形成一个事件，它的回调函数立即执行。 定时器的问题在于，它并非精确的（在容忍范围内）。 process.nextTick()process.nextTick()的操作相比setTimeout()较为轻量。 具体代码如下： 12345678910111213process.nextTick &#x3D; function(callback) &#123; if(process._exiting) return; if(tickDepth &gt;&#x3D; process.maxTickDepth) maxTickWarn(); var tock &#x3D; &#123;callback: callback&#125;; if(process.domain) rock.domain &#x3D; process.domain; nextTickQueue.push(tock); if(nextTickQueue.length) &#123; process._needTickCallback(); &#125;&#125; 每次调用process.nextTick()方法，只会将回调函数放入队列中，在下一轮Tick中取出执行。定时器中采用红黑树时间复杂度为O(lg(n))，process.nextTick()的是O(1)，更高效。 setImmediate()1234567process.nextTick(function() &#123; console.log(&#39;nextTick延迟执行&#39;)&#125;);setImmediate(function() &#123; console.log(&#39;setImmediate延迟执行&#39;)&#125;);console.log(&#39;正常执行&#39;) 执行结果： 123正常执行nextTick延迟执行setImmediate延迟执行 从执行结果来看，process.nextTick()的回调函数执行优先级高于setImmediate()，这是因为，事件循环对于观察者的检查是有先后顺序的，process.nextTick()属于idle观察者，setImmediate()属于check观察者。在每一个轮循环检查中idle观察者先于I/O观察者，I/O观察者先于check观察者。 在具体实现上，process.nextTick()的回调函数保存在一个数组中，setImmediate()的结果保存在链表中。在行为上，process.nextTick()在每轮循环中会将数组中的回调函数全部执行，setImmediate()在每轮循环中执行链表中的一个回调函数。 事件驱动和高性能服务器事件驱动的本质，通过祝循环加事件触发的方式来运行程序。 对于网络套接字的处理，Node也用到了异步I/O，网络套接字侦听到的请求都会形成事件交给I/O观察者。事件循环会不停的处理这些网络I/O事件。如果JavaScript有传入回调函数，这些事件将会最终传递到业务逻辑层进行处理。利用Node构建Web服务器，正是在这一个基础上实现的。 经典的服务器模型： 同步式 每进程/每请求 每线程/每请求 Node通过事件驱动的方式处理请求，无需为每一个请求创建额外的对应线程，可以省掉创建线程和销毁线程的开销，同时操作系统在调度任务时，因为线程较少，上下文切换的代价很低。这是Node高性能的一个原因。","categories":[{"name":"Node","slug":"Node","permalink":"http://yoursite.com/categories/Node/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://yoursite.com/tags/Node/"}]},{"title":"JSX简介","slug":"02-JSX简介","date":"2020-05-24T00:00:00.000Z","updated":"2020-05-24T08:35:50.000Z","comments":true,"path":"2020/05/24/02-JSX简介/","link":"","permalink":"http://yoursite.com/2020/05/24/02-JSX%E7%AE%80%E4%BB%8B/","excerpt":"前言1const element &#x3D; &lt;h1&gt;Hello, world!&lt;&#x2F;h1&gt;; 这个标签语法既不是字符串也不是 HTML。它被称为 JSX，是一个 JavaScript 的语法扩展。我们建议在 React 中配合使用 JSX，JSX 可以很好地描述 UI 应该呈现出它应有交互的本质形式。JSX 可能会使人联想到模版语言，但它具有 JavaScript 的全部功能。","text":"前言1const element &#x3D; &lt;h1&gt;Hello, world!&lt;&#x2F;h1&gt;; 这个标签语法既不是字符串也不是 HTML。它被称为 JSX，是一个 JavaScript 的语法扩展。我们建议在 React 中配合使用 JSX，JSX 可以很好地描述 UI 应该呈现出它应有交互的本质形式。JSX 可能会使人联想到模版语言，但它具有 JavaScript 的全部功能。 在 JSX 中嵌入表达式在下面的例子中，我们声明了一个名为 name 的变量，然后在 JSX 中使用它，并将它包裹在大括号中： 1234567const name &#x3D; &#39;Josh Perez&#39;;const element &#x3D; &lt;h1&gt;Hello, &#123;name&#125;&lt;&#x2F;h1&gt;;ReactDOM.render( element, document.getElementById(&#39;root&#39;)); 在 JSX 语法中，你可以在大括号内放置任何有效的 JavaScript 表达式。例如，2 + 2，user.firstName 或 formatName(user) 都是有效的 JavaScript 表达式。 在下面的示例中，我们将调用 JavaScript 函数 formatName(user) 的结果，并将结果嵌入到 &lt;h1&gt; 元素中。 12345678910111213141516171819function formatName(user) &#123; return user.firstName + &#39; &#39; + user.lastName;&#125;const user &#x3D; &#123; firstName: &#39;Harper&#39;, lastName: &#39;Perez&#39;&#125;;const element &#x3D; ( &lt;h1&gt; Hello, &#123;formatName(user)&#125;! &lt;&#x2F;h1&gt;);ReactDOM.render( element, document.getElementById(&#39;root&#39;)); JSX 也是一个表达式在编译之后，JSX 表达式会被转为普通 JavaScript 函数调用，并且对其取值后得到 JavaScript 对象。 也就是说，你可以在 if 语句和 for 循环的代码块中使用 JSX，将 JSX 赋值给变量，把 JSX 当作参数传入，以及从函数中返回 JSX： 123456function getGreeting(user) &#123; if (user) &#123; return &lt;h1&gt;Hello, &#123;formatName(user)&#125;!&lt;&#x2F;h1&gt;; &#125; return &lt;h1&gt;Hello, Stranger.&lt;&#x2F;h1&gt;;&#125; JSX 特定属性你可以通过使用引号，来将属性值指定为字符串字面量： const element = &lt;div tabIndex=&quot;0&quot;&gt;&lt;/div&gt;; 也可以使用大括号，来在属性值中插入一个 JavaScript 表达式： const element = &lt;img src={user.avatarUrl}&gt;&lt;/img&gt;; 在属性中嵌入 JavaScript 表达式时，不要在大括号外面加上引号。你应该仅使用引号（对于字符串值）或大括号（对于表达式）中的一个，对于同一属性不能同时使用这两种符号。 因为 JSX 语法上更接近 JavaScript 而不是 HTML，所以 React DOM 使用 camelCase（小驼峰命名）来定义属性的名称，而不使用 HTML 属性名称的命名约定。 例如，JSX 里的 class 变成了 className，而 tabindex 则变为 tabIndex。 使用 JSX 指定子元素假如一个标签里面没有内容，你可以使用/&gt;来闭合标签，就像 XML 语法一样： 1const element &#x3D; &lt;img src&#x3D;&#123;user.avatarUrl&#125; &#x2F;&gt;; JSX 标签里能够包含很多子元素: 123456const element &#x3D; ( &lt;div&gt; &lt;h1&gt;Hello!&lt;&#x2F;h1&gt; &lt;h2&gt;Good to see you here.&lt;&#x2F;h2&gt; &lt;&#x2F;div&gt;); JSX 防止注入攻击你可以安全地在 JSX 当中插入用户输入内容： 123const title &#x3D; response.potentiallyMaliciousInput;&#x2F;&#x2F; 直接使用是安全的：const element &#x3D; &lt;h1&gt;&#123;title&#125;&lt;&#x2F;h1&gt;; React DOM 在渲染所有输入内容之前，默认会进行转义。它可以确保在你的应用中，永远不会注入那些并非自己明确编写的内容。所有的内容在渲染之前都被转换成了字符串。这样可以有效地防止 XSS（cross-site-scripting, 跨站脚本）攻击。 JSX 表示对象Babel 会把 JSX 转译成一个名为 React.createElement() 函数调用。 以下两种示例代码完全等效： 12345678910const element &#x3D; ( &lt;h1 className&#x3D;&quot;greeting&quot;&gt; Hello, world! &lt;&#x2F;h1&gt;);const element &#x3D; React.createElement( &#39;h1&#39;, &#123;className: &#39;greeting&#39;&#125;, &#39;Hello, world!&#39;); React.createElement()会预先执行一些检查，以帮助你编写无错代码，但实际上它创建了一个这样的对象： 12345678&#x2F;&#x2F; 注意：这是简化过的结构const element &#x3D; &#123; type: &#39;h1&#39;, props: &#123; className: &#39;greeting&#39;, children: &#39;Hello, world!&#39; &#125;&#125;; 这些对象被称为 “React 元素”。它们描述了你希望在屏幕上看到的内容。React 通过读取这些对象，然后使用它们来构建 DOM 以及保持随时更新。","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"元素渲染&组件&props","slug":"03-元素渲染&组件&props","date":"2020-05-24T00:00:00.000Z","updated":"2020-05-24T08:39:02.000Z","comments":true,"path":"2020/05/24/03-元素渲染&组件&props/","link":"","permalink":"http://yoursite.com/2020/05/24/03-%E5%85%83%E7%B4%A0%E6%B8%B2%E6%9F%93&%E7%BB%84%E4%BB%B6&props/","excerpt":"元素渲染 元素是构成 React 应用的最小砖块。 元素描述了你在屏幕上想看到的内容。 与浏览器的 DOM 元素不同，React 元素是创建开销极小的普通对象。React DOM 会负责更新 DOM 来与 React 元素保持一致。","text":"元素渲染 元素是构成 React 应用的最小砖块。 元素描述了你在屏幕上想看到的内容。 与浏览器的 DOM 元素不同，React 元素是创建开销极小的普通对象。React DOM 会负责更新 DOM 来与 React 元素保持一致。 元素渲染为DOM 假设你的 HTML 文件某处有一个 &lt;div&gt;： &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; 我们将其称为“根” DOM 节点，因为该节点内的所有内容都将由 React DOM 管理。 仅使用 React 构建的应用通常只有单一的根 DOM 节点。如果你在将 React 集成进一个已有应用，那么你可以在应用中包含任意多的独立根 DOM 节点。 想要将一个 React 元素渲染到根 DOM 节点中，只需把它们一起传入 ReactDOM.render()： 12const element &#x3D; &lt;h1&gt;Hello, world&lt;&#x2F;h1&gt;;ReactDOM.render(element, document.getElementById(&#39;root&#39;)); 页面上会展示出 “Hello, world”。 更新已渲染的元素React 元素是不可变对象。一旦被创建，你就无法更改它的子元素或者属性。一个元素就像电影的单帧：它代表了某个特定时刻的 UI。 根据我们已有的知识，更新 UI 唯一的方式是创建一个全新的元素，并将其传入 ReactDOM.render()。 考虑一个计时器的例子： 1234567891011function tick() &#123; const element &#x3D; ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;&#x2F;h1&gt; &lt;h2&gt;It is &#123;new Date().toLocaleTimeString()&#125;.&lt;&#x2F;h2&gt; &lt;&#x2F;div&gt; ); ReactDOM.render(element, document.getElementById(&#39;root&#39;));&#125;setInterval(tick, 1000); 这个例子会在 setInterval() 回调函数，每秒都调用 ReactDOM.render()。 React 只更新它需要更新的部分React DOM 会将元素和它的子元素与它们之前的状态进行比较，并只会进行必要的更新来使 DOM 达到预期的状态。 组件&amp;props组件允许你将UI拆分为独立可复用的代码片段，并对每个片段进行独立构思。 组件，从概念上类似于JavaScript的函数，它接受任意的入参(即props)，并返回用于描述页面展示内容的React元素。 函数组件与class组件定义组件最简单的方式就是编写 JavaScript 函数： 123function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;&#x2F;h1&gt;;&#125; 该函数是一个有效的 React 组件，因为它接收唯一带有数据的 “props”（代表属性）对象与并返回一个 React 元素。这类组件被称为函数组件，因为它本质上就是 JavaScript 函数。 你同时还可以使用 ES6 的 class 来定义组件： 12345class Welcome extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;&#x2F;h1&gt;; &#125;&#125; 上述两个组件在 React 里是等效的。 组件渲染之前，我们遇到的 React 元素都只是 DOM 标签： const element = &lt;div /&gt;; 不过，React 元素也可以是用户自定义的组件： 1const element &#x3D; &lt;Welcome name&#x3D;&quot;Sara&quot; &#x2F;&gt;; 当 React 元素为用户自定义组件时，它会将 JSX 所接收的属性（attributes）以及子组件（children）转换为单个对象传递给组件，这个对象被称之为 “props”。 例如，这段代码会在页面上渲染 “Hello, Sara”： 123456789function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;&#x2F;h1&gt;;&#125;const element &#x3D; &lt;Welcome name&#x3D;&quot;Sara&quot; &#x2F;&gt;;ReactDOM.render( element, document.getElementById(&#39;root&#39;)); 让我们来回顾一下这个例子中发生了什么： 我们调用 ReactDOM.render() 函数，并传入 &lt;Welcome name=&quot;Sara&quot; /&gt;作为参数。React 调用Welcome组件，并将 {name: &#39;Sara&#39;}作为 props 传入。Welcome 组件将 &lt;h1&gt;Hello, Sara&lt;/h1&gt;元素作为返回值。React DOM 将 DOM 高效地更新为 &lt;h1&gt;Hello, Sara&lt;/h1&gt;。 注意： 组件名称必须以大写字母开头。React 会将以小写字母开头的组件视为原生 DOM 标签。 组合组件组件可以在其输出中引用其他组件。这就可以让我们用同一组件来抽象出任意层次的细节。按钮，表单，对话框，甚至整个屏幕的内容：在 React 应用程序中，这些通常都会以组件的形式表示。 例如，我们可以创建一个可以多次渲染 Welcome 组件的 App 组件： 123456789101112131415161718function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;&#x2F;h1&gt;;&#125;function App() &#123; return ( &lt;div&gt; &lt;Welcome name&#x3D;&quot;Sara&quot; &#x2F;&gt; &lt;Welcome name&#x3D;&quot;Cahal&quot; &#x2F;&gt; &lt;Welcome name&#x3D;&quot;Edite&quot; &#x2F;&gt; &lt;&#x2F;div&gt; );&#125;ReactDOM.render( &lt;App &#x2F;&gt;, document.getElementById(&#39;root&#39;)); 通常来说，每个新的 React 应用程序的顶层组件都是 App 组件。但是，如果你将 React 集成到现有的应用程序中，你可能需要使用像 Button 这样的小组件，并自下而上地将这类组件逐步应用到视图层的每一处。 提取组件将组件拆分为更小的组件。 例如，参考如下 Comment 组件： 123456789101112131415161718192021function Comment(props) &#123; return ( &lt;div className&#x3D;&quot;Comment&quot;&gt; &lt;div className&#x3D;&quot;UserInfo&quot;&gt; &lt;img className&#x3D;&quot;Avatar&quot; src&#x3D;&#123;props.author.avatarUrl&#125; alt&#x3D;&#123;props.author.name&#125; &#x2F;&gt; &lt;div className&#x3D;&quot;UserInfo-name&quot;&gt; &#123;props.author.name&#125; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div className&#x3D;&quot;Comment-text&quot;&gt; &#123;props.text&#125; &lt;&#x2F;div&gt; &lt;div className&#x3D;&quot;Comment-date&quot;&gt; &#123;formatDate(props.date)&#125; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; );&#125; 该组件用于描述一个社交媒体网站上的评论功能，它接收 author（对象），text （字符串）以及 date（日期）作为 props。 该组件由于嵌套的关系，变得难以维护，且很难复用它的各个部分。因此，让我们从中提取一些组件出来。 首先，我们将提取 Avatar 组件： 12345678function Avatar(props) &#123; return ( &lt;img className&#x3D;&quot;Avatar&quot; src&#x3D;&#123;props.user.avatarUrl&#125; alt&#x3D;&#123;props.user.name&#125; &#x2F;&gt; );&#125; Avatar 不需知道它在 Comment 组件内部是如何渲染的。因此，我们给它的 props 起了一个更通用的名字：user，而不是 author。 我们建议从组件自身的角度命名 props，而不是依赖于调用组件的上下文命名。 我们现在针对 Comment 做些微小调整： 123456789101112131415161718function Comment(props) &#123; return ( &lt;div className&#x3D;&quot;Comment&quot;&gt; &lt;div className&#x3D;&quot;UserInfo&quot;&gt; &lt;Avatar user&#x3D;&#123;props.author&#125; &#x2F;&gt; &lt;div className&#x3D;&quot;UserInfo-name&quot;&gt; &#123;props.author.name&#125; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div className&#x3D;&quot;Comment-text&quot;&gt; &#123;props.text&#125; &lt;&#x2F;div&gt; &lt;div className&#x3D;&quot;Comment-date&quot;&gt; &#123;formatDate(props.date)&#125; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; );&#125; 接下来，我们将提取 UserInfo 组件，该组件在用户名旁渲染 Avatar 组件： 12345678910function UserInfo(props) &#123; return ( &lt;div className&#x3D;&quot;UserInfo&quot;&gt; &lt;Avatar user&#x3D;&#123;props.user&#125; &#x2F;&gt; &lt;div className&#x3D;&quot;UserInfo-name&quot;&gt; &#123;props.user.name&#125; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; );&#125; 进一步简化 Comment 组件： 12345678910111213function Comment(props) &#123; return ( &lt;div className&#x3D;&quot;Comment&quot;&gt; &lt;UserInfo user&#x3D;&#123;props.author&#125; &#x2F;&gt; &lt;div className&#x3D;&quot;Comment-text&quot;&gt; &#123;props.text&#125; &lt;&#x2F;div&gt; &lt;div className&#x3D;&quot;Comment-date&quot;&gt; &#123;formatDate(props.date)&#125; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; );&#125; 最初看上去，提取组件可能是一件繁重的工作，但是，在大型应用中，构建可复用组件库是完全值得的。根据经验来看，如果 UI 中有一部分被多次使用（Button，Panel，Avatar），或者组件本身就足够复杂（App，FeedStory，Comment），那么它就是一个可复用组件的候选项。 Props 的只读性组件无论是使用函数声明还是通过 class 声明，都决不能修改自身的 props。来看下这个 sum 函数： 123function sum(a, b) &#123; return a + b;&#125; 这样的函数被称为“纯函数”，因为该函数不会尝试更改入参，且多次调用下相同的入参始终返回相同的结果。 相反，下面这个函数则不是纯函数，因为它更改了自己的入参： 123function withdraw(account, amount) &#123; account.total -&#x3D; amount;&#125; React 非常灵活，但它也有一个严格的规则： 所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。 当然，应用程序的 UI 是动态的，并会伴随着时间的推移而变化。在不违反上述规则的情况下，state 允许 React 组件随用户操作、网络响应或者其他变化而动态更改输出内容。","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"State&生命周期","slug":"04-State&生命周期","date":"2020-05-24T00:00:00.000Z","updated":"2020-05-24T08:39:02.000Z","comments":true,"path":"2020/05/24/04-State&生命周期/","link":"","permalink":"http://yoursite.com/2020/05/24/04-State&%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"前言本文介绍了 React 组件中 state 和生命周期的概念。 在元素渲染章节中，我们只了解了一种更新 UI 界面的方法。通过调用 ReactDOM.render() 来修改我们想要渲染的元素： 1234567891011121314function tick() &#123; const element &#x3D; ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;&#x2F;h1&gt; &lt;h2&gt;It is &#123;new Date().toLocaleTimeString()&#125;.&lt;&#x2F;h2&gt; &lt;&#x2F;div&gt; ); ReactDOM.render( element, document.getElementById(&#39;root&#39;) );&#125;setInterval(tick, 1000);","text":"前言本文介绍了 React 组件中 state 和生命周期的概念。 在元素渲染章节中，我们只了解了一种更新 UI 界面的方法。通过调用 ReactDOM.render() 来修改我们想要渲染的元素： 1234567891011121314function tick() &#123; const element &#x3D; ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;&#x2F;h1&gt; &lt;h2&gt;It is &#123;new Date().toLocaleTimeString()&#125;.&lt;&#x2F;h2&gt; &lt;&#x2F;div&gt; ); ReactDOM.render( element, document.getElementById(&#39;root&#39;) );&#125;setInterval(tick, 1000); 在本章节中，我们将学习如何封装真正可复用的 Clock 组件。它将设置自己的计时器并每秒更新一次。 我们可以从封装时钟的外观开始： 1234567891011121314151617function Clock(props) &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;&#x2F;h1&gt; &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;&#x2F;h2&gt; &lt;&#x2F;div&gt; );&#125;function tick() &#123; ReactDOM.render( &lt;Clock date&#x3D;&#123;new Date()&#125; &#x2F;&gt;, document.getElementById(&#39;root&#39;) );&#125;setInterval(tick, 1000); 然而，它忽略了一个关键的技术细节：Clock 组件需要设置一个计时器，并且需要每秒更新 UI。 理想情况下，我们希望只编写一次代码，便可以让 Clock 组件自我更新： 1234ReactDOM.render( &lt;Clock &#x2F;&gt;, document.getElementById(&#39;root&#39;)); 我们需要在 Clock 组件中添加 “state” 来实现这个功能。 State 与 props 类似，但是 state 是私有的，并且完全受控于当前组件。 将函数组件转换成 class 组件通过以下五步将 Clock 的函数组件转成 class 组件： 创建一个同名的 ES6 class，并且继承于 React.Component。 添加一个空的 render() 方法。 将函数体移动到 render() 方法之中。 在 render() 方法中使用 this.props 替换 props。 删除剩余的空函数声明。 12345678910class Clock extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;&#x2F;h1&gt; &lt;h2&gt;It is &#123;this.props.date.toLocaleTimeString()&#125;.&lt;&#x2F;h2&gt; &lt;&#x2F;div&gt; ); &#125;&#125; 现在 Clock 组件被定义为 class，而不是函数。 每次组件更新时 render 方法都会被调用，但只要在相同的 DOM 节点中渲染 &lt;Clock /&gt;，就仅有一个 Clock 组件的 class 实例被创建使用。这就使得我们可以使用如 state 或生命周期方法等很多其他特性。 向 class 组件中添加局部的 state我们通过以下三步将 date 从 props 移动到 state 中： 把 render() 方法中的 this.props.date 替换成 this.state.date ： 12345678910class Clock extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;&#x2F;h1&gt; &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;&#x2F;h2&gt; &lt;&#x2F;div&gt; ); &#125;&#125; 添加一个 class 构造函数，然后在该函数中为 this.state 赋初值： 123456789101112131415class Clock extends React.Component &#123; constructor(props) &#123; super(props); this.state &#x3D; &#123;date: new Date()&#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;&#x2F;h1&gt; &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;&#x2F;h2&gt; &lt;&#x2F;div&gt; ); &#125;&#125; 通过以下方式将 props 传递到父类的构造函数中： 1234constructor(props) &#123; super(props); this.state &#x3D; &#123;date: new Date()&#125;;&#125; Class 组件应该始终使用 props 参数来调用父类的构造函数。 移除 &lt;Clock /&gt; 元素中的 date 属性：1234ReactDOM.render( &lt;Clock &#x2F;&gt;, document.getElementById(&#39;root&#39;)); 我们之后会将计时器相关的代码添加到组件中。 代码如下： 1234567891011121314151617181920class Clock extends React.Component &#123; constructor(props) &#123; super(props); this.state &#x3D; &#123;date: new Date()&#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;&#x2F;h1&gt; &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;&#x2F;h2&gt; &lt;&#x2F;div&gt; ); &#125;&#125;ReactDOM.render( &lt;Clock &#x2F;&gt;, document.getElementById(&#39;root&#39;)); 接下来，我们会设置 Clock 的计时器并每秒更新它。 将生命周期方法添加到 Class 中在具有许多组件的应用程序中，当组件被销毁时释放所占用的资源是非常重要的。 当 Clock 组件第一次被渲染到 DOM 中的时候，就为其设置一个计时器。这在 React 中被称为挂载（mount）。 同时，当 DOM 中 Clock 组件被删除的时候，应该清除计时器。这在 React 中被称为“卸载（unmount）”。 我们可以为 class 组件声明一些特殊的方法，当组件挂载或卸载时就会去执行这些方法： 123456789101112131415161718192021class Clock extends React.Component &#123; constructor(props) &#123; super(props); this.state &#x3D; &#123;date: new Date()&#125;; &#125; componentDidMount() &#123; &#125; componentWillUnmount() &#123; &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;&#x2F;h1&gt; &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;&#x2F;h2&gt; &lt;&#x2F;div&gt; ); &#125;&#125; 这些方法叫做“生命周期方法”。 componentDidMount() 方法会在组件已经被渲染到 DOM 中后运行，所以，最好在这里设置计时器： 123456componentDidMount() &#123; this.timerID &#x3D; setInterval( () &#x3D;&gt; this.tick(), 1000 );&#125; 接下来把计时器的 ID 保存在 this 之中（this.timerID）。 尽管 this.props 和 this.state 是 React 本身设置的，且都拥有特殊的含义，但是其实你可以向 class 中随意添加不参与数据流（比如计时器 ID）的额外字段。 我们会在 componentWillUnmount() 生命周期方法中清除计时器： 123componentWillUnmount() &#123; clearInterval(this.timerID);&#125; 最后，我们会实现一个叫 tick() 的方法，Clock 组件每秒都会调用它。 使用 this.setState() 来时刻更新组件 state： 12345678910111213141516171819202122232425262728293031323334353637class Clock extends React.Component &#123; constructor(props) &#123; super(props); this.state &#x3D; &#123;date: new Date()&#125;; &#125; componentDidMount() &#123; this.timerID &#x3D; setInterval( () &#x3D;&gt; this.tick(), 1000 ); &#125; componentWillUnmount() &#123; clearInterval(this.timerID); &#125; tick() &#123; this.setState(&#123; date: new Date() &#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;&#x2F;h1&gt; &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;&#x2F;h2&gt; &lt;&#x2F;div&gt; ); &#125;&#125;ReactDOM.render( &lt;Clock &#x2F;&gt;, document.getElementById(&#39;root&#39;)); 现在时钟每秒都会刷新。 正确地使用 State关于 setState() 你应该了解三件事： 不要直接修改 State 例如，此代码不会重新渲染组件： 123456&#x2F;&#x2F; Wrongthis.state.comment &#x3D; &#39;Hello&#39;;而是应该使用 setState():&#x2F;&#x2F; Correctthis.setState(&#123;comment: &#39;Hello&#39;&#125;); 构造函数是唯一可以给 this.state 赋值的地方： State 的更新可能是异步的 出于性能考虑，React 可能会把多个setState()调用合并成一个调用。 因为 this.props 和 this.state 可能会异步更新，所以你不要依赖他们的值来更新下一个状态。 例如，此代码可能会无法更新计数器： 1234&#x2F;&#x2F; Wrongthis.setState(&#123; counter: this.state.counter + this.props.increment,&#125;); 要解决这个问题，可以让 setState() 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数： 1234&#x2F;&#x2F; Correctthis.setState((state, props) &#x3D;&gt; (&#123; counter: state.counter + props.increment&#125;)); 上面使用了箭头函数，不过使用普通的函数也同样可以： 123456&#x2F;&#x2F; Correctthis.setState(function(state, props) &#123; return &#123; counter: state.counter + props.increment &#125;;&#125;); State 的更新会被合并 当你调用 setState() 的时候，React 会把你提供的对象合并到当前的 state。 例如，你的 state 包含几个独立的变量： 1234567constructor(props) &#123; super(props); this.state &#x3D; &#123; posts: [], comments: [] &#125;;&#125; 然后你可以分别调用 setState() 来单独地更新它们： 12345678910111213componentDidMount() &#123; fetchPosts().then(response &#x3D;&gt; &#123; this.setState(&#123; posts: response.posts &#125;); &#125;); fetchComments().then(response &#x3D;&gt; &#123; this.setState(&#123; comments: response.comments &#125;); &#125;);&#125; 这里的合并是浅合并，所以 this.setState({comments})完整保留了 this.state.posts， 但是完全替换了 this.state.comments。 数据是向下流动的不管是父组件或是子组件都无法知道某个组件是有状态的还是无状态的，并且它们也并不关心它是函数组件还是 class 组件。 这就是为什么称 state 为局部的或是封装的的原因。除了拥有并设置了它的组件，其他组件都无法访问。 组件可以选择把它的 state 作为 props 向下传递到它的子组件中： 1&lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;&#x2F;h2&gt; 这对于自定义组件同样适用： 1&lt;FormattedDate date&#x3D;&#123;this.state.date&#125; &#x2F;&gt; FormattedDate 组件会在其 props 中接收参数 date，但是组件本身无法知道它是来自于 Clock 的 state，或是 Clock 的 props，还是手动输入的： 123function FormattedDate(props) &#123; return &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;&#x2F;h2&gt;;&#125; 这通常会被叫做“自上而下”或是“单向”的数据流。任何的 state 总是所属于特定的组件，而且从该 state 派生的任何数据或 UI 只能影响树中“低于”它们的组件。 如果你把一个以组件构成的树想象成一个 props 的数据瀑布的话，那么每一个组件的 state 就像是在任意一点上给瀑布增加额外的水源，但是它只能向下流动。 为了证明每个组件都是真正独立的，我们可以创建一个渲染三个 Clock 的 App 组件： 1234567891011121314function App() &#123; return ( &lt;div&gt; &lt;Clock &#x2F;&gt; &lt;Clock &#x2F;&gt; &lt;Clock &#x2F;&gt; &lt;&#x2F;div&gt; );&#125;ReactDOM.render( &lt;App &#x2F;&gt;, document.getElementById(&#39;root&#39;)); 每个 Clock 组件都会单独设置它自己的计时器并且更新它。 在 React 应用中，组件是有状态组件还是无状态组件属于组件实现的细节，它可能会随着时间的推移而改变。你可以在有状态的组件中使用无状态的组件，反之亦然。","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"HTTP1.0和HTTP1.1的一些区别","slug":"02-http1.0和http2.0的区别","date":"2020-05-21T00:00:00.000Z","updated":"2020-05-21T09:47:34.000Z","comments":true,"path":"2020/05/21/02-http1.0和http2.0的区别/","link":"","permalink":"http://yoursite.com/2020/05/21/02-http1.0%E5%92%8Chttp2.0%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"HTTP1.0和HTTP1.1的一些区别HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在： 缓存处理 在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。","text":"HTTP1.0和HTTP1.1的一些区别HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在： 缓存处理 在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。 带宽优化及网络连接的使用 HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。 错误通知的管理 在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。 Host头处理 在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。 长连接 HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。 HTTP1.1与HTTP2.0的区别 多路复用 HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。 当然HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。 TCP连接有一个预热和保护的过程，先检查数据是否传送成功，一旦成功过，则慢慢加大传输速度。因此对应瞬时并发的连接，服务器的响应就会变慢。所以最好能使用一个建立好的连接，并且这个连接可以支持瞬时并发的请求。 数据压缩 我们知道，http请求和响应都是由【状态行、请求/响应头部、消息主题】三部分组成的。 一般而言，消息主体都会经过gzip压缩，或者本身传输的就是压缩过后的二进制文件（如图片、音频等），但是状态行和头部多是没有经过任何压缩，而是直接以纯文本的方式进行传输的。 然而，随着web功能越来越复杂，请求数量越来越多，随之而来的就是头部的流量越来越多，并且在建立初次链接之后的链接也要发送user-agent等信息，是在是一种浪费。 因此，http2提出了对请求和响应的头部进行压缩，即不再只是压缩主题部分，这种压缩方式就是HAPCK 。 通过压缩，头部大小可以减少一半之多，如果后面重复发送请求，那么可能压缩后的头部大小只有原始大小的 1/10。 HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。 服务器推送 当代网页使用了许多资源:HTML、样式表、脚本、图片等等。在HTTP/1.x中这些资源每一个都必须明确地请求。这可能是一个很慢的过程。浏览器从获取HTML开始，然后在它解析和评估页面的时候，增量地获取更多的资源。因为服务器必须等待浏览器做每一个请求，网络经常是空闲的和未充分使用的。 为了改善延迟，HTTP/2引入了server push，它允许服务端推送资源给浏览器，在浏览器明确地请求之前。一个服务器经常知道一个页面需要很多附加资源，在它响应浏览器第一个请求的时候，可以开始推送这些资源。这允许服务端去完全充分地利用一个可能空闲的网络，改善页面加载时间。 服务器端推送的这些资源其实存在客户端的某处地方，客户端直接从本地加载这些资源就可以了，不用走网络，速度自然是快很多的。 链接：https://www.jianshu.com/p/7bfec28236c3","categories":[{"name":"面试题目","slug":"面试题目","permalink":"http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"}],"tags":[{"name":"计算机网络面试题目","slug":"计算机网络面试题目","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"}]},{"title":"水平垂直居中","slug":"19-水平垂直居中","date":"2020-05-21T00:00:00.000Z","updated":"2020-05-21T09:47:34.000Z","comments":true,"path":"2020/05/21/19-水平垂直居中/","link":"","permalink":"http://yoursite.com/2020/05/21/19-%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/","excerpt":"水平居中行内元素水平居中这里行内元素是指文本text、图像img、按钮超链接等，只需给父元素设置text-align:center即可实现。 1234.center&#123; text-align:center;&#125;&lt;div class&#x3D;&quot;center&quot;&gt;水平居中&lt;&#x2F;div&gt;","text":"水平居中行内元素水平居中这里行内元素是指文本text、图像img、按钮超链接等，只需给父元素设置text-align:center即可实现。 1234.center&#123; text-align:center;&#125;&lt;div class&#x3D;&quot;center&quot;&gt;水平居中&lt;&#x2F;div&gt; 块级元素水平居中定宽块级元素水平居中只需给需要居中的块级元素加margin:0 auto即可，但这里需要注意的是，这里块状元素的宽度width值一定要有 123456.center&#123; width:200px; margin:0 auto; border:1px solid red;&#125;&lt;div class&#x3D;&quot;center&quot;&gt;水平居中&lt;&#x2F;div&gt; 不定宽块级元素水平居中不定宽，即块级元素宽度不固定 方法1：设置table 通过给要居中显示的元素，设置display:table，然后设置margin:0 auto来实现 123456.center&#123; display:table; margin:0 auto; border:1px solid red;&#125;&lt;div class&#x3D;&quot;center&quot;&gt;水平居中&lt;&#x2F;div&gt; 方法2：设置inline-block（多个块状元素） 子元素设置inline-block，同时父元素设置text-align:center 12345678910.center&#123; text-align:center;&#125;.inlineblock-div&#123; display:inline-block;&#125;&lt;div class&#x3D;&quot;center&quot;&gt; &lt;div class&#x3D;&quot;inlineblock-div&quot;&gt;1&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;inlineblock-div&quot;&gt;2&lt;&#x2F;div&gt;&lt;&#x2F;div&gt; 方法3：设置flex布局 只需把要处理的块状元素的父元素设置display:flex, 12345678.center&#123; display:flex; justify-content:center;&#125;&lt;div class&#x3D;&quot;center&quot;&gt; &lt;div class&#x3D;&quot;flex-div&quot;&gt;1&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;flex-div&quot;&gt;2&lt;&#x2F;div&gt;&lt;&#x2F;div&gt; 方法4：position + 负margin； 方法5：position + margin：auto； 方法6：position + transform； 这里方法4、5、6同下面垂直居中一样的道理，只不过需要把top/bottom改为left/right，在垂直居中部分会详细讲述。 垂直居中单行文本垂直居中设置paddingtop = paddingbottom或设置line-height=height； 多行文本垂直居中通过设置父元素table，子元素table-cell和vertical-align vertical-align:middle的意思是把元素放在父元素的中部 块级元素垂直居中 方法1：flex布局 在需要垂直居中的父元素上，设置display:flex和align-items：center 要求：父元素必须显示设置height值 方法2：利用position和top和负margin（需知宽高） 设置元素为absolute/relative/fixed margin=负一半 123456789101112131415.parent &#123; position: relative; width: 200px; height: 200px; border: 1px solid blue;&#125;.child &#123; position: absolute; height: 100px; width: 150px; top: 50%; margin-top: -50px; background-color: red;&#125; 方法3：利用position和top/bottom和margin:auto（注意不是margin:0 auto） position：absolute/relative/fixed top/bottom：0 margin：auto 方法4：利用position和top和transformtransform中translate偏移的百分比就是相对于元素自身的尺寸而言的 12345678910111213.parent &#123; position: relative; width: 200px; height: 200px; border: 1px solid blue;&#125;.child &#123; position: absolute; top: 50%; transform: translate(0, -50%); background-color: red;&#125; 水平垂直居中 方法1：绝对定位+margin:auto 123456789101112div&#123; width: 200px; height: 200px; background: green; position:absolute; left:0; top: 0; bottom: 0; right: 0; margin: auto; &#125; 方法2：绝对定位+负margin 1234567891011div&#123; width:200px; height: 200px; background:green; position: absolute; left:50%; top:50%; margin-left:-100px; margin-top:-100px; &#125; 方法3：绝对定位+transform 12345678910div&#123; width: 200px; height: 200px; background: green; position:absolute; left:50%; &#x2F;* 定位父级的50% *&#x2F; top:50%; transform: translate(-50%,-50%); &#x2F;*自己的50% *&#x2F;&#125; 方法4：flex布局 12345678910111213.box&#123; height:600px; display:flex; justify-content:center; &#x2F;&#x2F;子元素水平居中 align-items:center; &#x2F;&#x2F;子元素垂直居中 &#x2F;* aa只要三句话就可以实现不定宽高水平垂直居中。 *&#x2F; &#125; .box&gt;div&#123; background: green; width: 200px; height: 200px; &#125; 方法5：table-cell实现居中 123display:table-cell;text-align:center;vertical-align: middle;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"栏式布局","slug":"20-栏式布局","date":"2020-05-21T00:00:00.000Z","updated":"2020-05-21T09:47:34.000Z","comments":true,"path":"2020/05/21/20-栏式布局/","link":"","permalink":"http://yoursite.com/2020/05/21/20-%E6%A0%8F%E5%BC%8F%E5%B8%83%E5%B1%80/","excerpt":"三栏式布局 涉及浮动和清除浮动，主要讲解“圣杯”和“双飞翼”两种解决方法。这两种方法实现的都是三栏布局，两边的盒子宽度固定，中间盒子自适应，它们实现的效果是一样的，差别在于其实现的思想。 圣杯布局 圣杯：父盒子包含三个子盒子（左，中，右） 上部和下部各自占领屏幕所有宽度。 上下部之间的部分是一个三栏布局。 三栏布局两侧宽度不变，中间部分自动填充整个区域。 中间部分的高度是三栏中最高的区域的高度。","text":"三栏式布局 涉及浮动和清除浮动，主要讲解“圣杯”和“双飞翼”两种解决方法。这两种方法实现的都是三栏布局，两边的盒子宽度固定，中间盒子自适应，它们实现的效果是一样的，差别在于其实现的思想。 圣杯布局 圣杯：父盒子包含三个子盒子（左，中，右） 上部和下部各自占领屏幕所有宽度。 上下部之间的部分是一个三栏布局。 三栏布局两侧宽度不变，中间部分自动填充整个区域。 中间部分的高度是三栏中最高的区域的高度。 本文会用三种方法来实现圣杯布局，分别是浮动，flexbox以及css grid。 浮动实现12345678910111213141516171819202122232425262728293031323334353637383940&lt;div class&#x3D;&quot;header&quot;&gt;这里是头部&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;container&quot;&gt; &lt;div class&#x3D;&quot;middle&quot;&gt;中间部分&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;left&quot;&gt;左边&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;right&quot;&gt;右边&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;footer&quot;&gt;这里是底部&lt;&#x2F;div&gt;.header,.footer&#123; height:40px; width:100%; background:red;&#125;.footer&#123; clear:both;&#125;.container&#123; padding-left:200px; padding-right:300px;&#125;.container div&#123; postion:relative; float:left;&#125;.middle&#123; width:100%; background:yellow;&#125;.left&#123; width:200px; background:pink; margin-left:-100%; right:200px;&#125;.right&#123; width:300px; background:aqua; margin-right:-300px;&#125; flexbox弹性盒子实现 弹性盒子用来实现圣杯布局特别简单。只需要把中间的部分用flex布局即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;html&gt;&lt;head&gt; &lt;style&gt; div&#123; outline: 2px solid; margin: 5px; &#125; &#x2F;* 以下为整个页面的布局 *&#x2F; .main&#123; display:flex; flex-direction: column; height:100%; &#125; .top, .footer&#123; height: 50px; &#125; &#x2F;* 以下为中间的body布局 *&#x2F; .body&#123; flex:1; display: flex; &#125; .body-main&#123; flex: 1; background-color: yellow; &#125; .body-left, .body-right&#123; width: 100px; &#125; &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;div class&#x3D;&quot;main&quot;&gt; &lt;div class&#x3D;&quot;top&quot;&gt;标题栏&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;body&quot;&gt; &lt;div class&#x3D;&quot;body-left&quot;&gt;左边导航栏&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;body-main&quot;&gt;主内容，自动伸缩&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;body-right&quot;&gt;右边提示栏&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;footer&quot;&gt;页脚栏，使用flex布局&lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 两栏式布局两列自适应布局：左列定宽/不定宽，右列自适应 左列定宽，右列自适应margin + float123456789101112131415161718192021&lt;div class&#x3D;&quot;parent&quot;&gt; &lt;div class&#x3D;&quot;left&quot;&gt;&lt;p&gt;left&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;right-fix&quot;&gt; &lt;div class&#x3D;&quot;right&quot;&gt; &lt;p&gt;right&lt;&#x2F;p&gt;&lt;p&gt;right&lt;&#x2F;p&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&lt;&#x2F;div&gt; .left&#123; float: left; &#x2F;&#x2F;向左浮动 width: 100px; &#x2F;&#x2F;固定宽度 position: relative;&#x2F;&#x2F;由于.left与.right-fix重合，且.right-fix在DOM树上的位置比.left要后，因此.right-fix会遮挡住.left，设置.left为relative可以让其冒出来。 &#125; .right-fix&#123; float: right; &#x2F;&#x2F;向右浮动 width: 100%; &#x2F;&#x2F;为了自适应设为100% margin-left: -100px;&#x2F;&#x2F;由于宽度设为100%，.right-fix遭到浏览器换行处理；因此通过设置负的margin值，在左侧制造出100px的空白，使.right-fix与.left重合（即处于同一行） &#125; .right&#123; margin-left: 120px; &#x2F;&#x2F;由于.left和.right-fix重合了，因此给.right设置一个margin-left，避免内容区（.right）与.left重合。另外，120px - 100px &#x3D; 多出来的20px实际上就相当于.left和.right之间的间隔了。 &#125; absolute12345678910111213141516171819202122&lt;div class&#x3D;&quot;parent&quot;&gt; &lt;div class&#x3D;&quot;left&quot;&gt; &lt;p&gt;left&lt;&#x2F;p&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;right&quot;&gt; &lt;p&gt;right&lt;&#x2F;p&gt; &lt;p&gt;right&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;div&gt;.parent&#123; position: relative;&#125;.left&#123; position: absolute; left: 0; width: 100px;&#125;.right&#123; position: absolute; left: 120px; &#x2F;&#x2F;比.left的left多出20px，相当于间隔 right: 0;&#125; 这种方法是通过absolute配合left/right进行布局： 设置display: absolute后，通过top/right/bottom/left可以实现对元素的位置进行像素级的任意控制。因此，使用left属性即可控制各元素的起始位置，避免重叠。自适应的关键在于left和right属性，在对元素同时设置这两个属性后，元素的宽度便会遭到拉伸，实现自适应。需要注意的是父级元素需要设置display: relative。这种方案很容易理解，但缺点就是不能做到“不定宽”，因为.left和.right的left属性的值高度相关。 table布局1234567891011121314151617181920&lt;div class&#x3D;&quot;parent&quot;&gt; &lt;div class&#x3D;&quot;left&quot;&gt; &lt;p&gt;left&lt;&#x2F;p&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;right&quot;&gt; &lt;p&gt;right&lt;&#x2F;p&gt; &lt;p&gt;right&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;div&gt;.parent&#123; display: table; width: 100%; table-layout: fixed;&#125;.left,.right&#123; display: table-cell;&#125;.left&#123; width: 100px; padding-right: 20px;&#125; 这个方法是表格布局的典型运用。说真的，我也很迷惘要不要使用表格布局，毕竟已经是上个时代的产物了，虽然已经不再用&lt;table&gt;的HTML结构了，但用上相应的CSS其实思路跟以前是变化不大的。这个方法主要是利用了表格(table)的宽度必然等于其所有单元格(table-cell)加起来的总宽度，那么只要表格的宽度一定，其中一个（或几个）单元格的宽度也一定，那么另外一个未设置宽度的单元格则会默认占满剩下的宽度，即实现自适应。 左列不定宽，右列自适应float + BFC1234567891011121314151617&lt;div class&#x3D;&quot;parent&quot;&gt; &lt;div class&#x3D;&quot;left&quot;&gt; &lt;p&gt;left&lt;&#x2F;p&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;right&quot;&gt; &lt;p&gt;right&lt;&#x2F;p&gt; &lt;p&gt;right&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;div&gt;.left&#123; float: left; width: 100px; margin-right: 20px; &#x2F;&#x2F;形成20px的间隔&#125;.right&#123; overflow: hidden; &#x2F;&#x2F;通过设置overflow: hidden来触发BFC特性&#125; 这个方法主要是应用到BFC的一个特性： 浮动元素的块状兄弟元素会无视浮动元素的位置，尽量占满一整行，这样该兄弟元素就会被浮动元素覆盖。 若浮动元素的块状兄弟元素为BFC，则不会占满一整行，而是根据浮动元素的宽度，占据该行剩下的宽度，避免与浮动元素重叠。 浮动元素与其块状BFC兄弟元素之间的margin可以生效，这将继续减少兄弟元素的宽度。 并不是一定要在.right上用overflow: hidden;，只要能触发BFC就好了，另外在IE6上也可以触发haslayout特性（推荐用*zoom: 1;）。由于.right的宽度是自动计算的，不需要设置任何与.left宽度相关的css，因此.left的宽度可以不固定（由内容盒子决定）。 flex12345678910111213141516171819&lt;div class&#x3D;&quot;parent&quot;&gt; &lt;div class&#x3D;&quot;left&quot;&gt; &lt;p&gt;left&lt;&#x2F;p&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;right&quot;&gt; &lt;p&gt;right&lt;&#x2F;p&gt; &lt;p&gt;right&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;div&gt;.parent&#123; display: flex;&#125;.left&#123; margin-right: 20px;&#125;.right&#123; flex: 1;&#125;.left p&#123;width: 200px;&#125; flex布局的自适应我就不多说了，本来就是设计来自适应的，只需要用上flex: 1;，就能让.right分到.parent的宽度减去.left的宽度。","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"脚本化HTTP","slug":"46-脚本化HTTP","date":"2020-05-20T00:00:00.000Z","updated":"2020-05-20T09:40:46.000Z","comments":true,"path":"2020/05/20/46-脚本化HTTP/","link":"","permalink":"http://yoursite.com/2020/05/20/46-%E8%84%9A%E6%9C%AC%E5%8C%96HTTP/","excerpt":"前言本章会说明在没有导致Web浏览器重新加载任何窗口或窗体的内容情况下，脚本如何实现Web浏览器与服务器之间的通信。","text":"前言本章会说明在没有导致Web浏览器重新加载任何窗口或窗体的内容情况下，脚本如何实现Web浏览器与服务器之间的通信。 术语Ajax描述了一种主要使用脚本操纵HTTP的Web应用架构。Ajax应用的主要特点是使用脚本操纵HTTP和Web服务器进行数据交换，不会导致页面重载。Web应用可以使用Ajax技术把用户的交互数据记录到服务器中，也可以开始只显示简单页面，之后按需加载额外的数据和页面组件来提升应用的启动时间。 Comet是和使用脚本操纵HTTP的Web应用架构相关的术语。某种意义上，Comet和Ajax相反。在Ajax中，客户端从服务端“拉”数据，而在Comet中，服务端向客户端“推”数据。 实际上，&lt;script&gt;元素的src属性能设置URL并发起 HTTP GET请求。&lt;script&gt;可以跨域通信而不受限于同源策略。通常，使用基于&lt;script&gt;的Ajax传输协议时，服务器的响应采用JSON编码的数据格式，当执行脚本时，JavaScript解析器能自动将其解码。由于它使用JSON数据格式，因此这种Ajax传输协议也叫JSONP。 所有浏览器都支持XMLHttpRequest对象，它定义了使用脚本操纵HTTP的api，它可以使用get和post，同时能获取任何类型的文本文档。 使用XMLHttpRequest 使用这个HTTP API必须做的第一件事就是实例化XMLHttpRequest对象 1var resuest &#x3D; new XMLHttpRequest(); 可以重用已经存在的XMLHttpRequest，但是注意这将会终止之前通过该对象挂起的任何请求。 一个HTTP请求由4个部分组成 HTTP请求方法 正在请求的url 一个可选的请求头集合，其中可能包含身份验证信息 一个可选的请求主体 服务器返回的HTTP响应包括3部分 一个数字和文字组成的状态码，用来显示请求的成功和失败 一个响应头集合 响应主题 指定请求 发起HTTP请求的下一步是调用XMLHttpRequest对象的open()方法去指定这个请求的两个必须部分：方法和url 1request.open(&quot;GET&quot;, &quot;data.csv&quot;); open()的第一个参数指定HTTP方法，支持“GET”和“POST”请求，也支持把“HEAD”,“DELETE”,“OPTIONS”,“PUT”作为open()的第一个参数。 open()的第二个参数是url。跨域的请求通常会报错。 如果有请求头的话，请求进程的下个步骤就是设置请求头。 1request.setRequestHeader(&quot;Content-Type&quot;, &quot;text&#x2F;plain&quot;); 发起HTTP请求的最后一步是指定可选的请求主体并向服务器发送它，使用send()方法。 1request.send(null); 例子： 123456function postMessage(msg) &#123; var resuest &#x3D; new XMLHttpRequest(); request.open(&quot;POST&quot;, &quot;.&#x2F;log.php&quot;); request.setRequestHeader(&quot;Content-Type&quot;, &quot;text&#x2F;plain&quot;, charset&#x3D;UTF-8); request.send(msg);&#125; open的第三个参数可以设置同步或异步响应，默认为异步(true)。 取得响应 status和statusText属性以数字和文本的形式返回HTTP状态码。 使用getResponseHeader和getAllResponseHeaders能查询响应头。XMLHttpRequest会自动处理cookie。 响应主体可以从responseText属性中得到文本形式的，从responseXML中得到Document形式的。 XMLHttpRequest对象通常异步使用，发送请求后，send方法立即返回，直到响应返回，相应方法和属性才有效。为了在响应准备就绪时得到通知，必须监听XMLHttpRequest对象上的readystatechange事件。 readyState是一个整数，它指定了HTTP请求的状态。表格如下： 常量 值 定义 UNSENT 0 open尚未调用 OPENED 1 open已调用 HEADERS_RECEIVED 2 接收到头信息 LOADING 3 接收到响应主体 DONE 4 响应完成 当readyState值变成4时或服务器的响应完成时，所有的浏览器都触发readystatechange事件。 为了监听readystatechange事件，要把事件监听函数设置为XMLHttpRequest对象的onreadystatechange属性。 例子： 1234567891011function getText(url, callback) &#123; var resuest &#x3D; new XMLHttpRequest(); request.open(&quot;GET&quot;, &quot;url&quot;); request.onreadystatechange &#x3D; function() &#123; if (request.readyState &#x3D;&#x3D;&#x3D; 4 &amp;&amp; request.status &#x3D;&#x3D;&#x3D; 200) &#123; var type &#x3D; request.getResponseHeader(&quot;Conteng-Type&quot;); if (type.match(&#x2F;^text^&#x2F;)) callback(request.responseText); &#125; &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"基本类型和引用类型的值","slug":"第4章-基本类型和引用类型的值","date":"2020-05-09T00:00:00.000Z","updated":"2020-05-09T05:45:26.000Z","comments":true,"path":"2020/05/09/第4章-基本类型和引用类型的值/","link":"","permalink":"http://yoursite.com/2020/05/09/%E7%AC%AC4%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC/","excerpt":"变量，作用域和内存问题本文主要内容: 理解基本类型和引用类型的值 理解执行环境 理解垃圾收集","text":"变量，作用域和内存问题本文主要内容: 理解基本类型和引用类型的值 理解执行环境 理解垃圾收集 基本类型和引用类型的值 基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。 引用类型的值是保存在内存中的对象。JavaScript不允许直接访问内存中的位置，即不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象，为此，引用类型的值是按引用访问的。 动态的属性对于引用类型的值，可以为其添加属性和方法，也可以改变和删除其属性和方法。 123var person &#x3D; new Object();person.name &#x3D; &quot;Nicholas&quot;;alert(person.name); &#x2F;&#x2F; &quot;Nicholas&quot; 我们不能给基本类型的值添加属性，尽管这样不会导致任何错误。比如： 123var name &#x3D; &quot;Nicholas&quot;;name.age &#x3D; 27;alert(name.age) &#x2F;&#x2F; undefined 复制变量值在从一个变量向另一个变量复制基本类型值和引用类型值时，也存在不同。 如果从一个变量向一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。两个变量可以参与任何操作而不会相互影响。 当一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象的值复制一份到为新变量分配的空间中。不同的是，这个副本是一个指针，这个指针指向存储在堆中的一个对象，复制结束后，两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响另一个变量。 传递参数ECMAScript中所有函数的参数都是按值传递的。即，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。 在向函数参数传递引用类型的值时，会把这个值的内存地址赋值给一个局部变量，因此这个局部变量的会反映在函数的外部。 例1： 123456789function addTen(num) &#123; num + &#x3D; 10; return num;&#125;var count &#x3D; 20;var result &#x3D; addTen(count);alert(count); &#x2F;&#x2F; 20alert(result); &#x2F;&#x2F;30 例2： 1234567function setName(obj) &#123; obj.name &#x3D; &quot;Nicholas&quot;;&#125;var person &#x3D; new Object();setName(person);alert(person.name); &#x2F;&#x2F; &quot;Nicholas&quot; 例3： 123456789function setName(obj) &#123; obj.name &#x3D; &quot;Nicholas&quot;; obj &#x3D; new Object(); obj.name &#x3D; &quot;Greg&quot;&#125;var person &#x3D; new Object();setName(person);alert(person.name); &#x2F;&#x2F; &quot;Nicholas&quot; 例3中，如果person是按引用传递的，那么person就会自动被修改为指向其name属性为“Greg”的新对象。但是结果显示为”Nicholas”，这说明，即使在函数内部修改了参数的值，但是原始的引用仍然保持未变。实际上，在函数内部重写obj时，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。 可以把ECMAScript函数的参数想象成局部变量。 检测类型typeof操作符是确定一个变量是字符串、数值、布尔值、还是undefined的最佳工具。如果变量的值是一个对象或者null，则会返回object。 在检测引用类型的值时，typeof的作用不大，要使用instanceof，可以知道它是什么类型的对象。 result = variable instanceof constructor 如果变量是给定引用类型的实例(根据原型链来识别)，那么instanceof就会返回true。所有引用类型的实例都是object。instanceof检测基本类型时，就会返回false，因为基本类型不是对象。 执行环境(执行上下文)及作用域执行环境是JavaScript中的一个重要概念。 执行环境定义了变量或函数有权访问的其他数据，决定了他们各自的行为。 每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。 全局执行环境是最外围的一个执行环境。根据ECMAScript实现所在的宿主环境不同，表示执行环境的对象也不一样。在Web浏览器中，全局执行环境被认为是window对象，因此所有全局变量和函数都是作为window对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁(全局执行环境直到应用程序退出——例如关闭网页/浏览器时才会被销毁)。 每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中(执行上下文栈)。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。 当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在的环境的变量对象。如果这个环境是函数，则其活动对象作为变量对象。活动对象在最开始时只包含一个变量，即arguments对象。作用域链中的下一个变量来自包含(外部)环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。 标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级的向后回溯，直到找到标识符为止(若找不到，通常会导致错误发生)。 例： 12345678910111213var color &#x3D; &quot;blue&quot;;function changeColor () &#123; if (color &#x3D;&#x3D;&#x3D; &quot;blue&quot;) &#123; color &#x3D; &quot;red&quot;; &#125; else &#123; color &#x3D; &quot;blue&quot;; &#125;&#125;changeColor();alert(&quot;Color is now&quot; + color); 在这个简单的例子中，函数changeColor()的作用域包含两个对象：它自己的变量对象(其中定义着arguments对象)和全局环境的变量对象。可以在函数内部访问变量color，就是因为可以在这个作用域链中找到他。 此外，在局部作用域中定义的变量可以在局部环境中与全局变量互换使用，如下面例子所示： 1234567891011121314151617var color &#x3D; &quot;blue&quot;;function changeColor () &#123; var anotherColor &#x3D; &quot;red&quot;; function swapColors () &#123; var tempColor &#x3D; anotherColor; anotherColor &#x3D; color; color &#x3D; tempColor; &#x2F;&#x2F;这里可以访问color，anotherColor和tempColor &#125; &#x2F;&#x2F;这里可以访问color，anotherColor，但不能访问tempColor swapColors();&#125;&#x2F;&#x2F;这里只能访问colorchangeColor(); 以上代码共涉及三个执行环境：全局环境、changeColor()的局部环境和swapColors()的局部环境。作用域链如下： 123456window |______color |______changeColor() |_______anotherColor |_______swapColors() |______tempColor 内部环境可以通过作用域链访问所有的外部环境，但是外部环境不能访问内部环境中的任何变量和函数。 每个环境可以向上搜索作用域链，以查询变量和函数名；但是任何环境都不能通过向下搜索作用域链而进入另一个执行环境。 函数参数也被当作变量来对待，因此其访问规则与执行环境中的其他变量相同。 延长作用域链有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。在两种情况下会发生这种现象。具体来说，就是当执行流进入下列任何一个语句时，作用域链就会得到加长： try-catch语句的catch块； with语句 这两个语句都会在作用域链的前端添加一个变量对象。对with语句来说，会将指定的对象添加到作用域链中。对于catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。下面看一个例子: 12345678function buildUrl() &#123; var qs &#x3D; &quot;?debug&#x3D;true&quot;; with(location) &#123; var url &#x3D; href + qs; &#x2F;&#x2F;href实际上是location.href &#125; return url;&#125; 在此，with语句接收的是location对象，因此其变量对象中就包含了location对象的所有属性，而这个变量对象被添加到了作用域链的前端。 没有块级作用域JavaScript没有块级作用域经常会导致理解上的困惑。例如： 1234if (true) &#123; var color &#x3D; &quot;blue&quot;;&#125;alert(color); &#x2F;&#x2F;&quot;blue&quot;; 上述代码中，在一个if语句中定义了变量color。若是在C，C++或Java中，color会在if语句执行完毕后被销毁。但是在JavaScript中，if语句中，if语句中的变量声明会将变量添加到当前的执行环境中。在使用for语句时，尤其要牢记这一差异，例如： 1234for (var i &#x3D; 0;i &lt; 10; i++) &#123; doSomething(i);&#125;alert(i) &#x2F;&#x2F;10，循环结束后，变量i依旧存在于循环外部的执行环境中 声明变量使用var声明的变量会自动被添加到最接近的环境中(变量提升)。在函数内部中，最接近的环境是函数的局部环境，with语句中，最接近的是函数环境。如果初始化变量时没有使用var声明，该变量会被添加到全局环境。 例： 12345678funtion add(num1,num2) &#123; var sum &#x3D; num1 + num2; return sum;&#125;var result &#x3D; add(10, 20); &#x2F;&#x2F;30alert(sum) &#x2F;&#x2F;错误 例： 12345678funtion add(num1,num2) &#123; sum &#x3D; num1 + num2; return sum;&#125;var result &#x3D; add(10, 20); &#x2F;&#x2F;30alert(sum) &#x2F;&#x2F;30,sum在全局环境中 在初始化变量之前一定要声明，可以避免一些常见的错误。在严格模式下，初始化未经声明的变量会导致错误。 查询标识符当在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境中找到了该标识符，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域链向上搜索。搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中页没有找到这个标识符，则意味着该变量尚未声明。 例： 1234567var color &#x3D; &quot;blue&quot;;function getColor() &#123; return color;&#125;alert(color); &#x2F;&#x2F; blue 例： 12345678var color &#x3D; &quot;blue&quot;;function getColor() &#123; var color &#x3D; &quot;red&quot;; &#x2F;&#x2F; 向上查询找到，搜索结束 return color;&#125;alert(color); &#x2F;&#x2F; red 垃圾收集JavaScript具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。 这种垃圾收集机制的原理很简单：找出那些不再继续使用的变量，然后释放其占用的内存。因此，垃圾收集器会按照固定的时间间隔周期性的执行这一操作。 垃圾收集器必须跟踪那个变量有用哪个变量没有用，对于不再有用的变量打上标记，以备将来收回其占用的内存。标识无用变量的策略一般有2个。 标记清除JavaScript最常用的垃圾收集方式是标记清除。当变量进入环境中时，就将这个变量标识为“进入环境”。 可以使用任何方式来标记变量。 垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后垃圾收集器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间。 引用计数引用计数的含义是跟踪记录每个值被引用的次数。当一个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。 性能问题垃圾收集器是周期性运行的，而且如果为变量分配的内存数量很可观，那么回收工作量也是相当大的。在这种情况下，确定垃圾收集的时间间隔是一个非常重要的问题。 管理内存分配给Web浏览器的可用内存数量通常要比分配给桌面应用程序的少。这样做的目的主要是出于安全方面的考虑，目的是防止运行JavaScript的网页耗尽全部系统内存而导致系统崩溃。内存限制不仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。 因此，确保占用最少的内存，可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其设置为null来释放引用——这个做法叫做解除引用。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在他们离开执行环境时自动被解除引用。","categories":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://yoursite.com/categories/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://yoursite.com/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"基本概念(数据类型)","slug":"第3章-基本概念","date":"2020-04-25T00:00:00.000Z","updated":"2020-05-09T05:33:26.000Z","comments":true,"path":"2020/04/25/第3章-基本概念/","link":"","permalink":"http://yoursite.com/2020/04/25/%E7%AC%AC3%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","excerpt":"前言本文为JavaScript高级程序设计一书学习记录。 本文主要内容： 语法 数据类型 流控制语句 函数","text":"前言本文为JavaScript高级程序设计一书学习记录。 本文主要内容： 语法 数据类型 流控制语句 函数 语法 区分大小写ECMAscript中的一切(变量、函数名、操作符)都区分大小写。 严格模式ECMAscript5引入了严格模式。在严格模式下，ECMAscript3中一些不确定的行为得到了处理，对某些不安全的操作也会抛出错误。要在整个脚本中启用严格模式，可以在顶部添加如下代码： 1&quot;use strict&quot; 在函数内部的上方包含这条编译指示，也可以指定函数在严格模式下执行。 变量ECMAscript 的变量是松散类型的，所谓松散类型就是可以用来保存任何类型的数据。换句话说，每个变量仅仅是一个用于保存值的占位符。定义变量时要使用var操作符，后跟变量名。 例： 1var message &#x3D; &quot;hi&quot; 可以在修改变量值的同时修改值的类型。 有一点必须注意，即用var操作符定义的变量将成为定义该变量的作用域中的局部变量。如果在函数中使用var定义一个变量，那么这个变量在函数退出后就会被销毁。 12345function test() &#123; var message &#x3D; &quot;hi&quot;; &#x2F;&#x2F; 局部变量&#125;test();alert(message); &#x2F;&#x2F; 错误 也可以省略var操作符，从而创建一个全局变量。 12345function test() &#123; message &#x3D; &quot;hi&quot;; &#x2F;&#x2F; 全局变量&#125;test();alert(message); &#x2F;&#x2F; hi 可以使用一条语句定义多个变量，只要像下面这样把每个变量（初始化或不初始化均可）用逗号分隔开即可。 123var message &#x3D; &quot;hi&quot;; found &#x3D; false; age &#x3D; 29; 在严格模式下，不能定义名为eval或arguments的变量，否则会导致语法错误。 数据类型ECMAscript有6种基本数据类型，undefined、Null、Boolean、Number、string和symbol。还有一种复杂数据类型Object。 typeof操作符 undefined——如果这个值未定义； boolean——如果这个值是布尔值； string——如果这个值是字符串； number——如果这个值是数值； object——如果这个值是对象或者null function——如果这个值是函数 undefined类型在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined。 Null类型从逻辑角度看，null表示一个空对象指针，而这也是typeof返回object的原因。 注意：位于null和undefined之间的==总是会返回true，不过要注意的是，这个操作符出于比较的目的会转换其操作数。 Boolean类型两个值：true + false,可以调用转型函数Boolean()，转换为Boolean类型。 Number类型最基本的数值字面量格式是十进制整数，直接在代码中输入即可。 整数还可以通过八进制或十六进制的字面值来表示。其中，八进制字面值的第一位必须是0，八进制在严格模式下是无效的，会导致支持该模式的JavaScript引擎抛出错误。 数值范围由于内存的限制，ECMAscript不能保存世界上所有的数值。ECMAscript能够保存的最小的数值保存在Number.MIN_VALUE中——大多数浏览器中，这个值是5e-324；能够表示的最大数值保存在Number.MAX_VALUE中。 如果在某次计算的结果得到了一个超出JavaScript数值范围的值，那么这个数值将被自动转换成特殊的Infinity值。 inifinity值布不能参加数值计算，可以使用isFinite()函数判断数值是否有穷。 NaNNaN即非数值(not a number)是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况。 NaN本身有两个非同寻常的特点。 首先，任何涉及NaN的操作都会返回NaN 其次，NaN与任何值都不相等，包括NaN本身。 针对，有isNaN()这个函数，接收一个任何类型的参数，任何不能被转换为数值的值都会导致这个函数返回true。 数值转换有3个函数可以把非数值转换为数值，Number(), parseInt(),parseFloat()。 Number()可以用于任何数据类型，另外两个专用于字符串。 Number()函数的转换规则： Boolean值，true和false转换为1和0； 数字值，返回原值； null，返回0； undefined返回NaN 字符串 字符串只包含数字，返回数字 字符串包含有效的浮点格式，返回对应浮点值 包含有效的十六进制值，返回相同大小的十进制值 字符串空，返回0； 包含上述格式外的，返回NaN 对象，调用对象的valueof方法，按照前面规则返回值。 parseInt()可以有第二个参数，表示多少进制。 object类型ECMAscript中的对象其实就是一组数据和功能的集合。对象可以通过执行new操作符后跟随名称来创建。 object的每个实例都具有以下属性和方法： constructor：保存着用于创建当前对象的函数。 hasownProperty(propertyName)：用于检查给定的属性在当前对象实例中是否存在。 isPrototypeOf(object)：用于检查传入的对象是否是当前对象的原型。 propertyIsEnumerable(propertyName)：用于检查给定的属性是否能用for-in语句。 toLocalString()：返回对象的字符串表示，该字符串与执行环境的地区对应。 toString()：返回对象的字符串表示。 valueOf()：返回对象的字符串、数值或布尔值表示。","categories":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://yoursite.com/categories/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://yoursite.com/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"Module的语法","slug":"24-Module的语法","date":"2020-04-22T00:00:00.000Z","updated":"2020-04-22T09:23:08.000Z","comments":true,"path":"2020/04/22/24-Module的语法/","link":"","permalink":"http://yoursite.com/2020/04/22/24-Module%E7%9A%84%E8%AF%AD%E6%B3%95/","excerpt":"前言本文主要内容： 概述 严格模式 export 命令 import 命令 模块的整体加载 export default 命令 export 与 import 的复合写法 模块的继承 跨模块常量 import()","text":"前言本文主要内容： 概述 严格模式 export 命令 import 命令 模块的整体加载 export default 命令 export 与 import 的复合写法 模块的继承 跨模块常量 import() 概述 在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。 ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。 CommonJS 和AMD模块，都只能在运行时确定这些东西。比如，CommonJS模块就是对象，输入时必须查找对象属性。 12345678&#x2F;&#x2F; CommonJS模块let &#123; stat, exists, readFile &#125; &#x3D; require(&#39;fs&#39;);&#x2F;&#x2F; 等同于let _fs &#x3D; require(&#39;fs&#39;);let stat &#x3D; _fs.stat;let exists &#x3D; _fs.exists;let readfile &#x3D; _fs.readfile; 上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为运行时加载，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。 ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。 12&#x2F;&#x2F; ES6模块import &#123; stat, exists, readFile &#125; from &#39;fs&#39;; 上面代码的实质是从fs模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。 由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。 除了静态加载带来的各种好处，ES6 模块还有以下好处。 不再需要UMD模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。 将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者navigator对象的属性。 不再需要对象作为命名空间（比如Math对象），未来这些功能可以通过模块提供。本章介绍 ES6 模块的语法，下一章介绍如何在浏览器和 Node 之中，加载 ES6 模块。 严格模式ES6 的模块自动采用严格模式，不管你有没有在模块头部加上”use strict”;。 严格模式主要有以下限制。 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 不能使用with语句 不能对只读属性赋值，否则报错 不能使用前缀 0 表示八进制数，否则报错 不能删除不可删除的属性，否则报错 不能删除变量delete prop，会报错，只能删除属性delete global[prop] eval不会在它的外层作用域引入变量 eval和arguments不能被重新赋值 arguments不会自动反映函数参数的变化 不能使用arguments.callee 不能使用arguments.caller 禁止this指向全局对象 不能使用fn.caller和fn.arguments获取函数调用的堆栈 增加了保留字（比如protected、static和interface） 上面这些限制，模块都必须遵守。由于严格模式是 ES5 引入的，不属于 ES6，所以请参阅相关 ES5 书籍，本文不再详细介绍了。 其中，尤其需要注意this的限制。ES6 模块之中，顶层的this指向undefined，即不应该在顶层代码使用this。 export 命令模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。 一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。下面是一个 JS 文件，里面使用export命令输出变量。 1234&#x2F;&#x2F; profile.jsexport var firstName &#x3D; &#39;Michael&#39;;export var lastName &#x3D; &#39;Jackson&#39;;export var year &#x3D; 1958; 上面代码是profile.js文件，保存了用户信息。ES6 将其视为一个模块，里面用export命令对外部输出了三个变量。 export的写法，除了像上面这样，还有另外一种。 123456&#x2F;&#x2F; profile.jsvar firstName &#x3D; &#39;Michael&#39;;var lastName &#x3D; &#39;Jackson&#39;;var year &#x3D; 1958;export &#123; firstName, lastName, year &#125;; 上面代码在export命令后面，使用大括号指定所要输出的一组变量。它与前一种写法（直接放置在var语句前）是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。 export命令除了输出变量，还可以输出函数或类（class）。 123export function multiply(x, y) &#123; return x * y;&#125;; 上面代码对外输出一个函数multiply。 通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名。 12345678function v1() &#123; ... &#125;function v2() &#123; ... &#125;export &#123; v1 as streamV1, v2 as streamV2, v2 as streamLatestVersion&#125;; 上面代码使用as关键字，重命名了函数v1和v2的对外接口。重命名后，v2可以用不同的名字输出两次。 需要特别注意的是，export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。 123456&#x2F;&#x2F; 报错export 1;&#x2F;&#x2F; 报错var m &#x3D; 1;export m; 上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出 1，第二种写法通过变量m，还是直接输出 1。1只是一个值，不是接口。正确的写法是下面这样。 12345678910&#x2F;&#x2F; 写法一export var m &#x3D; 1;&#x2F;&#x2F; 写法二var m &#x3D; 1;export &#123;m&#125;;&#x2F;&#x2F; 写法三var n &#x3D; 1;export &#123;n as m&#125;; 上面三种写法都是正确的，规定了对外的接口m。其他脚本可以通过这个接口，取到值1。它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。 同样的，function和class的输出，也必须遵守这样的写法。 12345678910&#x2F;&#x2F; 报错function f() &#123;&#125;export f;&#x2F;&#x2F; 正确export function f() &#123;&#125;;&#x2F;&#x2F; 正确function f() &#123;&#125;export &#123;f&#125;; 另外，export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。 12export var foo &#x3D; &#39;bar&#39;;setTimeout(() &#x3D;&gt; foo &#x3D; &#39;baz&#39;, 500); 上面代码输出变量foo，值为bar，500 毫秒之后变成baz。 这一点与CommonJS规范完全不同。CommonJS 模块输出的是值的缓存，不存在动态更新。 最后，export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的import命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。 1234function foo() &#123; export default &#39;bar&#39; &#x2F;&#x2F; SyntaxError&#125;foo() 上面代码中，export语句放在函数之中，结果报错。 import 命令使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。 123456&#x2F;&#x2F; main.jsimport &#123; firstName, lastName, year &#125; from &#39;.&#x2F;profile.js&#39;;function setName(element) &#123; element.textContent &#x3D; firstName + &#39; &#39; + lastName;&#125; 上面代码的import命令，用于加载profile.js文件，并从中输入变量。import命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。 如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名。 1import &#123; lastName as surname &#125; from &#39;.&#x2F;profile.js&#39;; import命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。 123import &#123;a&#125; from &#39;.&#x2F;xxx.js&#39;a &#x3D; &#123;&#125;; &#x2F;&#x2F; Syntax Error : &#39;a&#39; is read-only; 上面代码中，脚本加载了变量a，对其重新赋值就会报错，因为a是一个只读的接口。但是，如果a是一个对象，改写a的属性是允许的。 123import &#123;a&#125; from &#39;.&#x2F;xxx.js&#39;a.foo &#x3D; &#39;hello&#39;; &#x2F;&#x2F; 合法操作 上面代码中，a的属性可以成功改写，并且其他模块也可以读到改写后的值。不过，这种写法很难查错，建议凡是输入的变量，都当作完全只读，不要轻易改变它的属性。 import后面的from指定模块文件的位置，可以是相对路径，也可以是绝对路径，.js后缀可以省略。如果只是模块名，不带有路径，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。 import {myMethod} from &#39;util&#39;; 上面代码中，util是模块文件名，由于不带有路径，必须通过配置，告诉引擎怎么取到这个模块。 注意，import命令具有提升效果，会提升到整个模块的头部，首先执行。 123foo();import &#123; foo &#125; from &#39;my_module&#39;; 上面的代码不会报错，因为import的执行早于foo的调用。这种行为的本质是，import命令是编译阶段执行的，在代码运行之前。 由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。 12345678910111213&#x2F;&#x2F; 报错import &#123; &#39;f&#39; + &#39;oo&#39; &#125; from &#39;my_module&#39;;&#x2F;&#x2F; 报错let module &#x3D; &#39;my_module&#39;;import &#123; foo &#125; from module;&#x2F;&#x2F; 报错if (x &#x3D;&#x3D;&#x3D; 1) &#123; import &#123; foo &#125; from &#39;module1&#39;;&#125; else &#123; import &#123; foo &#125; from &#39;module2&#39;;&#125; 上面三种写法都会报错，因为它们用到了表达式、变量和if结构。在静态分析阶段，这些语法都是没法得到值的。 最后，import语句会执行所加载的模块，因此可以有下面的写法。 import &#39;lodash&#39;; 上面代码仅仅执行lodash模块，但是不输入任何值。 如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次。 12import &#39;lodash&#39;;import &#39;lodash&#39;; 上面代码加载了两次lodash，但是只会执行一次。 12345import &#123; foo &#125; from &#39;my_module&#39;;import &#123; bar &#125; from &#39;my_module&#39;;&#x2F;&#x2F; 等同于import &#123; foo, bar &#125; from &#39;my_module&#39;; 上面代码中，虽然foo和bar在两个语句中加载，但是它们对应的是同一个my_module实例。也就是说，import语句是 Singleton 模式。 目前阶段，通过 Babel 转码，CommonJS 模块的require命令和 ES6 模块的import命令，可以写在同一个模块里面，但是最好不要这样做。因为import在静态解析阶段执行，所以它是一个模块之中最早执行的。下面的代码可能不会得到预期结果。 123require(&#39;core-js&#x2F;modules&#x2F;es6.symbol&#39;);require(&#39;core-js&#x2F;modules&#x2F;es6.promise&#39;);import React from &#39;React&#39;; 模块的整体加载除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。 下面是一个circle.js文件，它输出两个方法area和circumference。 123456789&#x2F;&#x2F; circle.jsexport function area(radius) &#123; return Math.PI * radius * radius;&#125;export function circumference(radius) &#123; return 2 * Math.PI * radius;&#125; 现在，加载这个模块。 123456&#x2F;&#x2F; main.jsimport &#123; area, circumference &#125; from &#39;.&#x2F;circle&#39;;console.log(&#39;圆面积：&#39; + area(4));console.log(&#39;圆周长：&#39; + circumference(14)); 上面写法是逐一指定要加载的方法，整体加载的写法如下。 1234import * as circle from &#39;.&#x2F;circle&#39;;console.log(&#39;圆面积：&#39; + circle.area(4));console.log(&#39;圆周长：&#39; + circle.circumference(14)); 注意，模块整体加载所在的那个对象（上例是circle），应该是可以静态分析的，所以不允许运行时改变。下面的写法都是不允许的。 12345import * as circle from &#39;.&#x2F;circle&#39;;&#x2F;&#x2F; 下面两行都是不允许的circle.foo &#x3D; &#39;hello&#39;;circle.area &#x3D; function () &#123;&#125;; export default 命令从前面的例子可以看出，使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。 为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出。 1234&#x2F;&#x2F; export-default.jsexport default function () &#123; console.log(&#39;foo&#39;);&#125; 上面代码是一个模块文件export-default.js，它的默认输出是一个函数。 其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。 123&#x2F;&#x2F; import-default.jsimport customName from &#39;.&#x2F;export-default&#39;;customName(); &#x2F;&#x2F; &#39;foo&#39; 上面代码的import命令，可以用任意名称指向export-default.js输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时import命令后面，不使用大括号。 export default命令用在非匿名函数前，也是可以的。 1234567891011121314151617181920212223242526272829&#x2F;&#x2F; export-default.jsexport default function foo() &#123; console.log(&#39;foo&#39;);&#125;&#x2F;&#x2F; 或者写成function foo() &#123; console.log(&#39;foo&#39;);&#125;export default foo;上面代码中，foo函数的函数名foo，在模块外部是无效的。加载的时候，视同匿名函数加载。下面比较一下默认输出和正常输出。&#x2F;&#x2F; 第一组export default function crc32() &#123; &#x2F;&#x2F; 输出 &#x2F;&#x2F; ...&#125;import crc32 from &#39;crc32&#39;; &#x2F;&#x2F; 输入&#x2F;&#x2F; 第二组export function crc32() &#123; &#x2F;&#x2F; 输出 &#x2F;&#x2F; ...&#125;;import &#123;crc32&#125; from &#39;crc32&#39;; &#x2F;&#x2F; 输入 上面代码的两组写法，第一组是使用export default时，对应的import语句不需要使用大括号；第二组是不使用export default时，对应的import语句需要使用大括号。 export default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export default命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能唯一对应export default命令。 本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。 123456789101112&#x2F;&#x2F; modules.jsfunction add(x, y) &#123; return x * y;&#125;export &#123;add as default&#125;;&#x2F;&#x2F; 等同于&#x2F;&#x2F; export default add;&#x2F;&#x2F; app.jsimport &#123; default as foo &#125; from &#39;modules&#39;;&#x2F;&#x2F; 等同于&#x2F;&#x2F; import foo from &#39;modules&#39;; 正是因为export default命令其实只是输出一个叫做default的变量，所以它后面不能跟变量声明语句。 123456789&#x2F;&#x2F; 正确export var a &#x3D; 1;&#x2F;&#x2F; 正确var a &#x3D; 1;export default a;&#x2F;&#x2F; 错误export default var a &#x3D; 1; 上面代码中，export default a的含义是将变量a的值赋给变量default。所以，最后一种写法会报错。 同样地，因为export default命令的本质是将后面的值，赋给default变量，所以可以直接将一个值写在export default之后。 12345&#x2F;&#x2F; 正确export default 42;&#x2F;&#x2F; 报错export 42; 上面代码中，后一句报错是因为没有指定对外的接口，而前一句指定对外接口为default。 有了export default命令，输入模块时就非常直观了，以输入 lodash 模块为例。 1import _ from &#39;lodash&#39;; 如果想在一条import语句中，同时输入默认方法和其他接口，可以写成下面这样。 1import _, &#123; each, forEach &#125; from &#39;lodash&#39;; 对应上面代码的export语句如下。 123456789export default function (obj) &#123; &#x2F;&#x2F; ···&#125;export function each(obj, iterator, context) &#123; &#x2F;&#x2F; ···&#125;export &#123; each as forEach &#125;; 上面代码的最后一行的意思是，暴露出forEach接口，默认指向each接口，即forEach和each指向同一个方法。 export default也可以用来输出类。 123456&#x2F;&#x2F; MyClass.jsexport default class &#123; ... &#125;&#x2F;&#x2F; main.jsimport MyClass from &#39;MyClass&#39;;let o &#x3D; new MyClass(); export 与 import 的复合写法如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。 12345export &#123; foo, bar &#125; from &#39;my_module&#39;;&#x2F;&#x2F; 可以简单理解为import &#123; foo, bar &#125; from &#39;my_module&#39;;export &#123; foo, bar &#125;; 上面代码中，export和import语句可以结合在一起，写成一行。但需要注意的是，写成一行以后，foo和bar实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，导致当前模块不能直接使用foo和bar。 模块的接口改名和整体输出，也可以采用这种写法。 12345&#x2F;&#x2F; 接口改名export &#123; foo as myFoo &#125; from &#39;my_module&#39;;&#x2F;&#x2F; 整体输出export * from &#39;my_module&#39;; 默认接口的写法如下。 1export &#123; default &#125; from &#39;foo&#39;; 具名接口改为默认接口的写法如下。 12345export &#123; es6 as default &#125; from &#39;.&#x2F;someModule&#39;;&#x2F;&#x2F; 等同于import &#123; es6 &#125; from &#39;.&#x2F;someModule&#39;;export default es6; 同样地，默认接口也可以改名为具名接口。 export { default as es6 } from &#39;./someModule&#39;; ES2020 之前，有一种import语句，没有对应的复合写法。 import * as someIdentifier from &quot;someModule&quot;; ES2020补上了这个写法。 12345export * as ns from &quot;mod&quot;;&#x2F;&#x2F; 等同于import * as ns from &quot;mod&quot;;export &#123;ns&#125;; 模块的继承模块之间也可以继承。 假设有一个circleplus模块，继承了circle模块。 1234567&#x2F;&#x2F; circleplus.jsexport * from &#39;circle&#39;;export var e &#x3D; 2.71828182846;export default function(x) &#123; return Math.exp(x);&#125; 上面代码中的export *，表示再输出circle模块的所有属性和方法。注意，export *命令会忽略circle模块的default方法。然后，上面代码又输出了自定义的e变量和默认方法。 这时，也可以将circle的属性或方法，改名后再输出。 123&#x2F;&#x2F; circleplus.jsexport &#123; area as circleArea &#125; from &#39;circle&#39;; 上面代码表示，只输出circle模块的area方法，且将其改名为circleArea。 加载上面模块的写法如下。 12345&#x2F;&#x2F; main.jsimport * as math from &#39;circleplus&#39;;import exp from &#39;circleplus&#39;;console.log(exp(math.e)); 上面代码中的import exp表示，将circleplus模块的默认方法加载为exp方法。 跨模块常量本书介绍const命令的时候说过，const声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用下面的写法。 1234567891011121314&#x2F;&#x2F; constants.js 模块export const A &#x3D; 1;export const B &#x3D; 3;export const C &#x3D; 4;&#x2F;&#x2F; test1.js 模块import * as constants from &#39;.&#x2F;constants&#39;;console.log(constants.A); &#x2F;&#x2F; 1console.log(constants.B); &#x2F;&#x2F; 3&#x2F;&#x2F; test2.js 模块import &#123;A, B&#125; from &#39;.&#x2F;constants&#39;;console.log(A); &#x2F;&#x2F; 1console.log(B); &#x2F;&#x2F; 3 如果要使用的常量非常多，可以建一个专门的constants目录，将各种常量写在不同的文件里面，保存在该目录下。 123456789&#x2F;&#x2F; constants&#x2F;db.jsexport const db &#x3D; &#123; url: &#39;http:&#x2F;&#x2F;my.couchdbserver.local:5984&#39;, admin_username: &#39;admin&#39;, admin_password: &#39;admin password&#39;&#125;;&#x2F;&#x2F; constants&#x2F;user.jsexport const users &#x3D; [&#39;root&#39;, &#39;admin&#39;, &#39;staff&#39;, &#39;ceo&#39;, &#39;chief&#39;, &#39;moderator&#39;]; 然后，将这些文件输出的常量，合并在index.js里面。 1234567&#x2F;&#x2F; constants&#x2F;index.jsexport &#123;db&#125; from &#39;.&#x2F;db&#39;;export &#123;users&#125; from &#39;.&#x2F;users&#39;;使用的时候，直接加载index.js就可以了。&#x2F;&#x2F; script.jsimport &#123;db, users&#125; from &#39;.&#x2F;constants&#x2F;index&#39;; import()简介前面介绍过，import命令会被 JavaScript 引擎静态分析，先于模块内的其他语句执行（import命令叫做“连接” binding 其实更合适）。所以，下面的代码会报错。 1234&#x2F;&#x2F; 报错if (x &#x3D;&#x3D;&#x3D; 2) &#123; import MyModual from &#39;.&#x2F;myModual&#39;;&#125; 上面代码中，引擎处理import语句是在编译时，这时不会去分析或执行if语句，所以import语句放在if代码块之中毫无意义，因此会报句法错误，而不是执行时错误。也就是说，import和export命令只能在模块的顶层，不能在代码块之中（比如，在if代码块之中，或在函数之中）。 这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。如果import命令要取代Node的require方法，这就形成了一个障碍。因为require是运行时加载模块，import命令无法取代require的动态加载功能。 12const path &#x3D; &#39;.&#x2F;&#39; + fileName;const myModual &#x3D; require(path); 上面的语句就是动态加载，require到底加载哪一个模块，只有运行时才知道。import命令做不到这一点。 ES2020提案 引入import()函数，支持动态加载模块。 import(specifier)上面代码中，import函数的参数specifier，指定所要加载的模块的位置。import命令能够接受什么参数，import()函数就能接受什么参数，两者区别主要是后者为动态加载。 import()返回一个 Promise 对象。下面是一个例子。 123456789const main &#x3D; document.querySelector(&#39;main&#39;);import(&#96;.&#x2F;section-modules&#x2F;$&#123;someVariable&#125;.js&#96;) .then(module &#x3D;&gt; &#123; module.loadPageInto(main); &#125;) .catch(err &#x3D;&gt; &#123; main.textContent &#x3D; err.message; &#125;); import()函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。另外，import()函数与所加载的模块没有静态连接关系，这点也是与import语句不相同。import()类似于 Node 的require方法，区别主要是前者是异步加载，后者是同步加载。 适用场合下面是import()的一些适用场合。 （1）按需加载。 import()可以在需要的时候，再加载某个模块。 123456789button.addEventListener(&#39;click&#39;, event &#x3D;&gt; &#123; import(&#39;.&#x2F;dialogBox.js&#39;) .then(dialogBox &#x3D;&gt; &#123; dialogBox.open(); &#125;) .catch(error &#x3D;&gt; &#123; &#x2F;* Error handling *&#x2F; &#125;)&#125;); 上面代码中，import()方法放在click事件的监听函数之中，只有用户点击了按钮，才会加载这个模块。 （2）条件加载 import()可以放在if代码块，根据不同的情况，加载不同的模块。 12345if (condition) &#123; import(&#39;moduleA&#39;).then(...);&#125; else &#123; import(&#39;moduleB&#39;).then(...);&#125; 上面代码中，如果满足条件，就加载模块 A，否则加载模块 B。 （3）动态的模块路径 import()允许模块路径动态生成。 12import(f()).then(...); 上面代码中，根据函数f的返回结果，加载不同的模块。 注意点import()加载模块成功以后，这个模块会作为一个对象，当作then方法的参数。因此，可以使用对象解构赋值的语法，获取输出接口。 1234import(&#39;.&#x2F;myModule.js&#39;).then((&#123;export1, export2&#125;) &#x3D;&gt; &#123; &#x2F;&#x2F; ...·&#125;); 上面代码中，export1和export2都是myModule.js的输出接口，可以解构获得。 如果模块有default输出接口，可以用参数直接获得。 1234import(&#39;.&#x2F;myModule.js&#39;).then(myModule &#x3D;&gt; &#123; console.log(myModule.default);&#125;); 上面的代码也可以使用具名输入的形式。 1234import(&#39;.&#x2F;myModule.js&#39;).then((&#123;default: theDefault&#125;) &#x3D;&gt; &#123; console.log(theDefault);&#125;); 如果想同时加载多个模块，可以采用下面的写法。 12345678Promise.all([ import(&#39;.&#x2F;module1.js&#39;), import(&#39;.&#x2F;module2.js&#39;), import(&#39;.&#x2F;module3.js&#39;),]).then(([module1, module2, module3]) &#x3D;&gt; &#123; ···&#125;); import()也可以用在 async 函数之中。 1234567891011async function main() &#123; const myModule &#x3D; await import(&#39;.&#x2F;myModule.js&#39;); const &#123;export1, export2&#125; &#x3D; await import(&#39;.&#x2F;myModule.js&#39;); const [module1, module2, module3] &#x3D; await Promise.all([ import(&#39;.&#x2F;module1.js&#39;), import(&#39;.&#x2F;module2.js&#39;), import(&#39;.&#x2F;module3.js&#39;), ]);&#125;main(); 本文转载自：https://es6.ruanyifeng.com/","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"Module的加载实现","slug":"25-Module的加载实现","date":"2020-04-22T00:00:00.000Z","updated":"2020-04-22T09:22:50.000Z","comments":true,"path":"2020/04/22/25-Module的加载实现/","link":"","permalink":"http://yoursite.com/2020/04/22/25-Module%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0/","excerpt":"前言本文主要内容： 浏览器加载 ES6 模块与 CommonJS 模块的差异 Node.js 加载 循环加载","text":"前言本文主要内容： 浏览器加载 ES6 模块与 CommonJS 模块的差异 Node.js 加载 循环加载 浏览器加载 传统方法HTML 网页中，浏览器通过&lt;script&gt;标签加载 JavaScript 脚本。 12345678&lt;!-- 页面内嵌的脚本 --&gt;&lt;script type&#x3D;&quot;application&#x2F;javascript&quot;&gt; &#x2F;&#x2F; module code&lt;&#x2F;script&gt;&lt;!-- 外部脚本 --&gt;&lt;script type&#x3D;&quot;application&#x2F;javascript&quot; src&#x3D;&quot;path&#x2F;to&#x2F;myModule.js&quot;&gt;&lt;&#x2F;script&gt; 上面代码中，由于浏览器脚本的默认语言是 JavaScript，因此type=&quot;application/javascript&quot;可以省略。 默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到&lt;script&gt;标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。 如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载，下面就是两种异步加载的语法。 12&lt;script src&#x3D;&quot;path&#x2F;to&#x2F;myModule.js&quot; defer&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&quot;path&#x2F;to&#x2F;myModule.js&quot; async&gt;&lt;&#x2F;script&gt; 上面代码中，&lt;script&gt;标签打开defer或async属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。 defer与async的区别是：defer要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，defer是“渲染完再执行”，async是“下载完就执行”。另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。 加载规则浏览器加载 ES6 模块，也使用&lt;script&gt;标签，但是要加入type=&quot;module&quot;属性。 1&lt;script type&#x3D;&quot;module&quot; src&#x3D;&quot;.&#x2F;foo.js&quot;&gt;&lt;&#x2F;script&gt; 上面代码在网页中插入一个模块foo.js，由于type属性设为module，所以浏览器知道这是一个 ES6 模块。 浏览器对于带有type=&quot;module&quot;的&lt;script&gt;，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了&lt;script&gt;标签的defer属性。 123&lt;script type&#x3D;&quot;module&quot; src&#x3D;&quot;.&#x2F;foo.js&quot;&gt;&lt;&#x2F;script&gt;&lt;!-- 等同于 --&gt;&lt;script type&#x3D;&quot;module&quot; src&#x3D;&quot;.&#x2F;foo.js&quot; defer&gt;&lt;&#x2F;script&gt; 如果网页有多个&lt;script type=&quot;module&quot;&gt;，它们会按照在页面出现的顺序依次执行。 &lt;script&gt;标签的async属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。 1&lt;script type&#x3D;&quot;module&quot; src&#x3D;&quot;.&#x2F;foo.js&quot; async&gt;&lt;&#x2F;script&gt; 一旦使用了async属性，&lt;script type=&quot;module&quot;&gt;就不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块。 ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。 12345&lt;script type&#x3D;&quot;module&quot;&gt; import utils from &quot;.&#x2F;utils.js&quot;; &#x2F;&#x2F; other code&lt;&#x2F;script&gt; 举例来说，jQuery 就支持模块加载。 1234&lt;script type&#x3D;&quot;module&quot;&gt; import $ from &quot;.&#x2F;jquery&#x2F;src&#x2F;jquery.js&quot;; $(&#39;#message&#39;).text(&#39;Hi from jQuery!&#39;);&lt;&#x2F;script&gt; 对于外部的模块脚本（上例是foo.js），有几点需要注意。 代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。 模块脚本自动采用严格模式，不管有没有声明use strict。 模块之中，可以使用import命令加载其他模块（.js后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用export命令输出对外接口。 模块之中，顶层的this关键字返回undefined，而不是指向window。也就是说，在模块顶层使用this关键字，是无意义的。 同一个模块如果加载多次，将只执行一次。 下面是一个示例模块。 123456import utils from &#39;https:&#x2F;&#x2F;example.com&#x2F;js&#x2F;utils.js&#39;;const x &#x3D; 1;console.log(x &#x3D;&#x3D;&#x3D; window.x); &#x2F;&#x2F;falseconsole.log(this &#x3D;&#x3D;&#x3D; undefined); &#x2F;&#x2F; true 利用顶层的this等于undefined这个语法点，可以侦测当前代码是否在 ES6 模块之中。 1const isNotModuleScript &#x3D; this !&#x3D;&#x3D; undefined; ES6 模块与 CommonJS 模块的差异讨论 Node.js 加载 ES6 模块之前，必须了解 ES6 模块与 CommonJS 模块完全不同。 它们有两个重大差异。 CommonJS模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 第二个差异是因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。 下面重点解释第一个差异。 CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个模块文件lib.js的例子。 123456789&#x2F;&#x2F; lib.jsvar counter &#x3D; 3;function incCounter() &#123; counter++;&#125;module.exports &#x3D; &#123; counter: counter, incCounter: incCounter,&#125;; 上面代码输出内部变量counter和改写这个变量的内部方法incCounter。然后，在main.js里面加载这个模块。 123456&#x2F;&#x2F; main.jsvar mod &#x3D; require(&#39;.&#x2F;lib&#39;);console.log(mod.counter); &#x2F;&#x2F; 3mod.incCounter();console.log(mod.counter); &#x2F;&#x2F; 3 上面代码说明，lib.js模块加载以后，它的内部变化就影响不到输出的mod.counter了。这是因为mod.counter是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。 1234567891011&#x2F;&#x2F; lib.jsvar counter &#x3D; 3;function incCounter() &#123; counter++;&#125;module.exports &#x3D; &#123; get counter() &#123; return counter &#125;, incCounter: incCounter,&#125;; 上面代码中，输出的counter属性实际上是一个取值器函数。现在再执行main.js，就可以正确读取内部变量counter的变动了。 123$ node main.js34 ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。 还是举上面的例子。 1234567891011&#x2F;&#x2F; lib.jsexport let counter &#x3D; 3;export function incCounter() &#123; counter++;&#125;&#x2F;&#x2F; main.jsimport &#123; counter, incCounter &#125; from &#39;.&#x2F;lib&#39;;console.log(counter); &#x2F;&#x2F; 3incCounter();console.log(counter); &#x2F;&#x2F; 4 上面代码说明，ES6 模块输入的变量counter是活的，完全反应其所在模块lib.js内部的变化。 再举一个出现在export一节中的例子。 12345678&#x2F;&#x2F; m1.jsexport var foo &#x3D; &#39;bar&#39;;setTimeout(() &#x3D;&gt; foo &#x3D; &#39;baz&#39;, 500);&#x2F;&#x2F; m2.jsimport &#123;foo&#125; from &#39;.&#x2F;m1.js&#39;;console.log(foo);setTimeout(() &#x3D;&gt; console.log(foo), 500); 上面代码中，m1.js的变量foo，在刚加载时等于bar，过了 500 毫秒，又变为等于baz。 让我们看看，m2.js能否正确读取这个变化。 1234$ babel-node m2.jsbarbaz 上面代码表明，ES6 模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块。 由于 ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。 12345678&#x2F;&#x2F; lib.jsexport let obj &#x3D; &#123;&#125;;&#x2F;&#x2F; main.jsimport &#123; obj &#125; from &#39;.&#x2F;lib&#39;;obj.prop &#x3D; 123; &#x2F;&#x2F; OKobj &#x3D; &#123;&#125;; &#x2F;&#x2F; TypeError 上面代码中，main.js从lib.js输入变量obj，可以对obj添加属性，但是重新赋值就会报错。因为变量obj指向的地址是只读的，不能重新赋值，这就好比main.js创造了一个名为obj的const变量。 最后，export通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例。 123456789101112&#x2F;&#x2F; mod.jsfunction C() &#123; this.sum &#x3D; 0; this.add &#x3D; function () &#123; this.sum +&#x3D; 1; &#125;; this.show &#x3D; function () &#123; console.log(this.sum); &#125;;&#125;export let c &#x3D; new C(); 上面的脚本mod.js，输出的是一个C的实例。不同的脚本加载这个模块，得到的都是同一个实例。 1234567891011&#x2F;&#x2F; x.jsimport &#123;c&#125; from &#39;.&#x2F;mod&#39;;c.add();&#x2F;&#x2F; y.jsimport &#123;c&#125; from &#39;.&#x2F;mod&#39;;c.show();&#x2F;&#x2F; main.jsimport &#39;.&#x2F;x&#39;;import &#39;.&#x2F;y&#39;; 现在执行main.js，输出的是1。 12$ babel-node main.js1 这就证明了x.js和y.js加载的都是C的同一个实例。 Node.js 加载概述Node.js对 ES6 模块的处理比较麻烦，因为它有自己的 CommonJS模块格式，与 ES6 模块格式是不兼容的。目前的解决方案是，将两者分开，ES6 模块和 CommonJS 采用各自的加载方案。从 v13.2 版本开始，Node.js 已经默认打开了 ES6 模块支持。 Node.js 要求 ES6 模块采用.mjs后缀文件名。也就是说，只要脚本文件里面使用import或者export命令，那么就必须采用.mjs后缀名。Node.js 遇到.mjs文件，就认为它是 ES6 模块，默认启用严格模式，不必在每个模块文件顶部指定&quot;use strict&quot;。 如果不希望将后缀名改成.mjs，可以在项目的package.json文件中，指定type字段为module。 123&#123; &quot;type&quot;: &quot;module&quot;&#125; 一旦设置了以后，该目录里面的 JS 脚本，就被解释用 ES6 模块。 123#解释成 ES6 模块&#96;$ node my-app.js&#96; 如果这时还要使用 CommonJS 模块，那么需要将 CommonJS 脚本的后缀名都改成.cjs。如果没有type字段，或者type字段为commonjs，则.js脚本会被解释成 CommonJS 模块。 总结为一句话：.mjs文件总是以 ES6 模块加载，.cjs文件总是以 CommonJS 模块加载，.js文件的加载取决于package.json里面type字段的设置。 注意，ES6 模块与 CommonJS 模块尽量不要混用。require命令不能加载.mjs文件，会报错，只有import命令才可以加载.mjs文件。反过来，.mjs文件里面也不能使用require命令，必须使用import。 main 字段package.json文件有两个字段可以指定模块的入口文件：main和exports。比较简单的模块，可以只使用main字段，指定模块加载的入口文件。 12345&#x2F;&#x2F; .&#x2F;node_modules&#x2F;es-module-package&#x2F;package.json&#123; &quot;type&quot;: &quot;module&quot;, &quot;main&quot;: &quot;.&#x2F;src&#x2F;index.js&quot;&#125; 上面代码指定项目的入口脚本为./src/index.js，它的格式为 ES6 模块。如果没有type字段，index.js就会被解释为 CommonJS 模块。 然后，import命令就可以加载这个模块。 1234&#x2F;&#x2F; .&#x2F;my-app.mjsimport &#123; something &#125; from &#39;es-module-package&#39;;&#x2F;&#x2F; 实际加载的是 .&#x2F;node_modules&#x2F;es-module-package&#x2F;src&#x2F;index.js 上面代码中，运行该脚本以后，Node.js 就会到./node_modules目录下面，寻找es-module-package模块，然后根据该模块package.json的main字段去执行入口文件。 这时，如果用 CommonJS 模块的require()命令去加载es-module-package模块会报错，因为 CommonJS 模块不能处理export命令。 exports 字段exports字段的优先级高于main字段。它有多种用法。 （1）子目录别名 package.json文件的exports字段可以指定脚本或子目录的别名。 123456&#x2F;&#x2F; .&#x2F;node_modules&#x2F;es-module-package&#x2F;package.json&#123; &quot;exports&quot;: &#123; &quot;.&#x2F;submodule&quot;: &quot;.&#x2F;src&#x2F;submodule.js&quot; &#125;&#125; 上面的代码指定src/submodule.js别名为submodule，然后就可以从别名加载这个文件。 12import submodule from &#39;es-module-package&#x2F;submodule&#39;;&#x2F;&#x2F; 加载 .&#x2F;node_modules&#x2F;es-module-package&#x2F;src&#x2F;submodule.js 下面是子目录别名的例子。 123456&#x2F;&#x2F; .&#x2F;node_modules&#x2F;es-module-package&#x2F;package.json&#123; &quot;exports&quot;: &#123; &quot;.&#x2F;features&#x2F;&quot;: &quot;.&#x2F;src&#x2F;features&#x2F;&quot; &#125;&#125; 12import feature from &#39;es-module-package&#x2F;features&#x2F;x.js&#39;;&#x2F;&#x2F; 加载 .&#x2F;node_modules&#x2F;es-module-package&#x2F;src&#x2F;features&#x2F;x.js 如果没有指定别名，就不能用“模块+脚本名”这种形式加载脚本。 12345&#x2F;&#x2F; 报错import submodule from &#39;es-module-package&#x2F;private-module.js&#39;;&#x2F;&#x2F; 不报错import submodule from &#39;.&#x2F;node_modules&#x2F;es-module-package&#x2F;private-module.js&#39;; （2）main 的别名 exports字段的别名如果是.，就代表模块的主入口，优先级高于main字段，并且可以直接简写成exports字段的值。 12345678910&#123; &quot;exports&quot;: &#123; &quot;.&quot;: &quot;.&#x2F;main.js&quot; &#125;&#125;&#x2F;&#x2F; 等同于&#123; &quot;exports&quot;: &quot;.&#x2F;main.js&quot;&#125; 由于exports字段只有支持 ES6 的 Node.js 才认识，所以可以用来兼容旧版本的 Node.js。 123456&#123; &quot;main&quot;: &quot;.&#x2F;main-legacy.cjs&quot;, &quot;exports&quot;: &#123; &quot;.&quot;: &quot;.&#x2F;main-modern.cjs&quot; &#125;&#125; 上面代码中，老版本的 Node.js （不支持 ES6 模块）的入口文件是main-legacy.cjs，新版本的 Node.js 的入口文件是main-modern.cjs。 （3）条件加载 利用.这个别名，可以为 ES6 模块和 CommonJS 指定不同的入口。目前，这个功能需要在 Node.js 运行的时候，打开--experimental-conditional-exports标志。 123456789&#123; &quot;type&quot;: &quot;module&quot;, &quot;exports&quot;: &#123; &quot;.&quot;: &#123; &quot;require&quot;: &quot;.&#x2F;main.cjs&quot;, &quot;default&quot;: &quot;.&#x2F;main.js&quot; &#125; &#125;&#125; 上面代码中，别名.的require条件指定require()命令的入口文件（即 CommonJS 的入口），default条件指定其他情况的入口（即 ES6 的入口）。 上面的写法可以简写如下。 123456&#123; &quot;exports&quot;: &#123; &quot;require&quot;: &quot;.&#x2F;main.cjs&quot;, &quot;default&quot;: &quot;.&#x2F;main.js&quot; &#125;&#125; 注意，如果同时还有其他别名，就不能采用简写，否则或报错。 12345678&#123; &#x2F;&#x2F; 报错 &quot;exports&quot;: &#123; &quot;.&#x2F;feature&quot;: &quot;.&#x2F;lib&#x2F;feature.js&quot;, &quot;require&quot;: &quot;.&#x2F;main.cjs&quot;, &quot;default&quot;: &quot;.&#x2F;main.js&quot; &#125;&#125; ES6 模块加载 CommonJS 模块目前，一个模块同时支持 ES6 和 CommonJS 两种格式的常见方法是，package.json文件的main字段指定 CommonJS 入口，给 Node.js 使用；module字段指定 ES6 模块入口，给打包工具使用，因为 Node.js 不认识module字段。 有了上一节的条件加载以后，Node.js 本身就可以同时处理两种模块。 123456789&#x2F;&#x2F; .&#x2F;node_modules&#x2F;pkg&#x2F;package.json&#123; &quot;type&quot;: &quot;module&quot;, &quot;main&quot;: &quot;.&#x2F;index.cjs&quot;, &quot;exports&quot;: &#123; &quot;require&quot;: &quot;.&#x2F;index.cjs&quot;, &quot;default&quot;: &quot;.&#x2F;wrapper.mjs&quot; &#125;&#125; 上面代码指定了 CommonJS 入口文件index.cjs，下面是这个文件的代码。 12&#x2F;&#x2F; .&#x2F;node_modules&#x2F;pkg&#x2F;index.cjsexports.name &#x3D; &#39;value&#39;; 然后，ES6 模块可以加载这个文件。 123&#x2F;&#x2F; .&#x2F;node_modules&#x2F;pkg&#x2F;wrapper.mjsimport cjsModule from &#39;.&#x2F;index.cjs&#39;;export const name &#x3D; cjsModule.name; 注意，import命令加载 CommonJS 模块，只能整体加载，不能只加载单一的输出项。 12345&#x2F;&#x2F; 正确import packageMain from &#39;commonjs-package&#39;;&#x2F;&#x2F; 报错import &#123; method &#125; from &#39;commonjs-package&#39;; 还有一种变通的加载方法，就是使用 Node.js 内置的module.createRequire()方法。 12345678910&#x2F;&#x2F; cjs.cjsmodule.exports &#x3D; &#39;cjs&#39;;&#x2F;&#x2F; esm.mjsimport &#123; createRequire &#125; from &#39;module&#39;;const require &#x3D; createRequire(import.meta.url);const cjs &#x3D; require(&#39;.&#x2F;cjs.cjs&#39;);cjs &#x3D;&#x3D;&#x3D; &#39;cjs&#39;; &#x2F;&#x2F; true 上面代码中，ES6 模块通过module.createRequire()方法可以加载 CommonJS 模块 CommonJS 模块加载 ES6 模块CommonJS 的require命令不能加载 ES6 模块，会报错，只能使用import()这个方法加载。 123(async () &#x3D;&gt; &#123; await import(&#39;.&#x2F;my-app.mjs&#39;);&#125;)(); 上面代码可以在 CommonJS 模块中运行。 Node.js 的内置模块Node.js 的内置模块可以整体加载，也可以加载指定的输出项。 12345678910111213&#x2F;&#x2F; 整体加载import EventEmitter from &#39;events&#39;;const e &#x3D; new EventEmitter();&#x2F;&#x2F; 加载指定的输出项import &#123; readFile &#125; from &#39;fs&#39;;readFile(&#39;.&#x2F;foo.txt&#39;, (err, source) &#x3D;&gt; &#123; if (err) &#123; console.error(err); &#125; else &#123; console.log(source); &#125;&#125;); 加载路径ES6 模块的加载路径必须给出脚本的完整路径，不能省略脚本的后缀名。import命令和package.json文件的main字段如果省略脚本的后缀名，会报错。 12&#x2F;&#x2F; ES6 模块中将报错import &#123; something &#125; from &#39;.&#x2F;index&#39;; 为了与浏览器的import加载规则相同，Node.js 的.mjs文件支持 URL 路径。 1import &#39;.&#x2F;foo.mjs?query&#x3D;1&#39;; &#x2F;&#x2F; 加载 .&#x2F;foo 传入参数 ?query&#x3D;1 上面代码中，脚本路径带有参数?query=1，Node 会按 URL 规则解读。同一个脚本只要参数不同，就会被加载多次，并且保存成不同的缓存。由于这个原因，只要文件名中含有:、%、#、?等特殊字符，最好对这些字符进行转义。 目前，Node.js 的import命令只支持加载本地模块（file:协议）和data:协议，不支持加载远程模块。另外，脚本路径只支持相对路径，不支持绝对路径（即以/或//开头的路径）。 最后，Node 的import命令是异步加载，这一点与浏览器的处理方法相同。 内部变量ES6 模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。为了达到这个目标，Node 规定 ES6 模块之中不能使用 CommonJS 模块的特有的一些内部变量。 首先，就是this关键字。ES6 模块之中，顶层的this指向undefined；CommonJS 模块的顶层this指向当前模块，这是两者的一个重大差异。 其次，以下这些顶层变量在 ES6 模块之中都是不存在的。 123456argumentsrequiremoduleexports__filename__dirname 循环加载“循环加载”（circular dependency）指的是，a脚本的执行依赖b脚本，而b脚本的执行又依赖a脚本。 12345&#x2F;&#x2F; a.jsvar b &#x3D; require(&#39;b&#39;);&#x2F;&#x2F; b.jsvar a &#x3D; require(&#39;a&#39;); 通常，“循环加载”表示存在强耦合，如果处理不好，还可能导致递归加载，使得程序无法执行，因此应该避免出现。 但是实际上，这是很难避免的，尤其是依赖关系复杂的大项目，很容易出现a依赖b，b依赖c，c又依赖a这样的情况。这意味着，模块加载机制必须考虑“循环加载”的情况。 对于 JavaScript 语言来说，目前最常见的两种模块格式 CommonJS 和 ES6，处理“循环加载”的方法是不一样的，返回的结果也不一样。 CommonJS 模块的加载原理介绍 ES6 如何处理“循环加载”之前，先介绍目前最流行的 CommonJS 模块格式的加载原理。 CommonJS 的一个模块，就是一个脚本文件。require命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。 123456&#123; id: &#39;...&#39;, exports: &#123; ... &#125;, loaded: true, ...&#125; 上面代码就是 Node 内部加载模块后生成的一个对象。该对象的id属性是模块名，exports属性是模块输出的各个接口，loaded属性是一个布尔值，表示该模块的脚本是否执行完毕。其他还有很多属性，这里都省略了。 以后需要用到这个模块的时候，就会到exports属性上面取值。即使再次执行require命令，也不会再次执行该模块，而是到缓存之中取值。也就是说，CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。 CommonJS 模块的循环加载CommonJS 模块的重要特性是加载时执行，即脚本代码在require的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。 让我们来看，Node 官方文档里面的例子。脚本文件a.js代码如下。 12345exports.done &#x3D; false;var b &#x3D; require(&#39;.&#x2F;b.js&#39;);console.log(&#39;在 a.js 之中，b.done &#x3D; %j&#39;, b.done);exports.done &#x3D; true;console.log(&#39;a.js 执行完毕&#39;); 上面代码之中，a.js脚本先输出一个done变量，然后加载另一个脚本文件b.js。注意，此时a.js代码就停在这里，等待b.js执行完毕，再往下执行。 再看b.js的代码。 12345exports.done &#x3D; false;var a &#x3D; require(&#39;.&#x2F;a.js&#39;);console.log(&#39;在 b.js 之中，a.done &#x3D; %j&#39;, a.done);exports.done &#x3D; true;console.log(&#39;b.js 执行完毕&#39;); 上面代码之中，b.js执行到第二行，就会去加载a.js，这时，就发生了“循环加载”。系统会去a.js模块对应对象的exports属性取值，可是因为a.js还没有执行完，从exports属性只能取回已经执行的部分，而不是最后的值。 a.js已经执行的部分，只有一行。 exports.done = false; 因此，对于b.js来说，它从a.js只输入一个变量done，值为false。 然后，b.js接着往下执行，等到全部执行完毕，再把执行权交还给a.js。于是，a.js接着往下执行，直到执行完毕。我们写一个脚本main.js，验证这个过程。 123var a &#x3D; require(&#39;.&#x2F;a.js&#39;);var b &#x3D; require(&#39;.&#x2F;b.js&#39;);console.log(&#39;在 main.js 之中, a.done&#x3D;%j, b.done&#x3D;%j&#39;, a.done, b.done); 执行main.js，运行结果如下。 123456789$ node main.js在 &#96;b.js&#96; 之中，&#96;a.done &#x3D; false&#96;&#96;b.js&#96; 执行完毕在 a.js 之中，b.done &#x3D; truea.js 执行完毕在 main.js 之中, a.done&#x3D;true, b.done&#x3D;true 上面的代码证明了两件事。一是，在b.js之中，a.js没有执行完毕，只执行了第一行。二是，main.js执行到第二行时，不会再次执行b.js，而是输出缓存的b.js的执行结果，即它的第四行。 1exports.done &#x3D; true; 总之，CommonJS 输入的是被输出值的拷贝，不是引用。 另外，由于 CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。 12345678910var a &#x3D; require(&#39;a&#39;); &#x2F;&#x2F; 安全的写法var foo &#x3D; require(&#39;a&#39;).foo; &#x2F;&#x2F; 危险的写法exports.good &#x3D; function (arg) &#123; return a.foo(&#39;good&#39;, arg); &#x2F;&#x2F; 使用的是 a.foo 的最新值&#125;;exports.bad &#x3D; function (arg) &#123; return foo(&#39;bad&#39;, arg); &#x2F;&#x2F; 使用的是一个部分加载时的值&#125;; 上面代码中，如果发生循环加载，require(&#39;a&#39;).foo的值很可能后面会被改写，改用require(&#39;a&#39;)会更保险一点。 ES6 模块的循环加载ES6 处理“循环加载”与 CommonJS 有本质的不同。ES6 模块是动态引用，如果使用import从一个模块加载变量（即import foo from &#39;foo&#39;），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。 请看下面这个例子。 1234567891011&#x2F;&#x2F; a.mjsimport &#123;bar&#125; from &#39;.&#x2F;b&#39;;console.log(&#39;a.mjs&#39;);console.log(bar);export let foo &#x3D; &#39;foo&#39;;&#x2F;&#x2F; b.mjsimport &#123;foo&#125; from &#39;.&#x2F;a&#39;;console.log(&#39;b.mjs&#39;);console.log(foo);export let bar &#x3D; &#39;bar&#39;; 上面代码中，a.mjs加载b.mjs，b.mjs又加载a.mjs，构成循环加载。执行a.mjs，结果如下。 123$ node --experimental-modules a.mjsb.mjsReferenceError: foo is not defined 上面代码中，执行a.mjs以后会报错，foo变量未定义，这是为什么？ 让我们一行行来看，ES6 循环加载是怎么处理的。首先，执行a.mjs以后，引擎发现它加载了b.mjs，因此会优先执行b.mjs，然后再执行a.mjs。接着，执行b.mjs的时候，已知它从a.mjs输入了foo接口，这时不会去执行a.mjs，而是认为这个接口已经存在了，继续往下执行。执行到第三行console.log(foo)的时候，才发现这个接口根本没定义，因此报错。 解决这个问题的方法，就是让b.mjs运行的时候，foo已经有定义了。这可以通过将foo写成函数来解决。 12345678910111213&#x2F;&#x2F; a.mjsimport &#123;bar&#125; from &#39;.&#x2F;b&#39;;console.log(&#39;a.mjs&#39;);console.log(bar());function foo() &#123; return &#39;foo&#39; &#125;export &#123;foo&#125;;&#x2F;&#x2F; b.mjsimport &#123;foo&#125; from &#39;.&#x2F;a&#39;;console.log(&#39;b.mjs&#39;);console.log(foo());function bar() &#123; return &#39;bar&#39; &#125;export &#123;bar&#125;; 这时再执行a.mjs就可以得到预期结果。 12345$ node --experimental-modules a.mjsb.mjsfooa.mjsbar 这是因为函数具有提升作用，在执行import {bar} from &#39;./b&#39;时，函数foo就已经有定义了，所以b.mjs加载的时候不会报错。这也意味着，如果把函数foo改写成函数表达式，也会报错。 123456&#x2F;&#x2F; a.mjsimport &#123;bar&#125; from &#39;.&#x2F;b&#39;;console.log(&#39;a.mjs&#39;);console.log(bar());const foo &#x3D; () &#x3D;&gt; &#39;foo&#39;;export &#123;foo&#125;; 上面代码的第四行，改成了函数表达式，就不具有提升作用，执行就会报错。 我们再来看 ES6 模块加载器SystemJS给出的一个例子。 12345678910111213&#x2F;&#x2F; even.jsimport &#123; odd &#125; from &#39;.&#x2F;odd&#39;export var counter &#x3D; 0;export function even(n) &#123; counter++; return n &#x3D;&#x3D;&#x3D; 0 || odd(n - 1);&#125;&#x2F;&#x2F; odd.jsimport &#123; even &#125; from &#39;.&#x2F;even&#39;;export function odd(n) &#123; return n !&#x3D;&#x3D; 0 &amp;&amp; even(n - 1);&#125; 上面代码中，even.js里面的函数even有一个参数n，只要不等于 0，就会减去 1，传入加载的odd()。odd.js也会做类似操作。 运行上面这段代码，结果如下。 12345678910$ babel-node&gt; import * as m from &#39;.&#x2F;even.js&#39;;&gt; m.even(10);true&gt; m.counter6&gt; m.even(20)true&gt; m.counter17 上面代码中，参数n从 10 变为 0 的过程中，even()一共会执行 6 次，所以变量counter等于 6。第二次调用even()时，参数n从 20 变为 0，even()一共会执行 11 次，加上前面的 6 次，所以变量counter等于 17。 这个例子要是改写成 CommonJS，就根本无法执行，会报错。 1234567891011121314&#x2F;&#x2F; even.jsvar odd &#x3D; require(&#39;.&#x2F;odd&#39;);var counter &#x3D; 0;exports.counter &#x3D; counter;exports.even &#x3D; function (n) &#123; counter++; return n &#x3D;&#x3D; 0 || odd(n - 1);&#125;&#x2F;&#x2F; odd.jsvar even &#x3D; require(&#39;.&#x2F;even&#39;).even;module.exports &#x3D; function (n) &#123; return n !&#x3D; 0 &amp;&amp; even(n - 1);&#125; 上面代码中，even.js加载odd.js，而odd.js又去加载even.js，形成“循环加载”。这时，执行引擎就会输出even.js已经执行的部分（不存在任何结果），所以在odd.js之中，变量even等于undefined，等到后面调用even(n - 1)就会报错。 1234$ node&gt; var m &#x3D; require(&#39;.&#x2F;even&#39;);&gt; m.even(10)TypeError: even is not a function","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"CSS属性：字体属性和文本属性","slug":"01-CSS属性：字体属性和文本属性","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:44:34.000Z","comments":true,"path":"2020/04/18/01-CSS属性：字体属性和文本属性/","link":"","permalink":"http://yoursite.com/2020/04/18/01-CSS%E5%B1%9E%E6%80%A7%EF%BC%9A%E5%AD%97%E4%BD%93%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%87%E6%9C%AC%E5%B1%9E%E6%80%A7/","excerpt":"本文主要内容 CSS的单位 字体属性 文本属性 定位属性：position、float、overflow等","text":"本文主要内容 CSS的单位 字体属性 文本属性 定位属性：position、float、overflow等 CSS的单位 html中的单位只有一种，那就是像素px，所以单位是可以省略的，但是在CSS中不一样。CSS中的单位是必须要写的，因为它没有默认单位。 绝对单位1 in=2.54cm=25.4mm=72pt=6pc。 各种单位的含义： in：英寸Inches (1 英寸 = 2.54 厘米) cm：厘米Centimeters mm：毫米Millimeters pt：点Points，或者叫英镑 (1点 = 1/72英寸) pc：皮卡Picas (1 皮卡 = 12 点) 相对单位px：像素em：印刷单位相当于12个点%：百分比，相对周围的文字的大小 为什么说像素px是一个相对单位呢，这也很好理解。比如说，电脑屏幕的的尺寸是不变的，但是我们可以让其显示不同的分辨率，在不同的分辨率下，单个像素的长度肯定是不一样的啦。 font 字体属性CSS中，有很多非布局样式（与布局无关），包括：字体、行高、颜色、大小、背景、边框、滚动、换行、装饰性属性（粗体、斜体、下划线）等。 字体属性: css样式中，常见的字体属性有以下几种： 12345678p&#123; font-size: 50px; /*字体大小*/ line-height: 30px; /*行高*/ font-family: 幼圆,黑体; /*字体类型：如果没有幼圆就显示黑体，没有黑体就显示默认*/ font-style: italic ; /*italic表示斜体，normal表示不倾斜*/ font-weight: bold; /*粗体*/ font-variant: small-caps; /*小写变大写*/&#125; 行高CSS中，所有的行，都有行高。盒子模型的padding，绝对不是直接作用在文字上的，而是作用在“行”上的。 为了严格保证字在行里面居中，我们的工程师有一个约定： 行高、字号，一般都是偶数。这样可以保证，它们的差一定偶数，就能够被2整除。 如何让单行文本垂直居中小技巧：如果一段文本只有一行，如果此时设置行高 = 盒子高，就可以保证单行文本垂直居中。这个很好理解。 vertical-align: middle; 属性1vertical-align: middle; /*指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式。*/ 字号、行高、字体三大属性（1）字号： 1font-size:14px; （2）行高： 1line-height:24px; （3）字体：（font-family就是“字体”，family是“家庭”的意思） 1font-family:&quot;宋体&quot;; 是否加粗属性以及上面这三个属性，我们可以连写：（是否加粗、字号 font-size、行高 line-height、字体 font-family） 格式： 1font: 加粗 字号&#x2F;行高&#x2F; 字体 举例： 1font: 400 14px&#x2F;24px &quot;宋体&quot;; PS：400是nomal，700是bold。 上面这几个属性可以连写，但是有一个要求，font属性连写至少要有字号和字体，否则连写是不生效的（相当于没有这一行代码）。 2、字体属性的说明： （1）网页中不是所有字体都能用，因为这个字体要看用户的电脑里面装没装，比如你设置： 1font-family: &quot;华文彩云&quot;; 上方代码中，如果用户的 Windows 电脑里面没有这个字体，那么就会变成宋体。 页面中，中文我们一般使用：微软雅黑、宋体、黑体。英文使用：Arial、Times New Roman。页面中如果需要其他的字体，就需要单独安装字体，或者切图。 （2）为了防止用户电脑里，没有微软雅黑这个字体。就要用英语的逗号，提供备选字体。如下：（可以备选多个） 1font-family: &quot;微软雅黑&quot;,&quot;宋体&quot;; 上方代码表示：如果用户电脑里没有安装微软雅黑字体，那么就是宋体。 （3）我们须将英语字体放在最前面，这样所有的中文，就不能匹配英语字体，就自动的变为后面的中文字体： 1font-family: &quot;Times New Roman&quot;,&quot;微软雅黑&quot;,&quot;宋体&quot;; 上方代码的意思是，英文会采用Times New Roman字体，而中文会采用微软雅黑字体（因为美国人设计的Times New Roman字体并不针对中文，所以中文会采用后面的微软雅黑）。比如说，对于smyhvae哈哈哈这段文字，smyhvae会采用Times New Roman字体，而哈哈哈会采用微软雅黑字体。 可是，如果我们把中文字体写在前面：(错误写法) 1font-family: &quot;微软雅黑&quot;,&quot;Times New Roman&quot;,&quot;宋体&quot;; 上方代码会导致，中文和英文都会采用微软雅黑字体。 （4）所有的中文字体，都有英语别名。 微软雅黑的英语别名： 1font-family: &quot;Microsoft YaHei&quot;; 宋体的英语别名： 1font-family: &quot;SimSun&quot;; 于是，当我们把字号、行高、字体这三个属性合二为一时，也可以写成： 1font:12px&#x2F;30px &quot;Times New Roman&quot;,&quot;Microsoft YaHei&quot;,&quot;SimSun&quot;; （5）行高可以用百分比，表示字号的百分之多少。 一般来说，百分比都是大于100%的，因为行高一定要大于字号。 比如说， font:12px/200% “宋体”等价于font:12px/24px “宋体”。200%可以理解成word里面的2倍行高。 反过来， font:16px/48px “宋体”;等价于font:16px/300% “宋体”。 字体加粗属性1234567.div &#123; font-weight: normal; /*正常*/ font-weight: bold; /*加粗*/ font-weight: 100; font-weight: 200; font-weight: 900;&#125; 在设置字体是否加粗时，属性值既可以填写normal、bold这样的加粗字体，也可以直接填写 100至900 这样的数字。normal的值相当于400，bold的值相当于700。 文本属性CSS样式中，常见的文本属性有以下几种： letter-spacing: 0.5cm ; 单个字母之间的间距 word-spacing: 1cm; 单词之间的间距 text-decoration: none; 字体修饰：none 去掉下划线、underline 下划线、line-through 中划线、overline 上划线 text-transform: lowercase; 单词字体大小写。uppercase大写、lowercase小写、capitalize（每个单词的首字母大写） color:red; 字体颜色 text-align: center; 在当前容器中的对齐方式。属性值可以是：left、right、center（在当前容器的中间）、justify 列表属性1234ul li&#123; list-style-image:url(images/2.gif) ; /*列表项前设置为图片*/ margin-left:80px; /*公有属性*/&#125; 另外还有一个简写属性叫做list-style，它的作用是：将上面的多个属性写在一个声明中。 overflow属性：超出范围的内容要怎么处理overflow属性的属性值可以是： visible：默认值。多余的内容不剪切也不添加滚动条，会全部显示出来。 hidden：不显示超过对象尺寸的内容。 auto：如果内容不超出，则不显示滚动条；如果内容超出，则显示滚动条。 scroll：Windows 平台下，无论内容是否超出，总是显示滚动条。Mac 平台下，和 auto 属性相同。 举例： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!doctype html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"Generator\" content=\"EditPlus®\"&gt; &lt;meta name=\"Author\" content=\"\"&gt; &lt;meta name=\"Keywords\" content=\"\"&gt; &lt;meta name=\"Description\" content=\"\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=\"text/css\"&gt; div&#123; width: 100px; height: 100px; background-color: #00cc66; margin-right: 100px; float: left; &#125; #div1&#123; overflow: auto;/*超出的部分让浏览器自行解决*/ &#125; #div2&#123; overflow: visible;/*超出的部分会显示出来*/ &#125; #div3&#123; overflow: hidden;/*超出的部分将剪切掉*/ &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"div1\"&gt;其实很简单 其实很自然 两个人的爱由两人分担 其实并不难 是你太悲观 隔着一道墙不跟谁分享 不想让你为难 你不再需要给我个答案&lt;/div&gt; &lt;div id=\"div2\"&gt;其实很简单 其实很自然 两个人的爱由两人分担 其实并不难 是你太悲观 隔着一道墙不跟谁分享 不想让你为难 你不再需要给我个答案&lt;/div&gt; &lt;div id=\"div3\"&gt;其实很简单 其实很自然 两个人的爱由两人分担 其实并不难 是你太悲观 隔着一道墙不跟谁分享 不想让你为难 你不再需要给我个答案&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 鼠标的属性 cursor鼠标的属性cursor有以下几个属性值： auto：默认值。浏览器根据当前情况自动确定鼠标光标类型。 pointer：IE6.0，竖起一只手指的手形光标。就像通常用户将光标移到超链接上时那样。 hand：和pointer的作用一样：竖起一只手指的手形光标。就像通常用户将光标移到超链接上时那样。 比如说，我想让鼠标放在那个标签上时，光标显示手状，代码如下： 123p:hover&#123; cursor: pointer;&#125; 另外还有以下的属性：（不用记，需要的时候查一下就行了） all-scroll : IE6.0 有上下左右四个箭头，中间有一个圆点的光标。用于标示页面可以向上下左右任何方向滚动。 col-resize : IE6.0 有左右两个箭头，中间由竖线分隔开的光标。用于标示项目或标题栏可以被水平改变尺寸。 crosshair : 简单的十字线光标。 default : 客户端平台的默认光标。通常是一个箭头。 hand : 竖起一只手指的手形光标。就像通常用户将光标移到超链接上时那样。 move : 十字箭头光标。用于标示对象可被移动。 help : 带有问号标记的箭头。用于标示有帮助信息存在。 no-drop : IE6.0 带有一个被斜线贯穿的圆圈的手形光标。用于标示被拖起的对象不允许在光标的当前位置被放下。 not-allowed : IE6.0 禁止标记(一个被斜线贯穿的圆圈)光标。用于标示请求的操作不允许被执行。 progress : IE6.0 带有沙漏标记的箭头光标。用于标示一个进程正在后台运行。 row-resize : IE6.0 有上下两个箭头，中间由横线分隔开的光标。用于标示项目或标题栏可以被垂直改变尺寸。 text : 用于标示可编辑的水平文本的光标。通常是大写字母 I 的形状。 vertical-text : IE6.0 用于标示可编辑的垂直文本的光标。通常是大写字母 I 旋转90度的形状。 wait : 用于标示程序忙用户需要等待的光标。通常是沙漏或手表的形状。 *-resize : 用于标示对象可被改变尺寸方向的箭头光标。 w-resize | s-resize | n-resize | e-resize | ne-resize | sw-resize | se-resize | nw-resize url ( url ) : IE6.0 用户自定义光标。使用绝对或相对 url 地址指定光标文件(后缀为 .cur 或者 .ani )。 滤镜这里只举一个滤镜的例子吧。比如说让图片变成灰度图的效果，可以这样设置滤镜： 1&lt;img src=\"3.jpg\" style=\"filter:gray()\"&gt;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"JavaScriptWindow-浏览器对象模型","slug":"01-JavaScriptWindow-浏览器对象模型","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:44:04.000Z","comments":true,"path":"2020/04/18/01-JavaScriptWindow-浏览器对象模型/","link":"","permalink":"http://yoursite.com/2020/04/18/01-JavaScriptWindow-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/","excerpt":"前言浏览器对象模型（Browser Object Model (BOM)）允许 JavaScript 与浏览器对话。 浏览器对象模型（Browser Object Model (BOM)）不存在浏览器对象模型（BOM）的官方标准。 现代的浏览器已经（几乎）实现了 JavaScript 交互相同的方法和属性，因此它经常作为 BOM 的方法和属性被提到。","text":"前言浏览器对象模型（Browser Object Model (BOM)）允许 JavaScript 与浏览器对话。 浏览器对象模型（Browser Object Model (BOM)）不存在浏览器对象模型（BOM）的官方标准。 现代的浏览器已经（几乎）实现了 JavaScript 交互相同的方法和属性，因此它经常作为 BOM 的方法和属性被提到。 Window 对象所有浏览器都支持 window 对象。它代表浏览器的窗口。 所有全局 JavaScript 对象，函数和变量自动成为 window 对象的成员。 全局变量是 window 对象的属性。 全局函数是 window 对象的方法。 甚至（HTML DOM 的）document 对象也是 window 对象属性： 1window.document.getElementById(&quot;header&quot;); 等同于： 1document.getElementById(&quot;header&quot;); 窗口尺寸两个属性可用用于确定浏览器窗口的尺寸。 这两个属性都以像素返回尺寸： window.innerHeight - 浏览器窗口的内高度（以像素计） window.innerWidth - 浏览器窗口的内宽度（以像素计） 浏览器窗口（浏览器视口）不包括工具栏和滚动条。 对于 Internet Explorer 8, 7, 6, 5： document.documentElement.clientHeight document.documentElement.clientWidth 或 document.body.clientHeight document.body.clientWidth 一个实用的 JavaScript 解决方案（包括所有浏览器）： 实例 1234567var w &#x3D; window.innerWidth|| document.documentElement.clientWidth|| document.body.clientWidth;var h &#x3D; window.innerHeight|| document.documentElement.clientHeight|| document.body.clientHeight; 其他窗口方法一些其他方法： window.open() - 打开新窗口 window.close() - 关闭当前窗口 window.moveTo() -移动当前窗口 window.resizeTo() -重新调整当前窗口","categories":[{"name":"BOM","slug":"BOM","permalink":"http://yoursite.com/categories/BOM/"}],"tags":[{"name":"BOM","slug":"BOM","permalink":"http://yoursite.com/tags/BOM/"}]},{"title":"JS简介","slug":"01-JS简介","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:44:24.000Z","comments":true,"path":"2020/04/18/01-JS简介/","link":"","permalink":"http://yoursite.com/2020/04/18/01-JS%E7%AE%80%E4%BB%8B/","excerpt":"JavaScript背景Web前端有三层： HTML：从语义的角度，描述页面结构 CSS：从审美的角度，描述样式（美化页面） JavaScript：从交互的角度，描述行为（实现业务逻辑和页面控制）","text":"JavaScript背景Web前端有三层： HTML：从语义的角度，描述页面结构 CSS：从审美的角度，描述样式（美化页面） JavaScript：从交互的角度，描述行为（实现业务逻辑和页面控制） 发展历史 JavaScript诞生于1995年。布兰登 • 艾奇（Brendan Eich，1961年～），1995年在网景公司，发明的JavaScript。 JavaScript是由网景公司发明，起初命名为LiveScript；1995年年12月SUN公司合作，因市场宣传需要，改名为 JavaScript。 后来 Sun 公司 被Oracle收购，JavaScript版权归Oracle所有。 备注：由于当时Java这个语言特别火，所以为了傍大牌，就改名为JavaScript。如同“北大”和“北大青鸟”的关系。“北大青鸟”就是傍“北大”大牌。 同时期还有其他的网页语言，比如VBScript、JScript等等，但是后来都被JavaScript打败了，所以现在的浏览器中，只运行一种脚本语言就是JavaScript。 JavaScript是世界上用的最多的脚本语言。 JavaScript的发展：蒸蒸日上2003年之前，JavaScript被认为“牛皮鲜”，用来制作页面上的广告，弹窗、漂浮的广告。什么东西让人烦，什么东西就是JavaScript开发的。所以很多浏览器就推出了屏蔽广告功能。 2004年，JavaScript命运开始改变。那一年，谷歌公司开始带头使用Ajax技术，Ajax技术就是JavaScript的一个应用。并且，那时候人们逐渐开始提升用户体验了。Ajax有一些应用场景。比如，当我们在百度搜索框搜文字时，输入框下方的智能提示，可以通过Ajax实现。比如，当我们注册网易邮箱时，能够及时发现用户名是否被占用，而不用调到另外一个页面。 2007年乔布斯发布了第一款iPhone，这一年开始，用户就多了上网的途径，就是用移动设备上网。JavaScript在移动页面中，也是不可或缺的。并且这一年，互联网开始标准化，按照W3C规则三层分离，JavaScript越来越被重视。 2010年，人们更加了解HTML5技术，HTML5推出了一个东西叫做Canvas（画布），工程师可以在Canvas上进行游戏制作，利用的就是JavaScript。 2011年，Node.js诞生，使JavaScript能够开发服务器程序了。 如今，WebApp已经非常流行，就是用网页技术开发手机应用。手机系统有iOS、安卓。比如公司要开发一个“携程网”App，就需要招聘三队人马，比如iOS工程师10人，安卓工程师10人，前端工程师10人。共30人，开发成本大；而且如果要改版，要改3个版本。现在，假设公司都用web技术，用html+css+javascript技术就可以开发App。也易于迭代（网页一改变，所有的终端都变了）。 虽然目前WebApp（Web应用）在功能和性能上的体验远不如Native App（原生应用），但是“在原生App中内嵌一部分H5页面”已经是一种趋势。 浏览器的介绍浏览器是网页运行的平台，常用的浏览器有谷歌（Chrome）、Safari、火狐（Firefox）、IE、Edge、Opera等。 浏览器的组成浏览器分成两部分： 渲染引擎 JS 引擎 1、渲染引擎：（浏览器内核） 浏览器所采用的「渲染引擎」也称之为「浏览器内核」，用来解析 HTML与CSS。渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。渲染引擎是兼容性问题出现的根本原因。 常见浏览器的内核如下： 浏览器 内核 chrome / 欧鹏 Blink Safari Webkit Firefox 火狐 Gecko IE Trident 2、JS 引擎： 也称为 JS 解释器。 用来解析网页中的JavaScript代码，对其处理后再运行。 浏览器本身并不会执行JS代码，而是通过内置 JavaScript 引擎(解释器) 来执行 JS 代码 。JS 引擎执行时会逐行解释源码（转换为机器语言），然后由计算机去执行。 浏览器本身并不会执行JS代码，而是通过内置 JavaScript 引擎(解释器) 来执行 JS 代码 。JS 引擎执行代码时逐行解释每一句源码（转换为机器语言），然后由计算机去执行。所以 JavaScript 语言归为脚本语言，会逐行解释执行。 常见浏览器的 JS 引擎如下： 浏览器 JS 引擎 chrome / 欧鹏 V8 Safari Nitro Firefox 火狐 SpiderMonkey（1.0-3.0）/ TraceMonkey（3.5-3.6）/ JaegerMonkey（4.0-） Opera Linear A（4.0-6.1）/ Linear B（7.0-9.2）/ Futhark（9.5-10.2）/ Carakan（10.5-） IE Trident 参考链接： 主流浏览器内核及JS引擎 浏览器工作原理 1、User Interface 用户界面，我们所看到的浏览器 2、Browser engine 浏览器引擎，用来查询和操作渲染引擎 3、Rendering engine 用来显示请求的内容，负责解析HTML、CSS 4、Networking 网络，负责发送网络请求 5、JavaScript Interpreter(解析者) JavaScript解析器，负责执行JavaScript的代码 6、UI Backend UI后端，用来绘制类似组合框和弹出窗口 7、Data Persistence(持久化) 数据持久化，数据存储 cookie、HTML5中的sessionStorage 参考链接：https://www.2cto.com/kf/201202/118111.html JavaScript介绍JavaScript入门易学性 JavaScript对初学者比较友好、简单易用。可以使用任何文本编辑工具编写，只需要浏览器就可以执行程序。 JavaScript是有界面效果的（相比之下，C语言只有白底黑字）。 JavaScript是弱变量类型的语言，变量只需要用 var/let/const 来声明。而Java中变量的声明，要根据变量的类型来定义。 比如Java中需要定义如下变量： 12345int a;float a;double a;String a;boolean a; 而JavaScript中，只需要用一种方式来定义： 123456// ES5 写法var a;// ES6 写法const a;let a; JavaScript是前端语言JavaScript是前端语言，而不是后台语言。 JavaScript运行在用户的终端网页上，而不是服务器上，所以我们称之为“前端语言”。就是服务于页面的交互效果、美化，不能操作数据库。 后台语言是运行在服务器上的，比如PHP、ASP、JSP等等，这些语言都能够操作数据库，都能够对数据库进行“增删改查”操作。 备注：Node.js是用 JavaScript 开发的，现在也可以基于 Node.js 技术进行服务器端编程。 JavaScript的组成JavaScript基础分为三个部分： ECMAScript：JavaScript的语法标准。包括变量、表达式、运算符、函数、if语句、for语句等。 DOM：Document Object Model（文档对象模型），操作页面上的元素的API。比如让盒子移动、变色、改变大小、轮播图等等。 BOM：Browser Object Model（浏览器对象模型），操作浏览器部分功能的API。通过BOM可以操作浏览器窗口，比如弹框、控制浏览器跳转、获取浏览器分辨率等等。 JavaScript 的特点特点1：解释型语言JavaScript 是解释型语言，不需要事先被翻译为机器码；而是边翻译边执行（翻译一行，执行一行）。 什么是「解释型语言」？详见下一段。 由于少了实现编译这一步骤，所以解释型语言开发起来尤为方便，但是解释型语言运行较慢也是它的劣势。不过解释型语言中使用了JIT技术，使得运行速度得以改善。 特点2：单线程特点3：ECMAScript标准ECMAScript是一种由 ECMA 国际（前身为欧洲计算机制造商协会,英文名称是European Computer Manufacturers Association）制定和发布的脚本语言规范。 JavaScript是由公司开发而成的，问题是不便于其他的公司拓展和使用。所以欧洲的这个ECMA的组织，牵头制定JavaScript的标准，取名为ECMAScript。 简单来说，ECMAScript不是一门语言，而是一个标准。ECMAScript 规定了JS的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套JS语法工业标准。 ECMAScript在2015年6月，发布了ECMAScript 6版本（ES6），语言的能力更强（也包含了很多新特性）。但是，浏览器的厂商不会那么快去追上这个标准，需要时间。 编程语言的分类翻译器计算机不能直接理解任何除机器语言以外的语言，所以必须要把程序员所编写的语言翻译成机器语言，计算机才能执行程序。程序语言翻译成机器语言的工具，被称为翻译器。 由此可见，所谓的“翻译”，指的是翻译成计算机能够执行的指令。 翻译器翻译的方式有两种：一种是编译，另一种是解释。两种方式之间的区别在于翻译的时机不同。 编译器：在代码执行之前，事前把所有的代码一次性翻译好，生成中间代码文件，然后整体执行。 解释器：边翻译，边执行（在代码执行时进行及时翻译，并立即执行）。当编译器以解释的方式运行时，也称之为解释器。 对应的语言，称之为“编译型语言”、“解释型语言”。 编译型语言 定义：事先把所有的代码一次性翻译好，然后整体执行。 优点：运行更快。 不足：移植性不好，不跨平台。 编译型语言举例：c、c++ 比如说，c语言的代码文件是.c后缀，翻译之后文件是.obj后缀，系统执行的是 obj 文件；再比如， java 语言的代码文件是.java后缀，翻译之后的文件是.class后缀。（注意，Java 语言不是严格的 编译型语言，这个一会儿会讲） 解释型语言 定义：边翻译边执行（翻译一行，执行一行），不需要事先一次性翻译。 优点：移植性好，跨平台。 缺点：运行更慢。 解释型语言举例：JavaScript、php、Python。 Java语言Java 语言既不是编译型语言，也不是解释型语言。翻译过程： （1）编译：.java代码文件先通过 javac 命令编译成.class文件。 （2）执行：.class文件再通过 jvm 虚拟机，解释执行。有了 jvm 的存在，让 java 跨平台了。 开始写第一行JavaScript代码 JavaScript 代码的书写位置在哪里呢？这个问题，也可以理解成：引入 js 代码，有哪几种方式。 方式1：行内式代码举例： 1&lt;input type=\"button\" value=\"点我点我\" onclick=\"alert('千古壹号')\" /&gt; 完整的可执行代码如下： 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=\"button\" value=\"点我点我\" onclick=\"alert('千古壹号的方式1')\" /&gt; &lt;/body&gt;&lt;/html&gt; 分析： 可以将单行或少量 JS 代码写在HTML标签的事件属性中（以 on 开头的属性），比如放在上面的 onclick点击事件中。 这种书写方式，不推荐使用，原因是：可读性差，尤其是需要编写大量 JS代码时，容易出错；引号多层嵌套时，也容易出错。 关于代码中的「引号」，在HTML标签中，我们推荐使用双引号, JS 中我们推荐使用单引号。 方式2、内嵌式我们可以在html 页面的 &lt;body&gt; 标签里放入&lt;script type=”text/javascript”&gt;&lt;/script&gt;标签对儿，并在&lt;script&gt;里书写JavaScript 代码： 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; // 在这里写 js 代码 alert('千古壹号的方式2'); console.log('qianguyihao 方式2'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 分析： text表示纯文本，因为JavaScript也是一个纯文本的语言。 可以将多行JS代码写到 &lt;script&gt; 标签中。 内嵌式 JS 是学习时常用的方式。 方式3：引入外部的 JS 文件1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 引入外部的 js 文件 --&gt; &lt;script src=\"tool.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上面这段代码，依然是放到body标签里，可以和内嵌的js代码并列。 另外，引用外部 JS文件的 script 标签中间不可以再写代码。 总结： 我们在实战开发中，基本都是采用方式3，因为这种方式，可以确保 html 文件和 js 文件是分开的，有利于代码的结构化和复用。很少会有人把一大堆 js 代码塞到 html 文件里。 JS一些简单的语法规则学习程序，是有规律可循的，程序会有有相同的部分，这些部分就是一种规定，不能更改，我们成为：语法。 （1）JavaScript对换行、缩进、空格不敏感。每一条语句以分号结尾。 也就是说： 代码一： 1234&lt;script type=\"text/javascript\"&gt; alert(\"今天蓝天白云\"); alert(\"我很高兴\");&lt;/script&gt; 等价于代码二： 123&lt;script type=\"text/javascript\"&gt; alert(\"今天蓝天白云\");alert(\"我很高兴\");&lt;/script&gt; 备注：每一条语句末尾要加上分号，虽然分号不是必须加的，如果不写分号，浏览器会自动添加，但是会消耗一些系统资源。 （2）所有的符号，都是英语的。比如括号、引号、分号。 如果你用的是搜狗拼音，建议不要用shift切换中英文（可以在搜狗软件里进行设置），不然很容易输入中文的分号；建议用ctrl+space切换中英文输入法。 （3）严格区分大小写。 注释我们不要把 HTML、CSS、JavaScript三者的注释格式搞混淆了。 HTML 的注释1&lt;!-- 我是注释 --&gt; CSS的注释12345678910111213&lt;style type=\"text/css\"&gt; /* 我是注释 */ p&#123; font-weight: bold; font-style: italic; color: red; &#125;&lt;/style&gt; 注意：CSS只有/* */这种注释，没有//这种注释。而且注释要写在&lt;style&gt;标签里面才算生效哦。 JavaScript 的注释单行注释： 1&#x2F;&#x2F; 我是注释 多行注释： 1234&#x2F;* 多行注释1 多行注释2*&#x2F; 补充：VS Code中，单行注释的快捷键是「Ctrl + /」，多行注释的默认快捷键是「Alt + Shift + A」。 当然，如果你觉得多行注释的默认快捷键不方便，我们还可以修改默认快捷键。操作如下： VS Code –&gt; 首选项 –&gt; 键盘快捷方式 –&gt; 查找“注释”这两个字 –&gt; 将原来的快捷键修改为「Ctrl + Shift + /」。 Javascript 输入输出语句弹出警告框：alert语句我们要学习的第一个语句，就是alert语句。 代码举例如下： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; alert('千古壹号'); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; alert（英文翻译为“警报”）的用途：弹出“警告框”。 如果写了两个alert()语句的话，网页的效果是：弹出第一个警告框，点击确定后，继续弹出第二个警告框。 控制台输出：console.log(“”)console.log(&quot;&quot;)表示在控制台中输出。console表示“控制台”，log表示“输出”。 在Chrome浏览器中，按F12即可打开控制台，选择「console」栏，即可看到打印的内容。 控制台是工程师、程序员调试程序的地方。程序员经常使用这条语句输出一些东西，来测试程序是否正确。 总结：alert() 主要用来显示消息给用户，console.log() 用来给程序员自己调试用的。 弹出输入框：prompt()语句prompt()就是专门用来弹出能够让用户输入的对话框。用得少，测试的时候偶尔会用。 JS代码如下： 12var a = prompt(\"请随便输入点什么东西吧\");console.log(a); 上方代码中，用户输入的内容，将被传递到变量 a 里面，并在控制台打印出来。 效 prompt()语句中，用户不管输入什么内容，都是字符串。 alert()和prompt()的区别： alert() 可以直接使用。 prompt() 会返回用户输入的内容。我们可以用一个变量，来接收用户输入的内容。 confirm","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"cookie","slug":"01-cookie","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:44:58.000Z","comments":true,"path":"2020/04/18/01-cookie/","link":"","permalink":"http://yoursite.com/2020/04/18/01-cookie/","excerpt":"前言cookie是什么，cookie就是一种浏览器管理状态的一个文件，它有name，也有value，后面那些看不见的是Domain、path等等。 Cookie主要用于以下三个方面： 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息） 个性化设置（如用户自定义设置、主题等） 浏览器行为跟踪（如跟踪分析用户行为等）","text":"前言cookie是什么，cookie就是一种浏览器管理状态的一个文件，它有name，也有value，后面那些看不见的是Domain、path等等。 Cookie主要用于以下三个方面： 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息） 个性化设置（如用户自定义设置、主题等） 浏览器行为跟踪（如跟踪分析用户行为等） cookie原理第一次访问网站的时候，浏览器发出请求，服务器响应请求后，会将cookie放入到响应请求中，在浏览器第二次发请求的时候，会把cookie带过去，服务端会辨别用户身份，当然服务器也可以修改cookie内容。 cookie不可跨域cookie不能在不同的域名下用，每个cookie都会绑定单一的域名。 cookie的属性 name 这个显而易见，就是代表cookie的名字的意思，一个域名下绑定的cookie，name不能相同，相同的name的值会被覆盖掉。 value 这个就是每个cookie拥有的一个属性，它表示cookie的值。 domain 这个是指的域名，这个代表的是，cookie绑定的域名，如果没有设置，就会自动绑定到执行语句的当前域，还有值得注意的点，统一个域名下的二级域名也是不可以交换使用cookie的，比如，你设置www.baidu.com和image.baidu.com,依旧是不能公用的。 path path这个属性默认是’/‘，这个值匹配的是web的路由，举个例子：默认路径 www.baidu.com, blog路径www.baidu.com/blog， path为 /blog。当你路径设置成/blog的时候，其实它会给/blog、/blogabc等等的绑定cookie。 cookie的有效期有效期就是前言图中的Expires属性，一般浏览器的cookie都是默认储存的，当关闭浏览器结束这个会话的时候，这个cookie也就会被删除，这就是session(会话储存)。 如果你想要cookie存在一段时间，那么你可以通过设置Expires属性为未来的一个时间节点，Expires这个是代表当前时间的，这个属性已经逐渐被Max-Age所取代。 Max-Age，是以秒为单位的，Max-Age为正数时，cookie会在Max-Age秒之后，被删除，当Max-Age为负数时，表示的是临时储存，不会生出cookie文件，只会存在浏览器内存中，且只会在打开的浏览器窗口或者子窗口有效，一旦浏览器关闭，cookie就会消失，当Max-Age为0时，又会发生什么呢，删除cookie，因为cookie机制本身没有设置删除cookie，失效的cookie会被浏览器自动从内存中删除，所以，它实现的就是让cookie失效。 secure这个属性译为安全，http不仅是无状态的，还是不安全的协议，容易被劫持，当这个属性设置为true时，此cookie只会在https和ssl等安全协议下传输。 提示：这个属性并不能对客户端的cookie进行加密，不能保证绝对的安全性 HttpOnly为避免跨域脚本 (XSS) 攻击，通过JavaScript的 Document.cookie API无法访问带有 HttpOnly 标记的Cookie，它们只应该发送给服务端。如果包含服务端 Session 信息的 Cookie 不想被客户端 JavaScript 脚本调用，那么就应该为其设置 HttpOnly 标记。 SameSite CookiesSameSite Cookie允许服务器要求某个cookie在跨站请求时不会被发送，从而可以阻止跨站请求伪造攻击（CSRF）。 SameSite cookies是相对较新的一个字段，所有主流浏览器都已经得到支持。 下面是例子： Set-Cookie: key=value; SameSite=Strict JS操作cookie通过Document.cookie属性可创建新的Cookie，也可通过该属性访问非HttpOnly标记的Cookie。 1234document.cookie &#x3D; &quot;yummy_cookie&#x3D;choco&quot;; document.cookie &#x3D; &quot;tasty_cookie&#x3D;strawberry&quot;; console.log(document.cookie); &#x2F;&#x2F; logs &quot;yummy_cookie&#x3D;choco; tasty_cookie&#x3D;strawberry&quot; 服务端操作cookie响应首部 Set-Cookie被用来由服务器端向客户端发送 cookie。 12345678910111213Set-Cookie: &lt;cookie-name&gt;&#x3D;&lt;cookie-value&gt; Set-Cookie: &lt;cookie-name&gt;&#x3D;&lt;cookie-value&gt;; Expires&#x3D;&lt;date&gt;Set-Cookie: &lt;cookie-name&gt;&#x3D;&lt;cookie-value&gt;; Max-Age&#x3D;&lt;non-zero-digit&gt;Set-Cookie: &lt;cookie-name&gt;&#x3D;&lt;cookie-value&gt;; Domain&#x3D;&lt;domain-value&gt;Set-Cookie: &lt;cookie-name&gt;&#x3D;&lt;cookie-value&gt;; Path&#x3D;&lt;path-value&gt;Set-Cookie: &lt;cookie-name&gt;&#x3D;&lt;cookie-value&gt;; SecureSet-Cookie: &lt;cookie-name&gt;&#x3D;&lt;cookie-value&gt;; HttpOnlySet-Cookie: &lt;cookie-name&gt;&#x3D;&lt;cookie-value&gt;; SameSite&#x3D;StrictSet-Cookie: &lt;cookie-name&gt;&#x3D;&lt;cookie-value&gt;; SameSite&#x3D;Lax&#x2F;&#x2F; Multiple directives are also possible, for example:Set-Cookie: &lt;cookie-name&gt;&#x3D;&lt;cookie-value&gt;; Domain&#x3D;&lt;domain-value&gt;; Secure; HttpOnly ——-参考： https://juejin.im/post/59d1f59bf265da06700b0934 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies","categories":[{"name":"JS高级","slug":"JS高级","permalink":"http://yoursite.com/categories/JS%E9%AB%98%E7%BA%A7/"}],"tags":[{"name":"JS高级","slug":"JS高级","permalink":"http://yoursite.com/tags/JS%E9%AB%98%E7%BA%A7/"}]},{"title":"CSS属性：背景属性","slug":"02-CSS属性：背景属性","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:44:16.000Z","comments":true,"path":"2020/04/18/02-CSS属性：背景属性/","link":"","permalink":"http://yoursite.com/2020/04/18/02-CSS%E5%B1%9E%E6%80%A7%EF%BC%9A%E8%83%8C%E6%99%AF%E5%B1%9E%E6%80%A7/","excerpt":"background 的常见背景属性css2.1 中，常见的背景属性有以下几种：（经常用到，要记住） background-color:#ff99ff; 设置元素的背景颜色。 background-image:url(images/2.gif); 将图像设置为背景。","text":"background 的常见背景属性css2.1 中，常见的背景属性有以下几种：（经常用到，要记住） background-color:#ff99ff; 设置元素的背景颜色。 background-image:url(images/2.gif); 将图像设置为背景。 background-repeat: no-repeat; 设置背景图片是否重复及如何重复，默认平铺满。（重要） no-repeat不要平铺； repeat-x横向平铺； repeat-y纵向平铺。 background-position:center top; 设置背景图片在当前容器中的位置。 background-attachment:scroll; 设置背景图片是否跟着滚动条一起移动。属性值可以是：scroll（与fixed属性相反，默认属性）、fixed（背景就会被固定住，不会被滚动条滚走）。 另外还有一个综合属性叫做background，它的作用是：将上面的多个属性写在一个声明中。 CSS3 中，新增了一些background属性： background-origin background-clip 背景裁切 background-size 调整尺寸 多重背景 background-color：背景颜色的表示方法css2.1 中，背景颜色的表示方法有三种：单词、rgb表示法、十六进制表示法。 比如红色可以有下面的三种表示方法： 123background-color: red;background-color: rgb(255,0,0);background-color: #ff0000; CSS3 中，有一种新的表示颜色的方式：RGBA或者HSLA。 RGBA、HSLA可应用于所有使用颜色的地方。 下面分别介绍。 用英语单词表示能够用英语单词来表述的颜色，都是简单颜色。比如红色、绿色等。代码举例： 1background-color: red; RGB 表示法RGB 表示三原色“红”red、“绿”green、“蓝”blue。 光学显示器中，每个像素都是由三原色的发光原件组成的，靠明亮度不同调成不同的颜色的。r、g、b的值，每个值的取值范围0~255，一共256个值。 比如红色： 1background-color: rgb(255,0,0); 黑色： 1background-color: rgb(0,0,0); 颜色可以叠加，比如黄色就是红色和绿色的叠加： 1background-color: rgb(255,255,0); RGBA 表示法123background-color: rgba(0, 0, 255, 0.3);border: 30px solid rgba(0, 255, 0, 0.3); 解释： RGBA 即：Red、Green、Blue、Alpha R、G、B 的取值范围是：0~255 十六进制表示法比如红色： 1background-color: #ff0000; PS:所有用#开头的值，都是16进制的。 这里，我们就要学会16进制与10进制之间的转换。下面举几个例子。 问：16进制中28等于10进制多少？答：2*16+8 = 40。 16进制中的af等于10进制多少？答：10 * 16 + 15 = 175 所以，#ff0000就等于rgb(255,0,0)。 background-color: #123456;等价于background-color: rgb(18,52,86); 十六进制可以简化为3位，所有#aabbcc的形式，能够简化为#abc。举例如下： 比如： 1background-color:#ff0000; 等价于： 1background-color:#f00; 比如： 1background-color:#112233; 等价于： 1background-color:#123; 但是，比如下面这个是无法简化的： 1background-color:#222333; 再比如，下面这个也是无法简化的： 1background-color:#123123; 几种常见的颜色简写可以记住。如下： 123456#000 黑#fff 白#f00 红#222 深灰#333 灰#ccc 浅灰 HSLA 表示法举例： 1background-color: hsla(240,50%,50%,0.4); 解释： H 色调，取值范围 0~360。0或360表示红色、120表示绿色、240表示蓝色。 S 饱和度，取值范围 0%~100%。值越大，越鲜艳。 L 亮度，取值范围 0%~100%。亮度最大时为白色，最小时为黑色。 A 透明度，取值范围 0~1。 关于设置透明度的其他方式： （1）opacity: 0.3; 会将整个盒子及子盒子设置透明度。也就是说，当盒子设置半透明的时候，会影响里面的子盒子。 （2）background: transparent; 可以单独设置透明度，但设置的是完全透明（不可调节透明度）。 background-repeat属性background-repeat:no-repeat;设置背景图片是否重复及如何重复，默认平铺满。属性值可以是： no-repeat（不要平铺） repeat-x（横向平铺） repeat-y（纵向平铺） background-position属性background-position属性指的是背景定位属性。 在描述属性值的时候，有两种方式：用像素描述、用单词描述。下面分别介绍。 1、用像素值描述属性值： 格式如下： 1background-position:向右偏移量 向下偏移量; 属性值可以是正数，也可以是负数。比如：100px 200px、-50px -120px。 2、用单词描述属性值： 格式如下： 1background-position: 描述左右的词 描述上下的词; 描述左右的词：left、center、right 描述上下的词：top 、center、bottom 比如说，right center表示将图片放到右边的中间；center center表示将图片放到正中间。 比如说，bottom表示图片的底边和父亲底边贴齐（好好理解）。 background-attachment 属性 background-attachment:scroll; 设置背景图片是否固定。属性值可以是： fixed（背景就会被固定住，不会被滚动条滚走）。 scroll（与fixed属性相反，默认属性） background-attachment:fixed;的效果如下： background 综合属性background属性和border一样，是一个综合属性，可以将多个属性写在一起.举例1: 1background:red url(1.jpg) no-repeat 100px 100px fixed; 等价于： 12345background-color:red;background-image:url(1.jpg);background-repeat:no-repeat;background-position:100px 100px;background-attachment:fixed; background-size属性：背景尺寸background-size属性：设置背景图片的尺寸。 格式举例： 12345678910111213/* 宽、高的具体数值 */background-size: 500px 500px;/* 宽高的百分比（相对于容器的大小） */background-size: 50% 50%; // 如果两个属性值相同，可以简写成：background-size: 50%;background-size: 100% auto; //这个属性可以自己试验一下。/* cover：图片始终填充满容器，且保证长宽比不变。图片如果有超出部分，则超出部分会被隐藏。 */background-size: cover;/* contain：将图片完整地显示在容器中，且保证长宽比不变。可能会导致容器的部分区域为空白。 */background-size: contain; 这里我们对属性值 cover 和 contain 进行再次强调： cover：图片始终填充满容器，且保证长宽比不变。图片如果有超出部分，则超出部分会被隐藏。 contain：将图片完整地显示在容器中，且保证长宽比不变。可能会导致容器的部分区域留白。 背景原点：background-origin 属性background-origin 属性：控制背景从什么地方开始显示。 格式举例： 123456789/* 从 padding-box 内边距开始显示背景图 */background-origin: padding-box; //默认值/* 从 border-box 边框开始显示背景图 */background-origin: border-box;/* 从 content-box 内容区域开始显示背景图 */background-origin: content-box; 如果属性值设置成了border-box，那边框部分也会显示图片哦。 background-clip属性：设置元素的背景（背景图片或颜色）是否延伸到边框下面格式举例： background-clip: content-box; 超出的部分，将裁剪掉。属性值可以是： border-box 超出 border-box 的部分，将裁剪掉 padding-box 超出 padding-box 的部分，将裁剪掉 content-box 超出 content-box 的部分，将裁剪掉 假设现在有这样的属性设置： 123background-origin: border-box;background-clip: content-box; 上方代码的意思是，背景图片从边框部分开始加载，但是呢，超出内容区域的部分将被裁减掉。 同时设置多个背景我们可以给一个盒子同时设置多个背景，用以逗号隔开即可。可用于自适应局。 代码举例： 渐变：background-image渐变是CSS3当中比较丰富多彩的一个特性，通过渐变我们可以实现许多炫丽的效果，有效的减少图片的使用数量，并且具有很强的适应性和可扩展性。 渐变分为： 线性渐变：沿着某条直线朝一个方向产生渐变效果。linear-gradient 径向渐变：从一个中心点开始沿着四周产生渐变效果。radial-gradient 重复渐变。linear-gradient-repeat 线性渐变格式： 1234background-image: linear-gradient(方向, 起始颜色, 终止颜色);background-image: linear-gradient(to right, yellow, green); 参数解释： 方向可以是：to left、to right、to top、to bottom、角度30deg（指的是顺时针方向30°）。 格式举例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div &#123; width: 500px; height: 100px; margin: 10px auto; border: 1px solid #000; &#125; /* 语法： linear-gradient(方向，起始颜色，终止颜色); 方向：to left to right to top to bottom 角度 30deg 起始颜色 终止颜色 */ div:nth-child(1) &#123; background-image: linear-gradient(to right, yellow, green); &#125; /* 不写方向，表示默认的方向是：从上往下 */ div:nth-child(2) &#123; background-image: linear-gradient(yellow, green); &#125; /* 方向可以指定角度 */ div:nth-child(3) &#123; width: 100px; height: 100px; background-image: linear-gradient(135deg, yellow, green); &#125; /* 0%的位置开始出现黄色，40%的位置开始出现红色的过度。70%的位置开始出现绿色的过度，100%的位置开始出现蓝色 */ div:nth-child(4) &#123; background-image: linear-gradient(to right, yellow 0%, red 40%, green 70%, blue 100%); &#125; /* 颜色之间，出现突变 */ div:nth-child(5) &#123; background-image: linear-gradient(45deg, yellow 0%, yellow 25%, blue 25%, blue 50%, red 50%, red 75%, green 75%, green 100% ); &#125; div:nth-child(6) &#123; background-image: linear-gradient(to right, #000 0%, #000 25%, #fff 25%, #fff 50%, #000 50%, #000 75%, #fff 75%, #fff 100% ); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 径向渐变格式： 123background-image: radial-gradient(辐射的半径大小, 中心的位置, 起始颜色, 终止颜色);background-image: radial-gradient(100px at center,yellow ,green); 解释：围绕中心点做渐变，半径是150px，从黄色到绿色做渐变。 中心点的位置可以是：at left right center bottom top。如果以像素为单位，则中心点参照的是盒子的左上角。 当然，还有其他的各种参数。格式举例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div &#123; width: 250px; height: 250px; border: 1px solid #000; margin: 20px; float: left; &#125; /* 径向渐变： radial-gradient（辐射的半径大小, 中心的位置，起始颜色，终止颜色）; 中心点位置：at left right center bottom top */ /*辐射半径为100px，中心点在中间*/ div:nth-child(1) &#123; background-image: radial-gradient(100px at center, yellow, green); &#125; /*中心点在左上角*/ div:nth-child(3) &#123; background-image: radial-gradient(at left top, yellow, green); &#125; div:nth-child(2) &#123; background-image: radial-gradient(at 50px 50px, yellow, green); &#125; /*设置不同的颜色渐变*/ div:nth-child(4) &#123; background-image: radial-gradient(100px at center, yellow 0%, green 30%, blue 60%, red 100%); &#125; /*如果辐射半径的宽高不同，那就是椭圆*/ div:nth-child(5) &#123; background-image: radial-gradient(100px 50px at center, yellow, green); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"box\"&gt;&lt;/div&gt;&lt;div class=\"box\"&gt;&lt;/div&gt;&lt;div class=\"box\"&gt;&lt;/div&gt;&lt;div class=\"box\"&gt;&lt;/div&gt;&lt;div class=\"box\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; clip-path：裁剪出元素的部分区域做展示clip-path属性可以创建一个只有元素的部分区域可以显示的剪切区域。区域内的部分显示，区域外的隐藏。 虽然clip-path不是背景属性，但这个属性非常强大，但往往会结合背景属性一起使用，达到一些效果。 举例：（鼠标悬停时，放大裁剪的区域） 123456789101112131415.div1 &#123; width: 320px; height: 320px; border: 1px solid red; background: url(http://img.smyhvae.com/20191006_1410.png) no-repeat; background-size: cover; /* 裁剪出圆形区域 */ clip-path: circle(50px at 100px 100px); transition: clip-path .4s;&#125;.div1:hover&#123; /* 鼠标悬停时，裁剪出更大的圆形 */ clip-path: circle(80px at 100px 100px);&#125; clip-path属性的好处是，即使做了任何裁剪，容器的占位大小是不变的。比如上方代码中，容器的占位大小一直都是 320px * 320px。这样的话，也方便我们做一些动画效果。 clip-path: polygon()举例： 另外，通过 clip-path: (svg) 可以导入svg矢量图，实现 iOS图标的圆角。","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"JavaScriptWindowScreen","slug":"02-JavaScriptWindowScreen","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T03:50:42.000Z","comments":true,"path":"2020/04/18/02-JavaScriptWindowScreen/","link":"","permalink":"http://yoursite.com/2020/04/18/02-JavaScriptWindowScreen/","excerpt":"前言window.screen 对象包含用户屏幕的信息。 Window Screenwindow.screen 对象不带 window 前缀也可以写： 属性： screen.width screen.height screen.availWidth screen.availHeight screen.colorDepth screen.pixelDepth","text":"前言window.screen 对象包含用户屏幕的信息。 Window Screenwindow.screen 对象不带 window 前缀也可以写： 属性： screen.width screen.height screen.availWidth screen.availHeight screen.colorDepth screen.pixelDepth Window Screen 宽度screen.width 属性返回以像素计的访问者屏幕宽度。 实例 显示以像素计的屏幕宽度： 1document.getElementById(&quot;demo&quot;).innerHTML &#x3D; &quot;Screen Width: &quot; + screen.width; 结果将是： Screen Width: 1536 Window Screen 高度screen.height 属性返回以像素计的访问者屏幕的高度。 实例 显示以像素计的屏幕高度： 1document.getElementById(&quot;demo&quot;).innerHTML &#x3D; &quot;Screen Height: &quot; + screen.height; 结果将是： Screen Height: 864 Window Screen 可用宽度screen.availWidth 属性返回访问者屏幕的宽度，以像素计，减去诸如窗口工具条之类的界面特征。 实例 显示以像素计的屏幕可用宽度： 1document.getElementById(&quot;demo&quot;).innerHTML &#x3D; &quot;Available Screen Width: &quot; + screen.availWidth; 结果将是： Available Screen Width: 1536 Window Screen 可用高度screen.availHeight 属性返回访问者屏幕的高度，以像素计，减去诸如窗口工具条之类的界面特征。 实例 显示以像素计的屏幕可用高度： 1document.getElementById(&quot;demo&quot;).innerHTML &#x3D; &quot;Available Screen Height: &quot; + screen.availHeight; 结果将是： Available Screen Height: 864 Window Screen 色深screen.colorDepth 属性返回用于显示一种颜色的比特数。 所有现代计算机都使用 24 位或 32 位硬件的色彩分辨率： -24 bits =16,777,216 种不同的 “True Colors” 32 bits = 4,294,967,296 中不同的 “Deep Colors” 更老的计算机使用 14 位：65,536 种不同的 “High Colors” 分辨率。 异常古老的计算机，以及老式的手机使用 8 位：256 中不同的 “VGA colors”。 实例 显示以位计的屏幕色彩深度： 1234567891011121314结果将是：Screen Color Depth: 24## Window Screen 像素深度screen.pixelDepth 属性返回屏幕的像素深度。实例显示以位计的屏幕像素深度：&#96;&#96;&#96;&#96;document.getElementById(&quot;demo&quot;).innerHTML &#x3D; &quot;Screen Pixel Depth: &quot; + screen.pixelDepth;&#96; 结果将是： Screen Pixel Depth: 24 对于现代计算机，颜色深度和像素深度是相等的。","categories":[{"name":"BOM","slug":"BOM","permalink":"http://yoursite.com/categories/BOM/"}],"tags":[{"name":"BOM","slug":"BOM","permalink":"http://yoursite.com/tags/BOM/"}]},{"title":"事件循环","slug":"02-事件循环","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-20T01:15:24.000Z","comments":true,"path":"2020/04/18/02-事件循环/","link":"","permalink":"http://yoursite.com/2020/04/18/02-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/","excerpt":"—# 前言 JavaScript是一门单线程的非阻塞的脚本语言。 单线程意味着，JavaScript代码在执行的任何时候，都只有一个主线程来处理所有的任务。 非阻塞则是当代码需要进行一项异步任务，主线程会挂起（pending）这个任务，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调。","text":"—# 前言 JavaScript是一门单线程的非阻塞的脚本语言。 单线程意味着，JavaScript代码在执行的任何时候，都只有一个主线程来处理所有的任务。 非阻塞则是当代码需要进行一项异步任务，主线程会挂起（pending）这个任务，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调。 浏览器环境下js引擎的事件循环机制执行栈与事件队列当javascript代码执行的时候会将不同的变量存于内存中的不同位置：堆（heap）和栈（stack）中来加以区分。其中，堆里存放着一些对象。而栈中则存放着一些基础类型变量以及对象的指针。 但是我们这里说的执行栈和上面这个栈的意义却有些不同。 我们知道，当我们调用一个方法的时候，js会生成一个与这个方法对应的执行环境（context），又叫执行上下文。这个执行环境中存在着这个方法的私有作用域，上层作用域的指向，方法的参数，这个作用域中定义的变量以及这个作用域的this对象。 而当一系列方法被依次调用的时候，因为js是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方。这个地方被称为执行栈。 当一个脚本第一次执行的时候，js引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个方法，那么js会向执行栈中添加这个方法的执行环境，然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码 执行完毕并返回结果后，js会退出这个执行环境并把这个执行环境销毁，回到上一个方法的执行环境。。这个过程反复进行，直到执行栈中的代码全部执行完毕。 从图片可知，一个方法执行会向执行栈中加入这个方法的执行环境，在这个执行环境中还可以调用其他方法，甚至是自己，其结果不过是在执行栈中再添加一个执行环境。这个过程可以是无限进行下去的，除非发生了栈溢出，即超过了所能使用内存的最大值。 js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码…，如此反复，这样就形成了一个无限的循环。这就是这个过程被称为“事件循环（Event Loop）”的原因。 宏任务和微任务因为异步任务之间并不相同，因此他们的执行优先级也有区别。不同的异步任务被分为两类：微任务（micro task）和宏任务（macro task）。 以下事件属于宏任务： setInterval() setTimeout() 以下事件属于微任务 new Promise() new MutaionObserver() 前面我们介绍过，在一个事件循环中，异步事件返回结果后会被放到一个任务队列中。然而，根据这个异步事件的类型，这个事件实际上会被对应的宏任务队列或者微任务队列中去。并且在当前执行栈为空的时候，主线程会 查看微任务队列是否有事件存在。如果不存在，那么再去宏任务队列中取出一个事件并把对应的回到加入当前执行栈；如果存在，则会依次执行队列中事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的一个事件，把对应的回调加入当前执行栈…如此反复，进入循环。 我们只需记住当当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。 这样就能解释下面这段代码的结果： 12345678910setTimeout(function () &#123; console.log(1);&#125;);new Promise(function(resolve,reject)&#123; console.log(2) resolve(3)&#125;).then(function(val)&#123; console.log(val);&#125;) 结果为： 123231 node环境下的事件循环机制与浏览器环境有何不同?在node中，事件循环表现出的状态与浏览器中大致相同。不同的是node中有一套自己的模型。node中事件循环的实现是依靠的libuv引擎。我们知道node选择chrome v8引擎作为js解释器，v8引擎将js代码分析后去调用对应的node api，而这些api最后则由libuv引擎驱动，执行对应的任务，并把不同的事件放在不同的队列中等待主线程执行。 因此实际上node中的事件循环存在于libuv引擎中。 事件循环模型下面是一个libuv引擎中的事件循环的模型: 既然目前大多数内核都是多线程的，它们可在后台处理多种操作。当其中的一个操作完成的时候，内核通知 Node.js 将适合的回调函数添加到 轮询 队列中等待时机执行。我们在本文后面会进行详细介绍。 123456789101112131415161718 ┌───────────────────────────┐┌─&gt;│ timers ││ └─────────────┬─────────────┘│ ┌─────────────┴─────────────┐│ │ I&#x2F;O(pending) callbacks ││ └─────────────┬─────────────┘│ ┌─────────────┴─────────────┐│ │ idle, prepare ││ └─────────────┬─────────────┘ ┌───────────────┐│ ┌─────────────┴─────────────┐ │ incoming: ││ │ poll │&lt;─────┤ connections, ││ └─────────────┬─────────────┘ │ data, etc. ││ ┌─────────────┴─────────────┐ └───────────────┘│ │ check ││ └─────────────┬─────────────┘│ ┌─────────────┴─────────────┐└──┤ close callbacks │ └───────────────────────────┘ 注：模型中的每一个方块代表事件循环的一个阶段 事件循环各阶段详解从上面这个模型中，我们可以大致分析出node中的事件循环的顺序： 外部输入数据–&gt;轮询阶段(poll)–&gt;检查阶段(check)–&gt;关闭事件回调阶段(close callback)–&gt;定时器检测阶段(timer)–&gt;I/O事件回调阶段(I/O callbacks)–&gt;闲置阶段(idle, prepare)–&gt;轮询阶段… 以上各阶段的名称是根据我个人理解的翻译，为了避免错误和歧义，下面解释的时候会用英文来表示这些阶段。 这些阶段大致的功能如下： timers: 这个阶段执行定时器队列中的回调如 setTimeout() 和 setInterval()。 I/O callbacks: 这个阶段执行几乎所有的回调。但是不包括close事件，定时器和setImmediate()的回调。 idle, prepare: 这个阶段仅在内部使用，可以不必理会。 poll: 等待新的I/O事件，node在一些特殊情况下会阻塞在这里。 check: setImmediate()的回调会在这个阶段执行。 close callbacks: 例如socket.on(‘close’, …)这种close事件的回调。 下面我们来按照代码第一次进入libuv引擎后的顺序来详细解说这些阶段： poll阶段当v8引擎将js代码解析后传入libuv引擎后，循环首先进入poll阶段。poll阶段的执行逻辑如下： 先查看poll queue中是否有事件，有任务就按先进先出的顺序依次执行回调。 当queue为空时，会检查是否有setImmediate()的callback，如果有就进入check阶段执行这些callback。但同时也会检查是否有到期的timer，如果有，就把这些到期的timer的callback按照调用顺序放到timer queue中，之后循环会进入timer阶段执行queue中的 callback。 这两者的顺序是不固定的，收到代码运行的环境的影响。如果两者的queue都是空的，那么loop会在poll阶段停留，直到有一个i/o事件返回，循环会进入i/o callback阶段并立即执行这个事件的callback。 值得注意的是，poll阶段在执行poll queue中的回调时实际上不会无限的执行下去。有两种情况poll阶段会终止执行poll queue中的下一个回调： 1.所有回调执行完毕。 2.执行数超过了node的限制。 check阶段check阶段专门用来执行setImmediate()方法的回调，当poll阶段进入空闲状态，并且setImmediate queue中有callback时，事件循环进入这个阶段。 close阶段当一个socket连接或者一个handle被突然关闭时（例如调用了socket.destroy()方法），close事件会被发送到这个阶段执行回调。否则事件会用process.nextTick（）方法发送出去。 timer阶段这个阶段以先进先出的方式执行所有到期的timer加入timer队列里的callback，一个timer callback指得是一个通过setTimeout或者setInterval函数设置的回调函数。 I/O callback阶段如上文所言，这个阶段主要执行大部分I/O事件的回调，包括一些为操作系统执行的回调。例如一个TCP连接生错误时，系统需要执行回调来获得这个错误的报告。 process.nextTick,setTimeout与setImmediate的区别与使用场景在node中有三个常用的用来推迟任务执行的方法：process.nextTick,setTimeout（setInterval与之相同）与setImmediate 这三者间存在着一些非常不同的区别： process.nextTick()尽管没有提及，但是实际上node中存在着一个特殊的队列，即nextTick queue。这个队列中的回调执行虽然没有被表示为一个阶段，但是这些事件却会在每一个阶段执行完毕准备进入下一个阶段时优先执行。当事件循环准备进入下一个阶段之前，会先检查nextTick queue中是否有任务，如果有，那么会先清空这个队列。与执行poll queue中的任务不同的是，这个操作在队列清空前是不会停止的。这也就意味着，错误的使用process.nextTick()方法会导致node进入一个死循环，直到内存泄漏。 那么合适使用这个方法比较合适呢？下面有一个例子： 123const server &#x3D; net.createServer(() &#x3D;&gt; &#123;&#125;).listen(8080);server.on(&#39;listening&#39;, () &#x3D;&gt; &#123;&#125;); 这个例子中当，当listen方法被调用时，除非端口被占用，否则会立刻绑定在对应的端口上。这意味着此时这个端口可以立刻触发listening事件并执行其回调。然而，这时候on(‘listening)还没有将callback设置好，自然没有callback可以执行。为了避免出现这种情况，node会在listen事件中使用process.nextTick()方法，确保事件在回调函数绑定后被触发。 setTimeout()和setImmediate()在三个方法中，这两个方法最容易被弄混。实际上，某些情况下这两个方法的表现也非常相似。然而实际上，这两个方法的意义却大为不同。 setTimeout()方法是定义一个回调，并且希望这个回调在我们所指定的时间间隔后第一时间去执行。注意这个“第一时间执行”，这意味着，受到操作系统和当前执行任务的诸多影响，该回调并不会在我们预期的时间间隔后精准的执行。执行的时间存在一定的延迟和误差，这是不可避免的。node会在可以执行timer回调的第一时间去执行你所设定的任务。 setImmediate()方法从意义上将是立刻执行的意思，但是实际上它却是在一个固定的阶段才会执行回调，即poll阶段之后。有趣的是，这个名字的意义和之前提到过的process.nextTick()方法才是最匹配的。node的开发者们也清楚这两个方法的命名上存在一定的混淆，他们表示不会把这两个方法的名字调换过来—因为有大量的node程序使用着这两个方法，调换命名所带来的好处与它的影响相比不值一提。 setTimeout()和不设置时间间隔的setImmediate()表现上及其相似。猜猜下面这段代码的结果是什么？ 1234567setTimeout(() &#x3D;&gt; &#123; console.log(&#39;timeout&#39;);&#125;, 0);setImmediate(() &#x3D;&gt; &#123; console.log(&#39;immediate&#39;);&#125;); 实际上，答案是不一定。没错，就连node的开发者都无法准确的判断这两者的顺序谁前谁后。这取决于这段代码的运行环境。运行环境中的各种复杂的情况会导致在同步队列里两个方法的顺序随机决定。但是，在一种情况下可以准确判断两个方法回调的执行顺序，那就是在一个I/O事件的回调中。下面这段代码的顺序永远是固定的： 12345678910const fs &#x3D; require(&#39;fs&#39;);fs.readFile(__filename, () &#x3D;&gt; &#123; setTimeout(() &#x3D;&gt; &#123; console.log(&#39;timeout&#39;); &#125;, 0); setImmediate(() &#x3D;&gt; &#123; console.log(&#39;immediate&#39;); &#125;);&#125;); 答案永远是： 12immediatetimeout 因为在I/O事件的回调中，setImmediate方法的回调永远在timer的回调前执行。 参考： https://zhuanlan.zhihu.com/p/33058983 https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/#what-is-the-event-loop","categories":[{"name":"JS高级","slug":"JS高级","permalink":"http://yoursite.com/categories/JS%E9%AB%98%E7%BA%A7/"}],"tags":[{"name":"JS高级","slug":"JS高级","permalink":"http://yoursite.com/tags/JS%E9%AB%98%E7%BA%A7/"}]},{"title":"JavaScriptWindowLocation","slug":"03-JavaScriptWindowLocation","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T03:39:14.000Z","comments":true,"path":"2020/04/18/03-JavaScriptWindowLocation/","link":"","permalink":"http://yoursite.com/2020/04/18/03-JavaScriptWindowLocation/","excerpt":"","text":"前言window.location 对象可用于获取当前页面地址（URL）并把浏览器重定向到新页面。 Window Location window.location 对象可不带 window 前缀书写。 一些例子： window.location.href 返回当前页面的 href (URL) window.location.hostname 返回 web 主机的域名 window.location.pathname 返回当前页面的路径或文件名 window.location.protocol 返回使用的 web 协议（http: 或 https:） window.location.assign 加载新文档","categories":[{"name":"BOM","slug":"BOM","permalink":"http://yoursite.com/categories/BOM/"}],"tags":[{"name":"BOM","slug":"BOM","permalink":"http://yoursite.com/tags/BOM/"}]},{"title":"变量","slug":"02-变量","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:43:44.000Z","comments":true,"path":"2020/04/18/02-变量/","link":"","permalink":"http://yoursite.com/2020/04/18/02-%E5%8F%98%E9%87%8F/","excerpt":"字面量：数字和字符串“字面量”即常量，是固定值，不可改变。看见什么，它就是什么。 字面量有3种： 数字 字符串 布尔字面量","text":"字面量：数字和字符串“字面量”即常量，是固定值，不可改变。看见什么，它就是什么。 字面量有3种： 数字 字符串 布尔字面量 （1）数值的字面量非常简单，写上去就行了，不需要任何的符号。例如： 1alert(886); //886是数字，所以不需要加引号。 （2）字符串的字面量也很简单，但一定要加上引号。可以是单词、句子等。例如： 123console.log('886');console.log('hello'); 温馨提示：100是数字，”100”是字符串。 （3）布尔字面量举例： 123if (true) &#123; console.log('如果为真，就走这里面的代码);&#125; 总结字面量都可以直接使用，但是我们一般不会直接使用字面量。 如果直接使用字面量的话，比较麻烦。比如说，多个地方要用到同一个字面量，还不如事先定义一个变量，用来保存字面量。 变量更方便我们使用，所以在开发中都是通过变量去保存一个字面量，而不会直接使用字面量。 变量的概念变量：是用于存放数据的容器。我们通过「变量名」获取数据，甚至可以修改数据。 变量还可以用来保存字面量。 本质：变量是程序在内存中申请的一块用来存放数据的空间。 变量的声明和赋值变量的声明（变量的定义）在ES6语法之前，统一使用var关键字来声明一个变量。比如： 1var name; // 生命一个名为 name 的变量 补充：在ES6语法及之后，统一使用 const、let关键字来声明一个变量。 变量的赋值变量的赋值： 1name= 'Edward' 变量的声明和赋值，举例如下： 1234var a = 100; // ES5语法const b = hello; // ES6 语法let b = world; // ES6 语法 var是英语“variant”变量的缩写。后面要加一个空格，空格后面的东西就是“变量名”： 定义变量：var就是一个关键字，用来定义变量。所谓关键字，就是有特殊功能的单词。 变量的赋值：等号表示赋值，将等号右边的值，赋给左边的变量。 变量名：我们可以给变量任意的取名字。 PS：在JavaScript中，永远都是用var来定义变量（在ES6 之前），这和C、Java等语言不同。 变量的初始化有经验的程序员，会把声明和赋值写在一起： 12var a = 100; //声明，并且赋值100console.log(a); //输出100 声明一个变量并赋值， 我们称之为变量的初始化。 变量声明和赋值的补充修改变量的值一个变量被重新复赋值后，它原有的值就会被覆盖，变量值将以最后一次赋的值为准。 举例： 1234var a = 100;a = 110;console.log(a); // 打印结果：110。因为 110 覆盖了 100 同时声明多个变量同时声明多个变量时，只需要写一个 var， 多个变量名之间用英文逗号隔开。 举例： 1var name = '千古壹号', age = 27, number = 100; 变量声明的几种特殊情况变量建议先声明，再使用。否则可能会报错。具体如下。 写法1、先声明，再赋值：（正常） 123var a;a = 100;console.log(a); // 打印结果：100 写法2、不声明，只赋值：（正常） 12a = 100;console.log(a); // 打印结果：100 写法3、只声明，不赋值：（注意，打印 undefined） 12var a;console.log(a); // 打印结果：undefined 写法4、不声明，不赋值，直接使用：（会报错） 1console.log(a); // 会报错 补充：写法1和写法2虽然都正常，但这两种写法是有区别的，等以后学习了「变量提升」的概念就明白了。大多数情况下，我们都是采用的写法1。 变量的命名规范大写字母是可以使用的，并且大小写敏感。也就是说A和a是两个变量。 12var A = 250; //变量1var a = 888; //变量2 我们来整理一下变量的命名规范： 只能由字母(A-Z、a-z)、数字(0-9)、下划线(_)、美元符( $ )组成 不能以数字开头。也就是说，必须以字母(A-Z、a-z)、下划线(_)或者美元符( $ )开头。变量名中不允许出现空格。 不用使用 JS 语言中保留的「关键字」和「保留字」作为变量名。 建议用驼峰命名规则。比如getElementById、matherAndFather、aaaOrBbbAndCcc 变量名会区分大小写(javascript 是区分大小写的语言)。 变量名长度不能超过255个字符。 汉语可以作为变量名。但是不建议使用。 标识符、关键字、保留字标识符标识符：在JS中所有的可以由我们自主命名的都可以称之为标识符。 例如：变量名、函数名、属性名、参数名都是属于标识符。通俗来讲，标识符就是我们写代码时为它们起的名字。 标识符的命名规则和变量的命令规则是一样的。看上面一段就可以了。 同样，标识符不能使用语言中保留的关键字及保留字。如下。 关键字关键字：是指 JS 本身已经使用了的单词，不能再用它们充当变量、函数名等标识符。 JS 中的关键字如下： 1234567891011break、continue、case、default、if、else、switch、for、in、do、while、try、catch、finally、throw、var、void、function、return、new、this、typeof、instanceof、delete、with、true、false、null、undefined 保留字保留字：实际上就是预留的“关键字”。意思是现在虽然还不是关键字，但是未来可能会成为关键字，同样不能使用它们当充当变量名、函数名等标识符。 JS 中的保留字如下： 123456789abstract、boolean、byte、char、class、const、debugger、double、enum、export、extends、final、float、gotoimplements、import、int、interface、long、native、package、private、protected、public、short、static、super、synchronized、throws、transient、volatile 举例举例1：交换两个变量的值 代码实现： 12345678var a1 = 100;var a2 = 200;var temp;temp = a1;a1 = a2;a2 = temp;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"CSS样式表和选择器","slug":"03-CSS样式表和选择器","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:45:18.000Z","comments":true,"path":"2020/04/18/03-CSS样式表和选择器/","link":"","permalink":"http://yoursite.com/2020/04/18/03-CSS%E6%A0%B7%E5%BC%8F%E8%A1%A8%E5%92%8C%E9%80%89%E6%8B%A9%E5%99%A8/","excerpt":"本文主要内容 CSS应用的三种方式：行内样式表、内嵌样式表、外部样式表 CSS四种基本选择器：标签选择器、类选择器、ID选择器、通用选择器 CSS几种扩展选择器：后代选择器、交集选择器、并集选择器 CSS样式优先级","text":"本文主要内容 CSS应用的三种方式：行内样式表、内嵌样式表、外部样式表 CSS四种基本选择器：标签选择器、类选择器、ID选择器、通用选择器 CSS几种扩展选择器：后代选择器、交集选择器、并集选择器 CSS样式优先级 CSS的重点知识点盒子模型、浮动、定位 css对换行不敏感，对空格也不敏感。但是一定要有标准的语法。冒号，分号都不能省略。 CSS语法语法格式：（其实就是键值对） 1234选择器&#123; 属性名: 属性值; 属性名: 属性值;&#125; 或者可以写成： 123456789101112选择器&#123; k:v; k:v; k:v; k:v;&#125;选择器&#123; k:v; k:v; k:v; k:v;&#125; 解释： 选择器代表页面上的某类元素，选择器后一定是大括号。 属性名后必须用冒号隔开，属性值后用分号（最后一个属性可以不用分号）。 属性名和冒号之间最好不要有空格（经验）。 如果一个属性有多个值的话，那么多个值用 空格 隔开 CSS有两个知识部分：1） 选择器；2） 属性. CSS使用方式（样式表）CSS和HTML结合的方式，其实就是问你css的代码放在哪里比较合适。CSS代码理论上的位置是任意的，但通常写在&lt;style&gt;标签里。只要是&lt;style&gt;标签里的代码，那就是css代码，浏览器就是这样来进行解析的。 CSS和HTML的结合方式有3种： 行内样式：在某个特定的标签里采用style属性。范围只针对此标签。 内嵌样式表：在页面的head里采用&lt;style&gt;标签。范围针对此页面。 引入外部样式表css文件的方式。这种引入方式又分为两种： 1、采用&lt;link&gt;标签。例如：&lt;link rel = &quot;stylesheet&quot; type = &quot;text/css&quot; href = &quot;a.css&quot;&gt;&lt;/link&gt; 2、采用import，必须写在&lt;style&gt;标签中，并且必须是第一句。例如：@import url(a.css) ; 两种引入样式方式的区别：外部样式表中不能写&lt;link&gt;标签，但是可以写import语句。 下面来详细的讲一讲这三种方式。 1、CSS和HTML结合方式一：行内样式采用style属性。范围只针对此标签适用。 该方式比较灵活，但是对于多个相同标签的同一样式定义比较麻烦，适合局部修改。 举例： 1&lt;p style=\"color:white;background-color:red\"&gt;我不会就这样轻易的狗带&lt;/p&gt; 效果： 2、CSS和HTML结合方式二：内嵌样式表在head标签中加入&lt;style&gt;标签，对多个标签进行统一修改，范围针对此页面。 该方式可以对单个页面的样式进行统一设置，但对于局部不够灵活。 举例： 12345678910111213&lt;style type=\"text/css\"&gt; p&#123; font-weight: bold; font-style: italic; color: red; &#125;&lt;/style&gt; &lt;body&gt; &lt;p&gt;hello world&lt;/p&gt; &lt;p style=\"color:blue\"&gt;hello world&lt;/p&gt; &lt;/body&gt; 3、CSS和HTML结合方式三：引入外部样式表css文件引入样式表文件的方式又分为两种： （1）采用&lt;link&gt;标签。例如：&lt;link rel = &quot;stylesheet&quot; type = &quot;text/css&quot; href = &quot;a.css&quot;&gt;&lt;/link&gt; （2）采用import，必须写在&lt;style&gt;标签中，并且必须是第一句。例如：@import url(a.css) ; 两种引入样式方式的区别： @import是 CSS 提供的语法规则，只有导入样式表的作用；link是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等; 加载页面时，link标签引入的 CSS 被同时加载；@import引入的 CSS 将在页面加载完毕后被加载; @import是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link标签作为 HTML 元素，不存在兼容性问题。 CSS的四种基本选择器CSS选择器：就是指定CSS要作用的标签，那个标签的名称就是选择器。意为：选择哪个容器。 CSS的选择器分为两大类：基本选择题和扩展选择器。 基本选择器： 标签选择器：针对一类标签 ID选择器：针对某一个特定的标签使用 类选择器：针对你想要的所有标签使用 通用选择器（通配符）：针对所有的标签都适用（不建议使用） 下面来分别讲一讲。 1、标签选择器：选择器的名字代表html页面上的标签标签选择器，选择的是页面上所有这种类型的标签，所以经常描述“共性”，无法描述某一个元素的“个性”。 举例： 123p&#123; font-size:14px;&#125; 上方选择器的意思是说：所有的&lt;p&gt;标签里的内容都将显示14号字体。 【总结】需要注意的是： （1）所有的标签，都可以是选择器。比如ul、li、label、dt、dl、input。 （2）无论这个标签藏的多深，一定能够被选择上。 （3）选择的所有，而不是一个。 2、ID选择器：规定用#来定义针对某一个特定的标签来使用，只能使用一次。css中的ID选择器以”#”来定义。 举例： 123#mytitle&#123; border:3px dashed green;&#125; id选择器的选择符是“#”。 任何的HTML标签都可以有id属性。表示这个标签的名字。这个标签的名字，可以任取，但是： （1）只能有字母、数字、下划线。 （2）必须以字母开头。 （3）不能和标签同名。比如id不能叫做body、img、a。 另外，特别强调的是：HTML页面，不能出现相同的id，哪怕他们不是一个类型。比如页面上有一个id为pp的p，一个id为pp的div，是非法的！ 一个标签可以被多个css选择器选择： 3、类选择器：规定用圆点.来定义针对你想要的所有标签使用。优点：灵活。 css中用.来表示类。举例如下： 123.one&#123; width:800px;&#125; 和id非常相似，任何的标签都可以携带id属性和class属性。class属性的特点： 特性1：类选择器可以被多种标签使用。 特性2：同一个标签可以使用多个类选择器。用空格隔开。举例如下：（正确） 1&lt;h3 class=\"teshu zhongyao\"&gt;我是一个h3啊&lt;/h3&gt; 类选择器使用的举例： 类选择器的使用，能够决定一个人的css水平。 （1）不要去试图用一个类名，把某个标签的所有样式写完。这个标签要多携带几个类，共同完成这个标签的样式。 （2）每一个类要尽可能小，有“公共”的概念，能够让更多的标签使用。 问题：到底用id还是用class？ 答案：尽可能的用class，除非极特殊的情况可以用id。 原因：id是js用的。也就是说，js要通过id属性得到标签，所以css层面尽量不用id，要不然js就很别扭。另一层面，我们会认为一个有id的元素，有动态效果。 上面这三种选择器的区别： 标签选择器针对的是页面上的一类标签。 ID选择器是只针对特定的标签(一个)，ID是此标签在此页面上的唯一标识。 类选择器可以被多种标签使用。 4、通配符*：匹配任何标签通用选择器，将匹配任何标签。不建议使用，IE有些版本不支持，大网站增加客户端负担。 效率不高，如果页面上的标签越多，效率越低，所以页面上不能出现这个选择器。 举例： 1234*&#123; margin-left:0px; margin-top:0px;&#125; CSS的几种高级选择器高级选择器： 后代选择器：用空格隔开 交集选择器：选择器之间紧密相连 并集选择器（分组选择器）：用逗号隔开 伪类选择器 下面详细讲一下这几种高级（扩展）选择器。 1、后代选择器: 定义的时候用空格隔开对于E F这种格式，表示所有属于E元素后代的F元素，有这个样式。空格就表示后代。 后代选择器，就是一种平衡：共性、特性的平衡。当要把某一个部分的所有的什么，进行样式改变，就要想到后代选择器。 后代选择器，描述的是祖先结构。 空格就表示后代。.div1 p 表示.div1的后代所有的p。 这里强调一下：这两个标签不一定是连续紧挨着的，只要保持一个后代的关联即可。也就是说，选择的是后代，不一定是儿子。 2、交集选择器：定义的时候紧密相连定义交集选择器的时候，两个选择器之间紧密相连。一般是以标签名开头，比如div.haha，再比如p.special。 如果后一个选择器是类选择器，则写为div.special；如果后一个选择器id选择器，则写为div#special。 123h3.special&#123; color:red;&#125; 选择的元素要求同时满足两个条件：必须是h3标签，然后必须是special标签。 注意，交集选择器没有空格。所以，没有空格的div.red（交集选择器）和有空格的div .red（后代选择器）不是一个意思。 交集选择器可以连续交：（一般不要这么写） 123h3.special.zhongyao&#123; color:red;&#125; 上面这种写法，是 IE7 开始兼容的，IE6 不兼容。 3、并集选择器：定义的时候用逗号隔开三种基本选择器都可以放进来。 举例： 123p,h1,#mytitle,.one&#123; color:red;&#125; 浏览器的兼容性问题1.子代选择器，用符号&gt;表示 IE7开始兼容，IE6不兼容。 123div&gt;p&#123; color:red;&#125; div的儿子p。和div的后代p的截然不同。 能够选择： 123&lt;div&gt; &lt;p&gt;我是div的儿子&lt;/p&gt;&lt;/div&gt; 不能选择： 1234567&lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;我是div的重孙子&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 2.序选择器 IE8开始兼容；IE6、7都不兼容 设置无序列表&lt;ul&gt;中的第一个&lt;li&gt;为红色： 12345&lt;style type=\"text/css\"&gt; ul li:first-child&#123; color:red; &#125;&lt;/style&gt; 设置无序列表&lt;ul&gt;中的最后一个&lt;li&gt;为红色： 123ul li:last-child&#123; color:blue;&#125; 。 由于浏览器的更新需要过程，所以现在如果公司还要求兼容IE6、7，那么就要自己写类名： 123456789101112&lt;ul&gt; &lt;li class=\"first\"&gt;项目&lt;/li&gt; &lt;li&gt;项目&lt;/li&gt; &lt;li&gt;项目&lt;/li&gt; &lt;li&gt;项目&lt;/li&gt; &lt;li&gt;项目&lt;/li&gt; &lt;li&gt;项目&lt;/li&gt; &lt;li&gt;项目&lt;/li&gt; &lt;li&gt;项目&lt;/li&gt; &lt;li&gt;项目&lt;/li&gt; &lt;li class=\"last\"&gt;项目&lt;/li&gt;&lt;/ul&gt; 用类选择器来选择第一个或者最后一个： 1234567ul li.first&#123; color:red;&#125;ul li.last&#123; color:blue;&#125; 3.下一个兄弟选择器 IE7开始兼容，IE6不兼容。 +表示选择下一个兄弟 12345&lt;style type=\"text/css\"&gt; h3+p&#123; color:red; &#125;&lt;/style&gt; 上方的选择器意思是：选择的是h3元素后面紧挨着的第一个兄弟。 这种选择器作用不大。","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"let和const","slug":"03-let和const","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:45:08.000Z","comments":true,"path":"2020/04/18/03-let和const/","link":"","permalink":"http://yoursite.com/2020/04/18/03-let%E5%92%8Cconst/","excerpt":"let命令基本用法ES6新增了let命令，用来声明变量，类似于var，但是所声明的变量，只在let命令所在的代码块有效。 1234567&#123; let a &#x3D; 10; var b &#x3D; 1;&#125;a &#x2F;&#x2F; ReferenceError: a is not defined.b &#x2F;&#x2F; 1","text":"let命令基本用法ES6新增了let命令，用来声明变量，类似于var，但是所声明的变量，只在let命令所在的代码块有效。 1234567&#123; let a &#x3D; 10; var b &#x3D; 1;&#125;a &#x2F;&#x2F; ReferenceError: a is not defined.b &#x2F;&#x2F; 1 上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。 不存在变量提升var命令会发生“变量提升”现象，即变量可以在声明前使用，值为undefined。 let声明的变量一定要在声明后使用，否则报错。 1234567&#x2F;&#x2F; var 的情况console.log(foo); &#x2F;&#x2F; 输出undefinedvar foo &#x3D; 2;&#x2F;&#x2F; let 的情况console.log(bar); &#x2F;&#x2F; 报错ReferenceErrorlet bar &#x3D; 2; 暂时性死区只要块级作用域内存在let命令，它所声明的变量就会绑定在这个区域，不再受外部的影响。 123456var tmp &#x3D; 123;if (true) &#123; tmp &#x3D; &#39;abc&#39;; &#x2F;&#x2F; ReferenceError let tmp;&#125; 上述代码，存在全局变量tmp，但是块级作用域又声明了一个局部变量tmp，导致后者绑定在这个块级作用域，所以在let声明这个变量前会报错。 ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为暂时性死区（temporal dead zone，简称TDZ）。 暂时性死区意味着typeof不再是一个百分之百安全的操作 12345typeof x; &#x2F;&#x2F; ReferenceErrorlet x;let x &#x3D; x; 上面代码中，变量x使用let命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，typeof运行时就会抛出一个ReferenceError。 作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。 typeof undeclared_variable // &quot;undefined&quot; ES6规定暂时性死区以及let和const不出现变量提升，主要是为了减少运行时的错误，防止在变量声明前就使用这个变量。 不允许重复声明let不允许在相同作用域内，重复声明同一个变量。 块级作用域为什么要有块级作用域？ ES5只有全局作用域和函数作用域。 12345678910var tmp &#x3D; new Date();function f() &#123; console.log(tmp); if (false) &#123; var tmp &#x3D; &#39;hello world&#39;; &#125;&#125;f(); &#x2F;&#x2F; undefined 上面代码的原意是，if代码块的外部使用外层的tmp变量，内部使用内层的tmp变量。但是，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。 第二种场景，用来计数的循环变量泄露为全局变量。 1234567var s &#x3D; &#39;hello&#39;;for (var i &#x3D; 0; i &lt; s.length; i++) &#123; console.log(s[i]);&#125;console.log(i); &#x2F;&#x2F; 5 上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。 ES6的块级作用域let实际上为JavaScript新增了块级作用域。 1234567function f1() &#123; let n &#x3D; 5; if (true) &#123; let n &#x3D; 10; &#125; console.log(n); &#x2F;&#x2F; 5&#125; 上面的函数有两个代码块，都声明了变量n，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是 10。 ES6允许块级作用域的任意嵌套。 内层作用域可以定义外层作用域的同名变量。 块级作用域与函数声明 允许在块级作用域内声明函数 函数声明类似于var，即会提升到全局作用域或函数作用域的头 同时，函数声明还会提升到所在的块级作用域的头部 注意：应该避免在块级作用域内声明函数ES6的块级作用域必须有{}，如果没有大括号，JavaScript引擎就认为不存在块级作用域。 const命令基本用法const声明一个只读的常量，不得改变值。 const的作用域与let相同：只在声明所在的块级作用域内有效。 const的作用域与let命令相同：只在声明所在的块级作用域内有效。 本质： const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。 对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。 ES6声明对象的六种方式： ES5 只有两种声明变量的方法：var命令和function命令。ES6 除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有 6 种声明变量的方法。 顶层对象的属性顶层对象，在浏览器中指的是window对象，在Node中指的是global对象。ES5之中，顶层对象的属性与全局变量是等价的。 ES6为了改变这一点，为了保持兼容性，规定，var和function声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令和const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从SE6开始，全局变量将逐步与顶层对象的属性脱钩。 1234567var a &#x3D; 1;&#x2F;&#x2F; 如果在 Node 的 REPL 环境，可以写成 global.a&#x2F;&#x2F; 或者采用通用方法，写成 this.awindow.a &#x2F;&#x2F; 1let b &#x3D; 1;window.b &#x2F;&#x2F; undefined 上面代码中，全局变量a由var命令声明，所以它是顶层对象的属性；全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined。 globalThis对象JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。 浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。 浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。 Node 里面，顶层对象是global，但其他环境都不支持。 同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。 全局环境中，this会返回顶层对象。但是，Node 模块和 ES6 模块中，this返回的是当前模块。 函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。 不管是严格模式，还是普通模式，new Function(&#39;return this&#39;)()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么eval、new Function这些方法都可能无法使用。 ES2020 在语言标准的层面，引入globalThis作为顶层对象。也就是说，任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。 垫片库global-this模拟了这个提案，可以在所有环境拿到globalThis。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"变量的数据类型","slug":"03-变量的数据类型","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:45:32.000Z","comments":true,"path":"2020/04/18/03-变量的数据类型/","link":"","permalink":"http://yoursite.com/2020/04/18/03-%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"变量的数据类型为什么需要数据类型在计算机中，不同的数据所需占用的存储空间不同，为了充分利用存储空间，于是定义了不同的数据类型。而且，不同的数据类型，寓意也不同。 我们都知道，无论这个变量是字符串类型，还是数字类型，我们都可以直接用 var 去定义它。比如：","text":"变量的数据类型为什么需要数据类型在计算机中，不同的数据所需占用的存储空间不同，为了充分利用存储空间，于是定义了不同的数据类型。而且，不同的数据类型，寓意也不同。 我们都知道，无论这个变量是字符串类型，还是数字类型，我们都可以直接用 var 去定义它。比如： 123var a = 'hello word';var b = 123; 为什么可以这样做呢？这是因为：JavaScript 是一种「弱类型语言」，或者说是一种「动态语言」，这意味着不需要提前声明变量的类型，在程序运行过程中，类型会自动被确定。 JS 的变量数据类型，是在程序运行的过程中，根据等号右边的值来确定的。而且，变量的数据类型是可以变化的。比如说： 123var name = 'qianguyihao';name = 123; // 强制将变量 name 修改为 数字类型 JS中一共有六种数据类型 基本数据类型（值类型）：String 字符串、Number 数值、Boolean 布尔值、Null 空值、Undefined 未定义、Symbol。 引用数据类型（引用类型）：Object 对象。 注意：内置对象 Function、Array、Date、RegExp、Error等都是属于 Object 类型。也就是说，除了那五种基本数据类型之外，其他的，都称之为 Object类型。 面试问：引用数据类型有几种？ 面试答：只有一种，即 Object 类型。 数据类型之间最大的区别： 基本数据类型：参数赋值的时候，传数值。 引用数据类型：参数赋值的时候，传地址（修改的同一片内存空间）。 String 字符串语法字符串型可以是引号中的任意文本，其语法为：双引号 &quot;&quot; 或者单引号 &#39;&#39;。 来看个示例。下面的这些，都是字符串： 12345678910111213var a = \"abcde\";var b = \"千古壹号\";var c = \"123123\";var d = '哈哈哈哈哈';var e = \"\"; //空字符串var f = haha; // 没使用引号，到这里会直接报错。因为会被认为是js代码，但是之前并没有定义 haha。console.log(typeof a);console.log(typeof b);console.log(typeof c);console.log(typeof d);console.log(typeof e); 控制台输出如下： 12345stringstringstringstringstring 引号的注意事项1、单引号和双引号不能混用。比如下面这样写是不可以的： 1var str = 'hello\"; // 报错：Uncaught SyntaxError: Invalid or unexpected token 2、同类引号不能嵌套：双引号里不能再放双引号，单引号里不能再放单引号。 3、单引号里可以嵌套双引号；双引号里可以嵌套单引号。 转义字符在字符串中我们可以使用\\作为转义字符，当表示一些特殊符号时可以使用\\进行转义。 \\&quot; 表示 &quot; \\&#39; 表示 &#39; \\\\ 表示\\ \\r 表示回车 \\n 表示换行。n 的意思是 newline。 \\t 表示缩进。t 的意思是 tab。 \\b 表示空格。b 的意思是 blank。 举例： 12345var str1 = \"我说:\\\"今天\\t天气真不错！\\\"\";var str2 = \"\\\\\\\\\\\\\";console.log(str1);console.log(str2); 上方代码的打印结果： 12我说:&quot;今天 天气真不错！&quot;\\\\\\ 获取字符串的长度字符串是由若干个字符组成的，这些字符的数量就是字符串的长度。我们可以通过字符串的 length 属性可以获取整个字符串的长度。 代码举例： 12345678910var str1 = '千古壹号';var str2 = '千古壹号，永不止步！';var str3 = 'qianguyihao';var str4 = 'qianguyihao, keep moving!';console.log(str1.length); // 4console.log(str2.length); // 10console.log(str3.length); // 11console.log(str4.length); // 25 由此可见，字符串的 length 属性，在判断字符串的长度时，会认为： 一个中文算一个字符，一个英文算一个字符 一个标点符号（包括中文标点、英文标点）算一个字符 一个空格算一个字符 字符串拼接多个字符串之间可以使用加号 + 进行拼接。 拼接语法： 1字符串 + 任意数据类型 &#x3D; 拼接之后的新字符串; 拼接规则：拼接前，会把与字符串相加的这个数据类型转成字符串，然后再拼接成一个新的字符串。 代码举例：（字符串与六大数据类型相加） 123456789101112131415var str1 = '千古壹号' + '永不止步';var str2 = '千古壹号' + 666;var str3 = '千古壹号' + true;var str4 = '千古壹号' + null;var str5 = '千古壹号' + undefined;var obj = &#123; name: '千古壹号', age: 28 &#125;;var str6 = '千古壹号' + obj;console.log(str1);console.log(str2);console.log(str3);console.log(str4);console.log(str5);console.log(str6); 打印结果： 1234567891011千古壹号永不止步千古壹号666千古壹号true千古壹号null千古壹号undefined千古壹号[object Object] 数值型：Number在JS中所有的数值都是 Number 类型，包括整数和浮点数（小数）。 12345var a = 100; // 定义一个变量 a，并且赋值整数100console.log(typeof a); // 输出变量 a 的类型var b = 12.3; // 定义一个变量 b，并且赋值浮点数 12.3console.log(typeof a); 上方代码的输出结果为： 123numbernumber 再次补充：在 JS 中，只要是数，就是 Number 数值型的。无论整浮、浮点数（即小数）、无论大小、无论正负，都是 Number 类型的。 数值范围由于内存的限制，ECMAScript 并不能保存世界上所有的数值。 最大值：Number.MAX_VALUE，这个值为： 1.7976931348623157e+308 最小值：Number.MIN_VALUE，这个值为： 5e-324 如果使用 Number 表示的变量超过了最大值，则会返回Infinity。 无穷大（正无穷）：Infinity 无穷小（负无穷）：-Infinity 注意：typeof Infinity的返回结果是number。 NaNNaN：是一个特殊的数字，表示Not a Number，非数值。比如： 123console.log(\"abc\" / 18); //结果是NaNconsole.log(\"abc\" * \"abcd\"); //按理说，字符串相乘是没有结果的，但如果你非要让JS去算，它就一定会给你一个结果。结果是NaN 注意：typeof NaN的返回结果是 number。 Undefined和任何数值计算的结果为 NaN。NaN 与任何值都不相等，包括 NaN 本身。 另外，关于 isNaN() 函数，可以看下一篇文章。 浮点数的运算在JS中，整数的运算基本可以保证精确；但是小数的运算，可能会得到一个不精确的结果。所以，千万不要使用JS进行对精确度要求比较高的运算。 如下： 12var a = 0.1 + 0.2;console.log(a); //打印结果：0.30000000000000004 上方代码中，打印结果并不是0.3，而是0.30000000000000004。 我们知道，所有的运算都要转换成二进制去计算，然而，二进制是无法精确表示1/10的。因此存在小数的计算不精确的问题。 连字符和加号的区别键盘上的+可能是连字符，也可能是数字的加号。如下： 123console.log(&quot;我&quot; + &quot;爱&quot; + &quot;你&quot;); &#x2F;&#x2F;连字符，把三个独立的汉字，连接在一起了console.log(&quot;我+爱+你&quot;); &#x2F;&#x2F;原样输出console.log(1+2+3); &#x2F;&#x2F;输出6 输出： 123我爱你我+爱+你6 总结：如果加号两边都是数值，此时是加。否则，就是连字符（用来连接字符串）。 举例1： 123var a = \"1\";var b = 2;console.log(a + b); 控制台输出： 112 举例2： 123var a &#x3D; 1;var b &#x3D; 2;console.log(&quot;a&quot; + b); &#x2F;&#x2F;&quot;a&quot;就不是变量了！所以就是&quot;a&quot;+2 输出a2 控制台输出： 1a2 于是我们明白了，在变量中加入字符串进行拼接，可以被同化为字符串。【重要】 隐式转换我们知道，&quot;2&quot;+1得到的结果其实是字符串，但是&quot;2&quot;-1得到的结果却是数值1，这是因为计算机自动帮我们进行了“隐式转换”。 也就是说，-、*、/、%这几个符号会自动进行隐式转换。例如： 12var a = \"4\" + 3 - 6;console.log(a); 输出结果： 137 虽然程序可以对-、*、/、`%``这几个符号自动进行“隐式转换”；但作为程序员，我们最好自己完成转换，方便程序的可读性。 布尔值：Boolean布尔型有两个值：true 和 false。主要用来做逻辑判断： true 表示真，false 表示假。 布尔值直接使用就可以了，千万不要加上引号。 代码： 12var a = true;console.log(typeof a); 控制台输出结果： 1boolean 布尔型和数字型相加时， true 按 1 来算 ，false 按 0 来算。 Null 和 Undefinednull：空值专门用来表示一个为空的对象（例如：var a = null）。注意，专门用来表示空对象。 Null类型的值只有一个，就是null。比如 var a = null。 使用 typeof 检查一个null值时，会返回object。 undefined：未定义声明了一个变量，但是没有赋值（例如：var a;），此时它的值就是 undefined。 Undefined类型的值只有一个，就是undefind。比如 使用 type of 检查一个undefined时，会返回undefined。 null和undefined有很大的相似性。看看null == undefined的结果(true)也就更加能说明这点。 但是null === undefined的结果(false)。它们虽然相似，但还是有区别的，其中一个区别是：和数字运算时，10 + null结果为：10；10 + undefined结果为：NaN。 任何数据类型和undefined运算都是NaN; 任何值和null运算，null可看做0运算。 SymbolSymbol 是 ES6 引入了一个新的数据类型。 symbol 是一种基本数据类型 （primitive data type）。Symbol()函数会返回symbol类型的值，该类型具有静态属性和静态方法。它的静态属性会暴露几个内建的成员对象；它的静态方法会暴露全局的symbol注册，且类似于内建对象类，但作为构造函数来说它并不完整，因为它不支持语法：”new Symbol()”。 每个从Symbol()返回的symbol值都是唯一的。一个symbol值能作为对象属性的标识符；这是该数据类型仅有的目的。 变量值的传递（赋值）语句： 1a &#x3D; b; 把b的值赋给a，b不变。 将等号右边的值，赋给左边的变量；等号右边的变量，值不变。 来做几个题目。 举例1： 12345678910 &#x2F;&#x2F;a b cvar a &#x3D; 1; &#x2F;&#x2F;1var b &#x3D; 2; &#x2F;&#x2F;1 2var c &#x3D; 3; &#x2F;&#x2F;1 2 3a &#x3D; b + c; &#x2F;&#x2F;5 2 3b &#x3D; c - a; &#x2F;&#x2F;5 -2 3c &#x3D; a * b; &#x2F;&#x2F;5 -2 -10console.log(a);console.log(b);console.log(c); 输出： 1235-2-10 举例2： 12345678910 &#x2F;&#x2F;a b cvar a &#x3D; 1;var b &#x3D; 2;var c &#x3D; 3; &#x2F;&#x2F;1 2 3a &#x3D; a + b; &#x2F;&#x2F;3 2 3b &#x3D; b + a; &#x2F;&#x2F;3 5 3c &#x3D; c + b; &#x2F;&#x2F;3 5 8console.log(a); &#x2F;&#x2F;3console.log(b); &#x2F;&#x2F;5console.log(c); &#x2F;&#x2F;8 输出： 123358 举例3： 1234567 &#x2F;&#x2F;a bvar a &#x3D; &quot;1&quot;;var b &#x3D; 2; &#x2F;&#x2F;&quot;1&quot; 2a &#x3D; a + b; &#x2F;&#x2F;&quot;12&quot; 2b &#x3D; b + a; &#x2F;&#x2F;&quot;12&quot; &quot;212&quot;console.log(a); &#x2F;&#x2F;输出12console.log(b); &#x2F;&#x2F;输出212 输出： 1212212 举例4： 1234567 &#x2F;&#x2F;a bvar a &#x3D; &quot;1&quot;;var b &#x3D; 2;a &#x3D; b + a; &#x2F;&#x2F;&quot;21&quot; 2b &#x3D; b + a; &#x2F;&#x2F;&quot;21&quot; &quot;221&quot;console.log(a); &#x2F;&#x2F;21console.log(b) &#x2F;&#x2F;221 效果： 1221221 举例5：（这个例子比较特殊，字符串减去数字） 123var a &#x3D; &quot;3&quot;;var b &#x3D; 2;console.log(a-b); 效果：（注意，字符串 - 数值 = 数值） 11","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"CSS选择器：伪类","slug":"04-CSS选择器：伪类","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:46:44.000Z","comments":true,"path":"2020/04/18/04-CSS选择器：伪类/","link":"","permalink":"http://yoursite.com/2020/04/18/04-CSS%E9%80%89%E6%8B%A9%E5%99%A8%EF%BC%9A%E4%BC%AA%E7%B1%BB/","excerpt":"伪类（伪类选择器）伪类：同一个标签，根据其不同的种状态，有不同的样式。这就叫做“伪类”。伪类用冒号来表示。 比如div是属于box类，这一点很明确，就是属于box类。但是a属于什么类？不明确。因为需要看用户点击前是什么状态，点击后是什么状态。所以，就叫做“伪类”。","text":"伪类（伪类选择器）伪类：同一个标签，根据其不同的种状态，有不同的样式。这就叫做“伪类”。伪类用冒号来表示。 比如div是属于box类，这一点很明确，就是属于box类。但是a属于什么类？不明确。因为需要看用户点击前是什么状态，点击后是什么状态。所以，就叫做“伪类”。 静态伪类和动态伪类伪类选择器分为两种。 （1）静态伪类：只能用于超链接的样式。如下： :link 超链接点击之前 :visited 链接被访问过之后 PS：以上两种样式，只能用于超链接。 （2）动态伪类：针对所有标签都适用的样式。如下： :hover “悬停”：鼠标放到标签上的时候 :active “激活”： 鼠标点击标签，但是不松手时。 :focus 是某个标签获得焦点时的样式（比如某个输入框获得焦点） 超链接a标签超链接的四种状态a标签有4种伪类（即对应四种状态）。如下： :link “链接”：超链接点击之前 :visited “访问过的”：链接被访问过之后 :hover “悬停”：鼠标放到标签上的时候 :active “激活”： 鼠标点击标签，但是不松手时。 对应的代码如下： 123456789101112131415161718192021&lt;style type=\"text/css\"&gt; /*让超链接点击之前是红色*/ a:link&#123; color:red; &#125; /*让超链接点击之后是绿色*/ a:visited&#123; color:orange; &#125; /*鼠标悬停，放到标签上的时候*/ a:hover&#123; color:green; &#125; /*鼠标点击链接，但是不松手的时候*/ a:active&#123; color:black;&lt;/style&gt; 记住，在css中，这四种状态必须按照固定的顺序写： a:link 、a:visited 、a:hover 、a:active 如果不按照顺序，那么将失效。 超链接的美化a{}和a:link{}的区别： a{}定义的样式针对所有的超链接(包括锚点) a:link{}定义的样式针对所有写了href属性的超链接(不包括锚点) 超链接a标签在使用的时候，比较难。因为不仅仅要控制a这个盒子，也要控制它的伪类。 我们一定要将a标签写在前面，将:link、:visited、:hover、:active这些伪类写在后面。 当我们在定义a:link和 a:visited这两个伪类的时候，如果它们的属性相同，我们其实可以写在一起，用逗号隔开就好，摘抄如下： 1234567891011121314.nav ul li a&#123; display: block; width: 120px; height: 50px;&#125;/*两个伪类的属性，可以用逗号隔开*/.nav ul li a:link , .nav ul li a:visited&#123; text-decoration: none; background-color: purple; color:white;&#125;.nav ul li a:hover&#123; background-color: orange;&#125; 如上方代码所示，最标准的写法，就是把link、visited、hover这三个伪类都要写。但是前端开发工程师在大量的实践中，发现不写link、visited也挺兼容。写法是： a:link、a:visited都是可以省略的，简写在a标签里面。也就是说，a标签涵盖了link、visited的状态（前提是都具有了相同的属性）。写法如下： 动态伪类举例下面这三种动态伪类，针对所有标签都适用。 :hover “悬停”：鼠标放到标签上的时候 :active “激活”： 鼠标点击标签，但是不松手时。 :focus 是某个标签获得焦点时的样式（比如某个输入框获得焦点）","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"WindowHistory","slug":"04-WindowHistory","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:46:26.000Z","comments":true,"path":"2020/04/18/04-WindowHistory/","link":"","permalink":"http://yoursite.com/2020/04/18/04-WindowHistory/","excerpt":"前言window.history 对象包含浏览器历史。 Window Historywindow.history 对象可不带 window 书写。 为了保护用户的隐私，JavaScript 访问此对象存在限制。","text":"前言window.history 对象包含浏览器历史。 Window Historywindow.history 对象可不带 window 书写。 为了保护用户的隐私，JavaScript 访问此对象存在限制。 一些方法： history.back() - 等同于在浏览器点击后退按钮 history.forward() - 等同于在浏览器中点击前进按钮 Window History Backhistory.back() 方法加载历史列表中前一个 URL。 这等同于在浏览器中点击后退按钮。 实例 在页面中创建后退按钮： 1234567891011121314&lt;html&gt;&lt;head&gt;&lt;script&gt;function goBack() &#123; window.history.back() &#125;&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;Back&quot; onclick&#x3D;&quot;goBack()&quot;&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; Window History Forwardhistory forward() 方法加载历史列表中下一个 URL。 这等同于在浏览器中点击前进按钮。 实例 在页面中创建前进按钮： 1234567891011121314&lt;html&gt;&lt;head&gt;&lt;script&gt;function goForward() &#123; window.history.forward() &#125;&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;Forward&quot; onclick&#x3D;&quot;goForward()&quot;&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;","categories":[{"name":"BOM","slug":"BOM","permalink":"http://yoursite.com/categories/BOM/"}],"tags":[{"name":"BOM","slug":"BOM","permalink":"http://yoursite.com/tags/BOM/"}]},{"title":"基本数据类型vs引用数据类型","slug":"04-基本数据类型vs引用数据类型","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:45:54.000Z","comments":true,"path":"2020/04/18/04-基本数据类型vs引用数据类型/","link":"","permalink":"http://yoursite.com/2020/04/18/04-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Bvs%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"变量有以下数据类型： 基本数据类型（值类型）：String 字符串、Number 数值、Boolean 布尔值、Null 空值、Undefined 未定义。 引用数据类型（引用类型）：Object 对象。 本文，我们针对这两种类型，做进一步介绍。我们先来看个例子。","text":"变量有以下数据类型： 基本数据类型（值类型）：String 字符串、Number 数值、Boolean 布尔值、Null 空值、Undefined 未定义。 引用数据类型（引用类型）：Object 对象。 本文，我们针对这两种类型，做进一步介绍。我们先来看个例子。 基本数据类型举例： 1234567var a = 23;var b = a;a++;console.log(a); // 打印结果：24console.log(b); // 打印结果：23 上面的代码中：a 和 b 都是基本数据类型，让 b 等于 a，然后改变 a 的值之后，发现 b 的值并没有被改变。 但是在引用数据类型中，就不同了，我们来看一看。 引用数据类型举例： 1234567891011var obj1 = new Object();obj1.name = 'smyh';// 让 obj2 等于 obj1var obj2 = obj1;// 修改 obj1 的 name 属性obj1.name = 'vae';console.log(obj1.name); // 打印结果：vaeconsole.log(obj2.name); // 打印结果：vae 上面的代码中：obj1 和 obj2 都是引用数据类型，让 obj2 等于 obj1，然后修改 obj1.name 的值之后，发现 obj2.name 的值也发生了改变。 从上面的例子中，可以反映出，基本数据类型和引用数据类型是有区别的。 那到底有什么区别呢？我们进一步往下看。 栈内存和堆内存我们首先记住一句话：JS中，所有的变量都是保存在栈内存中的。 然后来看看下面的区别。 基本数据类型： 基本数据类型的值，直接保存在栈内存中。值与值之间是独立存在，修改一个变量不会影响其他的变量。 引用数据类型： 引用数据类型在被创建时，首先要在栈上给其引用（句柄）分配一块内存，而对象的具体信息都存储在堆内存上，然后由栈上面的引用指向堆中对象的地址。 如果两个变量保存了同一个对象的引用，当一个通过一个变量修改属性时，另一个也会受到影响。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"变量的解构赋值","slug":"04-变量的解构赋值","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:46:06.000Z","comments":true,"path":"2020/04/18/04-变量的解构赋值/","link":"","permalink":"http://yoursite.com/2020/04/18/04-%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/","excerpt":"前言本文主要内容： 数组的解构赋值 对象的解构赋值 字符串的解构赋值 数值和布尔值的解构赋值 函数参数的解构赋值 圆括号问题 用途","text":"前言本文主要内容： 数组的解构赋值 对象的解构赋值 字符串的解构赋值 数值和布尔值的解构赋值 函数参数的解构赋值 圆括号问题 用途 数组的解构赋值 基本用法ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构(Destructuring). ES6允许写成： 1let [a, b, c] &#x3D; [1, 2, 3]; 上面代码表示，可以从数组中提取值，按照对用位置，对变量赋值。 如果解构不成功，变量的值就等于undefined。 不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。 如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。 对于Set结构，也可以使用数组的解构赋值。 12let [x, y, z] &#x3D; new Set([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]);x &#x2F;&#x2F; &quot;a&quot; 只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值。 默认值解构赋值允许指定默认值。 12345let [foo &#x3D; true] &#x3D; [];foo &#x2F;&#x2F; truelet [x, y &#x3D; &#39;b&#39;] &#x3D; [&#39;a&#39;]; &#x2F;&#x2F; x&#x3D;&#39;a&#39;, y&#x3D;&#39;b&#39;let [x, y &#x3D; &#39;b&#39;] &#x3D; [&#39;a&#39;, undefined]; &#x2F;&#x2F; x&#x3D;&#39;a&#39;, y&#x3D;&#39;b&#39; 注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。 12345let [x &#x3D; 1] &#x3D; [undefined];x &#x2F;&#x2F; 1let [x &#x3D; 1] &#x3D; [null];x &#x2F;&#x2F; null 上面代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。 12345function f() &#123; console.log(&#39;aaa&#39;);&#125;let [x &#x3D; f()] &#x3D; [1]; 上面代码中，因为x能取到值，所以函数f根本不会执行。上面的代码其实等价于下面的代码。 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。 1234let [x &#x3D; 1, y &#x3D; x] &#x3D; []; &#x2F;&#x2F; x&#x3D;1; y&#x3D;1let [x &#x3D; 1, y &#x3D; x] &#x3D; [2]; &#x2F;&#x2F; x&#x3D;2; y&#x3D;2let [x &#x3D; 1, y &#x3D; x] &#x3D; [1, 2]; &#x2F;&#x2F; x&#x3D;1; y&#x3D;2let [x &#x3D; y, y &#x3D; 1] &#x3D; []; &#x2F;&#x2F; ReferenceError: y is not defined 对象的解构赋值基本用法解构不仅可以用于数组，还可以用于对象。 123let &#123; foo, bar &#125; &#x3D; &#123; foo: &#39;aaa&#39;, bar: &#39;bbb&#39; &#125;;foo &#x2F;&#x2F; &quot;aaa&quot;bar &#x2F;&#x2F; &quot;bbb&quot; 对象的解构与数组有一个重要的不同。数组的元素是按顺序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 如果解构失败，变量的值等于undefined。 对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。 123456&#x2F;&#x2F; 例一let &#123; log, sin, cos &#125; &#x3D; Math;&#x2F;&#x2F; 例二const &#123; log &#125; &#x3D; console;log(&#39;hello&#39;) &#x2F;&#x2F; hello 也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是变量，而不是前者。 1234let &#123; foo: baz &#125; &#x3D; &#123; foo: &#39;aaa&#39;, bar: &#39;bbb&#39; &#125;;baz &#x2F;&#x2F; &quot;aaa&quot;foo &#x2F;&#x2F; error: foo is not defined 与数组一样，解构也可以用于嵌套结构的对象。 12345678910let obj &#x3D; &#123; p: [ &#39;Hello&#39;, &#123; y: &#39;World&#39; &#125; ]&#125;;let &#123; p: [x, &#123; y &#125;] &#125; &#x3D; obj;x &#x2F;&#x2F; &quot;Hello&quot;y &#x2F;&#x2F; &quot;World&quot; 注意，这时p是模式，不是变量，因此不会被赋值。 对象的解构赋值可以取到继承的属性。 123456const obj1 &#x3D; &#123;&#125;;const obj2 &#x3D; &#123; foo: &#39;bar&#39; &#125;;Object.setPrototypeOf(obj1, obj2);const &#123; foo &#125; &#x3D; obj1;foo &#x2F;&#x2F; &quot;bar&quot; 上面代码中，对象 obj1的原型对象是obj2。foo属性不是obj1自身的属性，而是继承自obj2的属性，解构赋值可以取到这个属性。 默认值对象的解构也可以指定默认值。 123456789101112131415var &#123;x &#x3D; 3&#125; &#x3D; &#123;&#125;;x &#x2F;&#x2F; 3var &#123;x, y &#x3D; 5&#125; &#x3D; &#123;x: 1&#125;;x &#x2F;&#x2F; 1y &#x2F;&#x2F; 5var &#123;x: y &#x3D; 3&#125; &#x3D; &#123;&#125;;y &#x2F;&#x2F; 3var &#123;x: y &#x3D; 3&#125; &#x3D; &#123;x: 5&#125;;y &#x2F;&#x2F; 5var &#123; message: msg &#x3D; &#39;Something went wrong&#39; &#125; &#x3D; &#123;&#125;;msg &#x2F;&#x2F; &quot;Something went wrong&quot; 默认值生效的条件是，对象的属性值严格等于undefined。 12345var &#123;x &#x3D; 3&#125; &#x3D; &#123;x: undefined&#125;;x &#x2F;&#x2F; 3var &#123;x &#x3D; 3&#125; &#x3D; &#123;x: null&#125;;x &#x2F;&#x2F; null 上面代码中，属性x等于null，因为null与undefined不严格相等，所以是个有效的赋值，导致默认值3不会生效。 字符串的解构赋值字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。 123456const [a, b, c, d, e] &#x3D; &#39;hello&#39;;a &#x2F;&#x2F; &quot;h&quot;b &#x2F;&#x2F; &quot;e&quot;c &#x2F;&#x2F; &quot;l&quot;d &#x2F;&#x2F; &quot;l&quot;e &#x2F;&#x2F; &quot;o&quot; 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。 12let &#123;length : len&#125; &#x3D; &#39;hello&#39;;len &#x2F;&#x2F; 5 数值和布尔值的解构赋值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。 12345let &#123;toString: s&#125; &#x3D; 123;s &#x3D;&#x3D;&#x3D; Number.prototype.toString &#x2F;&#x2F; truelet &#123;toString: s&#125; &#x3D; true;s &#x3D;&#x3D;&#x3D; Boolean.prototype.toString &#x2F;&#x2F; true 上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。 12let &#123; prop: x &#125; &#x3D; undefined; &#x2F;&#x2F; TypeErrorlet &#123; prop: y &#125; &#x3D; null; &#x2F;&#x2F; TypeError 函数参数的解构赋值函数的参数也可以使用解构赋值。 12345function add([x, y])&#123; return x + y;&#125;add([1, 2]); &#x2F;&#x2F; 3 上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。 下面是另一个例子。 123456789101112[[1, 2], [3, 4]].map(([a, b]) &#x3D;&gt; a + b);&#x2F;&#x2F; [ 3, 7 ]函数参数的解构也可以使用默认值。function move(&#123;x &#x3D; 0, y &#x3D; 0&#125; &#x3D; &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); &#x2F;&#x2F; [3, 8]move(&#123;x: 3&#125;); &#x2F;&#x2F; [3, 0]move(&#123;&#125;); &#x2F;&#x2F; [0, 0]move(); &#x2F;&#x2F; [0, 0] 上面代码中，函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。如果解构失败，x和y等于默认值。 注意，下面的写法会得到不一样的结果。 12345678function move(&#123;x, y&#125; &#x3D; &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); &#x2F;&#x2F; [3, 8]move(&#123;x: 3&#125;); &#x2F;&#x2F; [3, undefined]move(&#123;&#125;); &#x2F;&#x2F; [undefined, undefined]move(); &#x2F;&#x2F; [0, 0] 上面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。 undefined就会触发函数参数的默认值。 12[1, undefined, 3].map((x &#x3D; &#39;yes&#39;) &#x3D;&gt; x);&#x2F;&#x2F; [ 1, &#39;yes&#39;, 3 ] 圆括号问题解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。 由此带来的问题是，如果模式中出现圆括号怎么处理。ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。 但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。 不能使用圆括号的情况以下三种解构赋值不得使用圆括号。 （1）变量声明语句 123456789&#x2F;&#x2F; 全部报错let [(a)] &#x3D; [1];let &#123;x: (c)&#125; &#x3D; &#123;&#125;;let (&#123;x: c&#125;) &#x3D; &#123;&#125;;let &#123;(x: c)&#125; &#x3D; &#123;&#125;;let &#123;(x): c&#125; &#x3D; &#123;&#125;;let &#123; o: (&#123; p: p &#125;) &#125; &#x3D; &#123; o: &#123; p: 2 &#125; &#125;; 上面 6 个语句都会报错，因为它们都是变量声明语句，模式不能使用圆括号。 （2）函数参数 函数参数也属于变量声明，因此不能带有圆括号。 1234&#x2F;&#x2F; 报错function f([(z)]) &#123; return z; &#125;&#x2F;&#x2F; 报错function f([z,(x)]) &#123; return x; &#125; （3）赋值语句的模式 1234567&#x2F;&#x2F; 全部报错(&#123; p: a &#125;) &#x3D; &#123; p: 42 &#125;;([a]) &#x3D; [5];上面代码将整个模式放在圆括号之中，导致报错。&#x2F;&#x2F; 报错[(&#123; p: a &#125;), &#123; x: c &#125;] &#x3D; [&#123;&#125;, &#123;&#125;]; 上面代码将一部分模式放在圆括号之中，导致报错。 可以使用圆括号的情况可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。 123[(b)] &#x3D; [3]; &#x2F;&#x2F; 正确(&#123; p: (d) &#125; &#x3D; &#123;&#125;); &#x2F;&#x2F; 正确[(parseInt.prop)] &#x3D; [3]; &#x2F;&#x2F; 正确 上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。 用途变量的解构赋值用途很多。 （1）交换变量的值 1234let x &#x3D; 1;let y &#x3D; 2;[x, y] &#x3D; [y, x]; 上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。 （2）从函数返回多个值 函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。 12345678910111213141516&#x2F;&#x2F; 返回一个数组function example() &#123; return [1, 2, 3];&#125;let [a, b, c] &#x3D; example();&#x2F;&#x2F; 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;let &#123; foo, bar &#125; &#x3D; example(); （3）函数参数的定义 解构赋值可以方便地将一组参数与变量名对应起来。 1234567&#x2F;&#x2F; 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);&#x2F;&#x2F; 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); （4）提取 JSON 数据 解构赋值对提取 JSON 对象中的数据，尤其有用。 12345678910let jsonData &#x3D; &#123; id: 42, status: &quot;OK&quot;, data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; &#x3D; jsonData;console.log(id, status, number);&#x2F;&#x2F; 42, &quot;OK&quot;, [867, 5309] 上面代码可以快速提取 JSON 数据的值。 （5）函数参数的默认值 1234567891011jQuery.ajax &#x3D; function (url, &#123; async &#x3D; true, beforeSend &#x3D; function () &#123;&#125;, cache &#x3D; true, complete &#x3D; function () &#123;&#125;, crossDomain &#x3D; false, global &#x3D; true, &#x2F;&#x2F; ... more config&#125; &#x3D; &#123;&#125;) &#123; &#x2F;&#x2F; ... do stuff&#125;; 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || ‘default foo’;这样的语句。 （6）遍历 Map 结构 任何部署了 Iterator 接口的对象，都可以用for…of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。 1234567891011121314151617181920const map &#x3D; new Map();map.set(&#39;first&#39;, &#39;hello&#39;);map.set(&#39;second&#39;, &#39;world&#39;);for (let [key, value] of map) &#123; console.log(key + &quot; is &quot; + value);&#125;&#x2F;&#x2F; first is hello&#x2F;&#x2F; second is world如果只想获取键名，或者只想获取键值，可以写成下面这样。&#x2F;&#x2F; 获取键名for (let [key] of map) &#123; &#x2F;&#x2F; ...&#125;&#x2F;&#x2F; 获取键值for (let [,value] of map) &#123; &#x2F;&#x2F; ...&#125; （7）输入模块的指定方法 加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。 1const &#123; SourceMapConsumer, SourceNode &#125; &#x3D; require(&quot;source-map&quot;);","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"CSS样式表的继承性和层叠性","slug":"05-CSS样式表的继承性和层叠性","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:47:06.000Z","comments":true,"path":"2020/04/18/05-CSS样式表的继承性和层叠性/","link":"","permalink":"http://yoursite.com/2020/04/18/05-CSS%E6%A0%B7%E5%BC%8F%E8%A1%A8%E7%9A%84%E7%BB%A7%E6%89%BF%E6%80%A7%E5%92%8C%E5%B1%82%E5%8F%A0%E6%80%A7/","excerpt":"本文主要内容 CSS的继承性 CSS的层叠性 计算权重 权重问题大总结 CSS样式表的冲突的总结 权重问题深入 同一个标签，携带了多个类名 !important标记","text":"本文主要内容 CSS的继承性 CSS的层叠性 计算权重 权重问题大总结 CSS样式表的冲突的总结 权重问题深入 同一个标签，携带了多个类名 !important标记 CSS的继承性 有一些属性，当给自己设置的时候，自己的后代都继承上了，这个就是继承性。 继承性是从自己开始，直到最小的元素。 关于文字样式的属性，都具有继承性。这些属性包括：color、 text-开头的、line-开头的、font-开头的。 关于盒子、定位、布局的属性，都不能继承。 CSS的层叠性很多公司如果要笔试，那么一定会考层叠性。 层叠性：计算权重层叠性：就是css处理冲突的能力。 所有的权重计算，没有任何兼容问题！ 当多个选择器，选择上了某个元素的时候，要按照如下顺序统计权重： id 选择器 类选择器、属性选择器、伪类选择器 标签选择器、伪元素选择器 因为对于相同方式的样式表，其选择器排序的优先级为：ID选择器 &gt; 类选择器 &gt; 标签选择器 层叠性：权重计算的问题大总结（非常重要）层叠性。层叠性是一种能力，就是处理冲突的能力。当不同选择器，对一个标签的同一个样式，有不同的值，听谁的？这就是冲突。css有着严格的处理冲突的机制。 选择上了，数权重，(id的数量，类的数量，标签的数量)。如果权重一样，谁写在后面听谁的。 没有选择上，通过继承影响的，就近原则，谁描述的近听谁的。如果描述的一样近，比如选择器权重，如果权重再一样重，谁写在后面听谁的。 CSS样式表的冲突的总结 1、对于相同的选择器（比如同样都是类选择器），其样式表排序：行级样式 &gt; 内嵌样式表 &gt; 外部样式表（就近原则） 2、对于相同类型的样式表（比如同样都是内部样式表），其选择器排序：ID选择器 &gt; 类选择器 &gt; 标签选择器 3、外部样式表的ID选择器 &gt; 内嵌样式表的标签选择器 总结：就近原则。ID选择器优先级最大。 权重问题深入同一个标签，携带了多个类名，有冲突：这里需要补充两种冲突的情况： 1、对同一个标签，如果用到了了多个相同的内嵌样式表，它的优先级：定义的样式表中，谁最近，就用谁。 2、对于同一个标签，如果引用了多个相同的外部样式表，它的优先级：html文件中，引用样式表的位置越近，就用谁。 !important标记需要强调如下3点： （1）!important提升的是一个属性，而不是一个选择器 123456789101112p&#123; color:red !important; 只写了这一个!important，所以只有字体颜色属性提升了权重 font-size: 100px ; 这条属性没有写!important，所以没有提升权重&#125;#para1&#123; color:blue; font-size: 50px;&#125;.spec&#123; color:green; font-size: 20px;&#125; 所以，综合来看，字体颜色是red（听important的）；字号是50px（听id的）。 （2）!important无法提升继承的权重，该是0还是0 比如HTML结构： 123&lt;div&gt; &lt;p&gt;哈哈哈哈哈哈哈哈&lt;/p&gt;&lt;/div&gt; 有CSS样式： 123456div&#123; color:red !important;&#125;p&#123; color:blue;&#125; 由于div是通过继承性来影响文字颜色的，所以!important无法提升它的权重，权重依然是0。 干不过p标签，因为p标签是实实在在选中了，所以字是蓝色的（以p为准）。 (3)!important不影响就近原则 如果大家都是继承来的，按理说应该按照“就近原则”，那么important能否影响就近原则呢？答案是：不影响。远的，永远是远的。不能给远的写一个important，干掉近的。 为了验证这个问题，我们可以搞两层具有继承性的标签，然后给外层标签加一个!important，最终看看就近原则有没有被打破。举例如下：","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"typeof和数据类型转换","slug":"05-typeof和数据类型转换","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T03:52:32.000Z","comments":true,"path":"2020/04/18/05-typeof和数据类型转换/","link":"","permalink":"http://yoursite.com/2020/04/18/05-typeof%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","excerpt":"变量的数据类型转换：将一种数据类型转换为另外一种数据类型。 通常有三种形式的类型转换： 转换为字符串类型 转换为数字型 转换为布尔型","text":"变量的数据类型转换：将一种数据类型转换为另外一种数据类型。 通常有三种形式的类型转换： 转换为字符串类型 转换为数字型 转换为布尔型 typeof 运算符 我们先来讲一下 typeof，再讲类型转换。 typeof()表示“获取变量的数据类型”，返回的是小写，语法为：（两种写法都可以） 12345// 写法1typeof 变量;// 写法2typeof(变量); typeof 这个运算符的返回结果就是变量的类型。那返回结果的类型是什么呢？是字符串。 返回结果： 类型 结果 Undefined “undefined” Null “object” Boolean “boolean” Number “number” BigInt “bigint” String “string” Symbol (ECMAScript 2015 新增) “symbol” 宿主对象（由 JS 环境提供） 取决于具体实现 Function 对象(按照 ECMA-262 规范实现 [[Call]]) “function” 其他任何对象 “object” 备注 1：为啥 typeof null的返回值也是 object 呢？因为 null 代表的是空对象。 备注 2：typeof NaN的返回值是 number，NaN 是一个特殊的数字。 返回结果举例： 123console.log(type []); // 空数组的打印结果：objectconsole.log(type &#123;&#125;); // 空对象的打印结果：object 代码解释：这里的空数组[]、空对象{} ，为啥他们在使用 typeof 时，返回值也是 object呢？因为这里的 返回结果object指的是引用数据类型。空数组、空对象都是引用数据类型 Object。 instanceofinstanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。 instanceof 是判断变量是否为某个对象的实例，返回值为true或false。 语法：object instanceof constructor 123456var o &#x3D; &#123;&#125;;var a &#x3D; [];o instanceof Array &#x2F;&#x2F; falsea instanceof Array &#x2F;&#x2F; truea instanceof Object &#x2F;&#x2F; true 变量的类型转换的分类类型转换分为两种：显示类型转换、隐式类型转换。 显示类型转换 toString() String() Number() parseInt(string) parseFloat(string) Boolean() 隐式类型转换 isNaN () 自增/自减运算符：++、—- 正号/负号：+a、-a 加号：+ 运算符：-、*、/ 隐式类型转换（特殊） 逻辑运算符：&amp;&amp;、||、！ 。非布尔值进行与或运算时，会先将其转换为布尔值，然后再运算，但运算结果是原值。具体可以看下一篇文章《运算符》。 关系运算符：&lt;、&gt; &lt;= &gt;=等。关系运算符，得到的运算结果都是布尔值：要么是true，要么是false。 针对上面这两种类型转换，这篇文章来详细介绍。 其他的简单类型 –&gt; String方法一（隐式类型转换）：字符串拼接格式：变量+”” 或者 变量+”abc” 举例： 123var a = 123; // Number 类型console.log(a + ''); // 转换成 String 类型console.log(a + 'haha'); // 转换成 String 类型 上面的例子中，打印的结果，都是字符串类型的数据。实际上内部是调用的 String() 函数。也就是说，c = c + &quot;&quot; 等价于 c = String(c)。 方法二：调用 toString()方法语法： 1变量.toString() 【重要】该方法不会影响到原变量，它会将转换的结果返回。当然我们还可以直接写成a = a.toString()，这样的话，就是直接修改原变量。 注意：null 和 undefined 这两个值没有 toString()方法，所以它们不能用方法二。如果调用，会报错。 另外，Number 类型的变量，在调用 toString()时，可以在方法中传递一个整数作为参数。此时它将会把数字转换为指定的进制，如果不指定则默认转换为 10 进制。例如： 12345678var a = 255;//对于Number调用toString()时可以在方法中传递一个整数作为参数//此时它将会把数字转换为指定的进制,如果不指定则默认转换为10进制a = a.toString(2); // 转换为二进制console.log(a); // 11111111console.log(typeof a); // string 方法三（强制转换）：使用 String()函数语法： 1String(变量) 使用 String()函数做强制类型转换时： 对于 Number 和 Boolean 而言，本质上就是调用 toString()方法。 但是对于 null 和 undefined，则不会调用 toString()方法。它会将 null 直接转换为 “null”。将 undefined 直接转换为 “undefined”。 prompt()：用户的输入prompt()就是专门用来弹出能够让用户输入的对话框。重要的是：用户不管输入什么，都当字符串处理。 其他的数据类型 –&gt; Number 【重要】使用 Number() 函数情况一：字符串 –&gt; 数字 1.如果字符串中是纯数字，则直接将其转换为数字。 2.只要字符串中包含了非数字的内容（小数点按数字来算），则转换为 NaN。 3.如果字符串是一个空串或者是一个全是空格的字符串，则转换为 0。 情况二：布尔 –&gt; 数字 true 转成 1 false 转成 0 情况三：null –&gt; 数字 结果为：0 情况四：undefined –&gt; 数字 结果为：NaN 补充：怎么理解这里的 NaN 呢？可以这样理解，使用 Number() 函数之后，如果无法转换为数字，就会转换为 NaN。 使用 parseInt()函数：字符串 -&gt; 整数parseInt()的作用是将字符串中的有效的整数内容转为数字。parse 表示“转换”，Int 表示“整数”（注意Int的拼写）。例如： 1parseInt(\"5\"); 得到的结果是数字 5。 parseInt()的转换情况如下。 情况一：字符串 –&gt; 数字 1.只保留字符串最开头的数字，后面的中文自动消失。 2.如果字符串不是以数字开头，则转换为 NaN。 3.如果字符串是一个空串或者是一个全是空格的字符串，转换时会报错。 情况二：Boolean –&gt; 数字 结果为：NaN 情况三：Null –&gt; 数字 结果为：NaN 情况四：Undefined –&gt; 数字 结果为：NaN Number() 函数和 parseInt() 函数的区别： 就拿Number(true) 和 parseInt(true)/parseFloat(true)来举例，二者在使用时，是有区别的： Number(true) ：千方百计地想转换为数字。 parseInt(true)/parseFloat(true) ：先转为字符串，再提取出最前面的数字部分；没提取出来，那就返回 NaN。 parseInt()具有以下特性： （1）只保留字符串最开头的数字，后面的中文自动消失。例如： 12345console.log(parseInt(\"2017在公众号上写了6篇文章\")); //打印结果：2017console.log(parseInt(\"2017.01在公众号上写了6篇文章\")); //打印结果仍是：2017 （说明只会取整数）console.log(parseInt(\"aaa2017.01在公众号上写了6篇文章\")); //打印结果：NaN （因为不是以数字开头） （2）如果对非 String使用 parseInt()或 parseFloat()，它会先将其转换为 String 然后再操作。【重要】 比如： 1234567891011var a = 168.23;console.log(parseInt(a)); //打印结果：168 （因为是先将c转为字符串\"168.23\"，然后然后再操作）var b = true;console.log(parseInt(b)); //打印结果：NaN （因为是先将a转为字符串\"true\"，然后然后再操作）var c = null;console.log(parseInt(c)); //打印结果：NaN （因为是先将b转为字符串\"null\"，然后然后再操作）var d = undefined;console.log(parseInt(d)); //打印结果：NaN （因为是先将b转为字符串\"undefined\"，然后然后再操作） （3）自动带有截断小数的功能：取整，不四舍五入。 例 1： 12var a = parseInt(5.8) + parseInt(4.7);console.log(a); 打印结果： 19 例 2： 12var a = parseInt(5.8 + 4.7);console.log(a); 打印结果： 110; （4）带两个参数时，表示在转换时，包含了进制转换。 代码举例： 12345var a = '110';var num = parseInt(a, 16); // 【重要】将 a 当成 十六进制 来看待，转换成 十进制 的 numconsole.log(num); 打印结果： 1272 如果你对打印结果感到震惊，请仔细看上面的代码注释。就是说，无论 parseInt() 里面的进制参数是多少，最终的转换结果是十进制。 我们继续来看下面的代码，打印结果是多少。 12345var a = '5';var num = parseInt(a, 2); // 将 a 当成 二进制 来看待，转换成 十进制 的 numconsole.log(num); // 打印结果：NaN。因为 二进制中没有 5 这个数，转换失败。 parseFloat()函数：字符串 –&gt; 浮点数（小数）parseFloat()的作用是：将字符串转换为浮点数。 parseFloat()和 parseInt()的作用类似，不同的是，parseFloat()可以获得有效的小数部分。 代码举例： 12var a = '123.456.789px';console.log(parseFloat(a)); // 打印结果：123.456 parseFloat() 的几个特性，可以参照 parseInt()。 转换为 Boolean将其他的数据类型转换为 Boolean，可以使用 Boolean()函数。情况如下： 情况一：数字 –&gt; 布尔。除了 0 和 NaN，其余的都是 true。也就是说，Boolean(NaN)的结果是 false。 情况二：字符串 —&gt; 布尔。除了空串，其余的都是 true。全是空格的字符串，转换结果也是 true。字符串&#39;0&#39;的转换结果也是 true。 情况三：null 和 undefined 都会转换为 false。 情况四：引用数据类型会转换为 true。注意，空数组[]和空对象{}，转换结果也是 true，这个一点，很多人都不知道。 PS：转换为 Boolean 的这几种情况，很重要，开发中会经常用到。 知识补充：其他进制的数字 16 进制的数字，以0x开头 8 进制的数字，以0开头 2 进制的数字，0b开头（不是所有的浏览器都支持：chrome 和火狐支持，IE 不支持） 比如070这个字符串，如果我调用 parseInt()转成数字时，有些浏览器会当成 8 进制解析，有些会当成 10 进制解析。 所以，比较建议的做法是：可以在 parseInt()中传递第二个参数，来指定当前数字的进制。例如： 1234var a = \"070\";a = parseInt(a, 8); //将 070 当成八进制来看待，转换结果为十进制。console.log(a); // 打印结果：56。这个地方要好好理解。 隐式类型转换重点：隐式类型转换，内部调用的都是显式类型的方法。下面来详细介绍。 isNaN() 函数语法： 1isNaN(参数); 解释：判断指定的参数是否为 NaN（非数字类型），返回结果为 Boolean 类型。也就是说：任何不能被转换为数值的参数，都会让这个函数返回 true。 执行过程： （1）先调用Number(参数)函数； （2）然后将Number(参数)的返回结果和NaN进行比较。 代码举例： 123456789console.log(isNaN('123')); // 返回结果：false。console.log(isNaN('abc')); // 返回结果：true。因为 Number('abc') 的返回结果是 NaNconsole.log(isNaN(null)); // 返回结果：falseconsole.log(isNaN(undefined)); // 返回结果：trueconsole.log(isNaN(NaN)); // 返回结果：true 自增/自减运算符：++、—-举例 1： 12345var a = \"666\";a++;console.log(typeof a); // 打印结果： numberconsole.log(a); // 打印结果：667 执行过程： （1）先调用Number(参数)函数； （2）然后将Number(参数)的返回结果进行 加 1 操作。 举例 2： 1234var a = 'abc';a++;console.log(typeof a); // 打印结果：numberconsole.log(a); // 打印结果：NaN。因为 Number('abc')的结果为 NaN，再自增后，结果依然是 NaN 正号/负号：+a、-a 注意，这里说的是正号/负号，不是加号/减号。 任何值做+a、-a、/a运算时，运算结果都会自动转换为 Number 类型。 内部调用的是 Number() 函数。 举例： 12345678var a = '666';var b = +a;console.log(typeof a); // 打印结果：string。说明 a 的数据类型保持不变。console.log(a); // 打印结果：666console.log(typeof b); // 打印结果：number。说明 b 的数据类型发生了变化。console.log(b); // 打印结果：666 加号：+情况一：字符串 + 数字 当加号的两边，只要有一个是字符串的时候，就会调用 String() 函数将数字转为字符串，然后再计算。导致最终的运算结果是字符串。 情况二：Boolean + 数字 Boolean 型和数字型相加时， true 按 1 来算 ，false 按 0 来算。这里其实是先调 Number() 函数，将 Boolean 类型转换为 Number类型，然后再和 数字相加。 情况三： null + 数字 等价于：0 + 数字 情况四： undefined + 数字 计算结果：NaN 运算符：-、*、/1、任何非 Number 类型的值做-、*、/运算时，会将这些值转换为Number然后再运算(内部调用的是 Number() 函数），运算结果是 Number 类型。（注：任何值 + 字符串是特例，运算结果是字符串） 比如： 1234567result1 = true + 1; // 2 = 1+ 1result2 = true + false; // 1 = 1+ 0result3 = 1 + null; // 1 = 1+ 0result4 = 100 - '1' // 99 2、任何的值和字符串做加法运算，都会先转换为字符串，然后再做拼串操作。 比如： 123result1 = 1 + 2 + '3' // 33result2 = '1' + 2 + 3; // 123 3、任何值和NaN做运算的结果都是NaN。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"WindowNavigator","slug":"05-WindowNavigator","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:46:54.000Z","comments":true,"path":"2020/04/18/05-WindowNavigator/","link":"","permalink":"http://yoursite.com/2020/04/18/05-WindowNavigator/","excerpt":"前言window.navigator 对象包含有关访问者的信息。","text":"前言window.navigator 对象包含有关访问者的信息。 Window Navigatorwindow.navigator 对象可以不带 window 前缀来写。 一些例子： navigator.appName navigator.appCodeName navigator.platform 浏览器 CookiecookieEnabled 属性返回 true，如果 cookie 已启用，否则返回 false： 实例 12345&lt;p id&#x3D;&quot;demo&quot;&gt;&lt;&#x2F;p&gt;&lt;script&gt;document.getElementById(&quot;demo&quot;).innerHTML &#x3D; &quot;cookiesEnabled is &quot; + navigator.cookieEnabled;&lt;&#x2F;script&gt; 浏览器应用程序名称appName 属性返回浏览器的应用程序名称. 浏览器应用程序代码名称appCodeName 属性返回浏览器的应用程序代码名称： 实例 12345&lt;p id&#x3D;&quot;demo&quot;&gt;&lt;&#x2F;p&gt;&lt;script&gt;document.getElementById(&quot;demo&quot;).innerHTML &#x3D; &quot;navigator.appCodeName is &quot; + navigator.appCodeName;&lt;&#x2F;script&gt; “Mozilla” 是 Chrome、Firefox、IE、Safari 以及 Opera 的应用程序代码名称。 浏览器引擎product 属性返回浏览器引擎的产品名称： 实例 12345&lt;p id&#x3D;&quot;demo&quot;&gt;&lt;&#x2F;p&gt;&lt;script&gt;document.getElementById(&quot;demo&quot;).innerHTML &#x3D; &quot;navigator.product is &quot; + navigator.product;&lt;&#x2F;script&gt; 浏览器版本appVersion 属性返回有关浏览器的版本信息. 浏览器代理userAgent 属性返回由浏览器发送到服务器的用户代理报头（user-agent header）. 来自 navigator 对象的信息通常是误导性的，不应该用于检测浏览器版本，因为： 不同浏览器能够使用相同名称 导航数据可被浏览器拥有者更改 某些浏览器会错误标识自身以绕过站点测试 浏览器无法报告发布晚于浏览器的新操作系统 浏览器平台platform 属性返回浏览器平台（操作系统）. 浏览器语language 属性返回浏览器语言. 浏览器是否在线？onLine 属性返回 true，假如浏览器在线. Java 是否启用？javaEnabled() 方法返回 true，如果 Java 已启用：","categories":[{"name":"BOM","slug":"BOM","permalink":"http://yoursite.com/categories/BOM/"}],"tags":[{"name":"BOM","slug":"BOM","permalink":"http://yoursite.com/tags/BOM/"}]},{"title":"字符串的拓展","slug":"05-字符串的扩展","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:46:14.000Z","comments":true,"path":"2020/04/18/05-字符串的扩展/","link":"","permalink":"http://yoursite.com/2020/04/18/05-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95/","excerpt":"前言本文主要内容： 字符的 Unicode 表示法 字符串的遍历器接口 直接输入 U+2028 和 U+2029 JSON.stringify() 的改造 模板字符串 实例：模板编译 标签模板 模板字符串的限制","text":"前言本文主要内容： 字符的 Unicode 表示法 字符串的遍历器接口 直接输入 U+2028 和 U+2029 JSON.stringify() 的改造 模板字符串 实例：模板编译 标签模板 模板字符串的限制 字符的 Unicode 表示法 ES6 加强了对 Unicode 的支持，允许采用\\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode 码点。 ES6 中，只要将码点放入大括号，就能正确解读该字符。 1234567891011&quot;\\u&#123;20BB7&#125;&quot;&#x2F;&#x2F; &quot;𠮷&quot;&quot;\\u&#123;41&#125;\\u&#123;42&#125;\\u&#123;43&#125;&quot;&#x2F;&#x2F; &quot;ABC&quot;let hello &#x3D; 123;hell\\u&#123;6F&#125; &#x2F;&#x2F; 123&#39;\\u&#123;1F680&#125;&#39; &#x3D;&#x3D;&#x3D; &#39;\\uD83D\\uDE80&#39;&#x2F;&#x2F; true 上面代码中，最后一个例子表明，大括号表示法与四字节的 UTF-16 编码是等价的。 有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符。 12345&#39;\\z&#39; &#x3D;&#x3D;&#x3D; &#39;z&#39; &#x2F;&#x2F; true&#39;\\172&#39; &#x3D;&#x3D;&#x3D; &#39;z&#39; &#x2F;&#x2F; true&#39;\\x7A&#39; &#x3D;&#x3D;&#x3D; &#39;z&#39; &#x2F;&#x2F; true&#39;\\u007A&#39; &#x3D;&#x3D;&#x3D; &#39;z&#39; &#x2F;&#x2F; true&#39;\\u&#123;7A&#125;&#39; &#x3D;&#x3D;&#x3D; &#39;z&#39; &#x2F;&#x2F; true 字符串的遍历器接口ES6 为字符串添加了遍历器接口，使得字符串可以被for…of循环遍历。 123456for (let codePoint of &#39;foo&#39;) &#123; console.log(codePoint)&#125;&#x2F;&#x2F; &quot;f&quot;&#x2F;&#x2F; &quot;o&quot;&#x2F;&#x2F; &quot;o&quot; 除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。 123456789101112let text &#x3D; String.fromCodePoint(0x20BB7);for (let i &#x3D; 0; i &lt; text.length; i++) &#123; console.log(text[i]);&#125;&#x2F;&#x2F; &quot; &quot;&#x2F;&#x2F; &quot; &quot;for (let i of text) &#123; console.log(i);&#125;&#x2F;&#x2F; &quot;𠮷&quot; 上面代码中，字符串text只有一个字符，但是for循环会认为它包含两个字符（都不可打印），而for…of循环会正确识别出这一个字符。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"CSS盒模型","slug":"06-CSS盒模型详解","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:52:08.000Z","comments":true,"path":"2020/04/18/06-CSS盒模型详解/","link":"","permalink":"http://yoursite.com/2020/04/18/06-CSS%E7%9B%92%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/","excerpt":"盒子模型介绍盒子模型，英文即box model。无论是div、span、还是a都是盒子。 但是，图片、表单元素一律看作是文本，它们并不是盒子。这个很好理解，比如说，一张图片里并不能放东西，它自己就是自己的内容。","text":"盒子模型介绍盒子模型，英文即box model。无论是div、span、还是a都是盒子。 但是，图片、表单元素一律看作是文本，它们并不是盒子。这个很好理解，比如说，一张图片里并不能放东西，它自己就是自己的内容。 盒子中的区域一个盒子中主要的属性就5个：width、height、padding、border、margin。如下： width和height：内容的宽度、高度（不是盒子的宽度、高度）。 padding：内边距。 border：边框。 margin：外边距。 注意：宽度和真实占有宽度，不是一个概念！来看下面这例子。 标准盒模型和IE盒模型 我们目前所学习的知识中，以标准盒子模型为准。 标准盒子模型： IE盒子模型： 上图显示： 在 CSS 盒子模型 (Box Model) 规定了元素处理元素的几种方式： width和height：内容的宽度、高度（不是盒子的宽度、高度）。 padding：内边距。 border：边框。 margin：外边距。 CSS盒模型和IE盒模型的区别： 在 标准盒子模型中，width 和 height 指的是内容区域的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。 IE盒子模型中，width 和 height 指的是内容区域+border+padding的宽度和高度。 &lt;body&gt;标签也有margin&lt;body&gt;标签有必要强调一下。很多人以为&lt;body&gt;标签占据的是整个页面的全部区域，其实是错误的，正确的理解是这样的：整个网页最大的盒子是&lt;document&gt;，即浏览器。而&lt;body&gt;是&lt;document&gt;的儿子。浏览器给&lt;body&gt;默认的margin大小是8个像素，此时&lt;body&gt;占据了整个页面的一大部分区域，而不是全部区域。来看一段代码。 如果想保持一个盒子的真实占有宽度不变，那么加width的时候就要减padding。加padding的时候就要减width。因为盒子变胖了是灾难性的，这会把别的盒子挤下去。 认识paddingpadding区域也有颜色padding就是内边距。padding的区域有背景颜色，css2.1前提下，并且背景颜色一定和内容区域的相同。也就是说，background-color将填充所有border以内的区域。 padding有四个方向padding是4个方向的，所以我们能够分别描述4个方向的padding。 方法有两种，第一种写小属性；第二种写综合属性，用空格隔开。 小属性的写法： 1234padding-top: 30px;padding-right: 20px;padding-bottom: 40px;padding-left: 100px; 综合属性的写法：(上、右、下、左)（顺时针方向，用空格隔开。margin的道理也是一样的） 1padding:30px 20px 40px 100px; 如果写了四个值，则顺序为：上、右、下、左。 如果只写了三个值，则顺序为：上、右、下。左边与右侧相同。 如果只写了两个值，比如说： 1padding: 30px 40px; 则顺序等价于：30px 40px 30px 40px; 要懂得，用小属性层叠大属性。比如： 12padding: 20px;padding-left: 30px; 下面的写法： 12padding-left: 30px;padding: 20px; 第一行的小属性无效，因为被第二行的大属性层叠掉了。 一些元素，默认带有padding一些元素，默认带有padding，比如ul标签。不加任何样式的ul，也是有40px的padding-left。 所以，我们做站的时候，为了便于控制，总是喜欢清除这个默认的padding。 可以使用*进行清除： 1234*&#123; margin: 0; padding: 0;&#125; 但是，*的效率不高，所以我们使用并集选择器，罗列所有的标签（不用背，有专业的清除默认样式的样式表，今后学习）： 1234body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,textarea,p,blockquote,th,td&#123; margin:0; padding:0;&#125; 认识borderborder就是边框。边框有三个要素：像素（粗细）、线型、颜色。 比如： 123456.div1&#123; width: 10px; height: 10px; border: 2px solid red;&#125; 颜色如果不写，默认是黑色。另外两个属性如果不写，则无法显示边框。 border-styleborder的所有的线型如下：（我们可以通过查看CSS参考手册得到） 比较稳定的border-style就几个：solid、dashed、dotted。 border拆分border是一个大综合属性。比如说： 1border:1px solid red; 就是把上下左右这四个方向的边框，都设置为 1px 宽度、线型实线、red颜色。 border属性是能够被拆开的，有两大种拆开的方式： （1）按三要素拆开：border-width、border-style、border-color。（一个border属性是由三个小属性综合而成的） （2）按方向拆开：border-top、border-right、border-bottom、border-left。 现在我们明白了：一个border属性，是由三个小属性综合而成的。如果某一个小属性后面是空格隔开的多个值，那么就是上右下左的顺序。举例如下： 123border-width:10px 20px;border-style:solid dashed dotted;border-color:red green blue yellow; border-image 属性比如： 1border-image: url(.img.png) 30 round; 这个属性在实际开发中用得不多，暂时忽略。 举例1：利用 border 属性画一个三角形（小技巧）完整代码如下： 1234567div&#123; width: 0; height: 0; border: 50px solid transparent; border-top-color: red; border-bottom: none;&#125; 效果如下： 举例2：利用 border 属性画一个三角形（更推荐的技巧）上面的例子1中，画出来的是直角三角形，可如果我想画等边三角形，要怎么做呢？ 完整代码如下：（用 css 画等边三角形） 12345678.div1&#123; width: 0; height: 0; border-top: 30px solid red; /* 通过改变 border-left 和 border-right 中的像素值，来改变三角形的形状 */ border-left: 20px solid transparent; border-right: 20px solid transparent;&#125; 另外，我们在上方代码的基础之上，再加一个 border-radus: 20px; 就能画出一个扇形。","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"JavaScript弹出框","slug":"06-JavaScript弹出框","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:48:38.000Z","comments":true,"path":"2020/04/18/06-JavaScript弹出框/","link":"","permalink":"http://yoursite.com/2020/04/18/06-JavaScript%E5%BC%B9%E5%87%BA%E6%A1%86/","excerpt":"前言JavaScript 有三种类型的弹出框：警告框、确认框和提示框。","text":"前言JavaScript 有三种类型的弹出框：警告框、确认框和提示框。 警告框如果要确保信息传递给用户，通常会使用警告框。 当警告框弹出时，用户将需要单击“确定”来继续。 语法window.alert(&quot;sometext&quot;); window.alert() 方法可以不带 window 前缀来写。 实例alert(&quot;我是一个警告框！&quot;); 确认框如果您希望用户验证或接受某个东西，则通常使用“确认”框。 当确认框弹出时，用户将不得不单击“确定”或“取消”来继续进行。 如果用户单击“确定”，该框返回 true。如果用户单击“取消”，该框返回 false。 语法window.confirm(&quot;sometext&quot;); window.confirm() 方法可以不带 window 前缀来编写。 实例 123456var r &#x3D; confirm(&quot;请按按钮&quot;);if (r &#x3D;&#x3D; true) &#123; x &#x3D; &quot;您按了确认！&quot;;&#125; else &#123; x &#x3D; &quot;您按了取消！&quot;;&#125; 提示框如果您希望用户在进入页面前输入值，通常会使用提示框。 当提示框弹出时，用户将不得不输入值后单击“确定”或点击“取消”来继续进行。 如果用户单击“确定”，该框返回输入值。如果用户单击“取消”，该框返回 NULL。 语法window.prompt(&quot;sometext&quot;,&quot;defaultText&quot;); window.prompt() 方法可以不带 window 前缀来编写。 实例 1234var person &#x3D; prompt(&quot;请输入您的姓名&quot;, &quot;比尔盖茨&quot;);if (person !&#x3D; null) &#123; document.getElementById(&quot;demo&quot;).innerHTML &#x3D; &quot;你好 &quot; + person + &quot;！今天过的怎么样？&quot;;&#125; 折行如需在弹出框中显示折行，请在反斜杠后面加一个字符 n。 实例 alert(&quot;Hello\\nHow are you?&quot;);","categories":[{"name":"BOM","slug":"BOM","permalink":"http://yoursite.com/categories/BOM/"}],"tags":[{"name":"BOM","slug":"BOM","permalink":"http://yoursite.com/tags/BOM/"}]},{"title":"Timing事件","slug":"07-Timing事件","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:48:00.000Z","comments":true,"path":"2020/04/18/07-Timing事件/","link":"","permalink":"http://yoursite.com/2020/04/18/07-Timing%E4%BA%8B%E4%BB%B6/","excerpt":"前言JavaScript 可以在时间间隔内执行。 这就是所谓的定时事件（ Timing Events）。 timing 事件window 对象允许以指定的时间间隔执行代码。","text":"前言JavaScript 可以在时间间隔内执行。 这就是所谓的定时事件（ Timing Events）。 timing 事件window 对象允许以指定的时间间隔执行代码。 这些时间间隔称为定时事件。 通过 JavaScript 使用的有两个关键的方法： setTimeout(function, milliseconds):在等待指定的毫秒数后执行函数。 setInterval(function, milliseconds)等同于 setTimeout()，但持续重复执行该函数。 setTimeout() 和 setInterval() 都属于 HTML DOM Window 对象的方法。 setTimeout() 方法window.setTimeout(function, milliseconds); window.setTimeout() 方法可以不带 window 前缀来编写。 第一个参数是要执行的函数。 第二个参数指示执行之前的毫秒数。 实例 单击按钮。等待 3 秒，然后页面会提示 “Hello”： 1234567&lt;button onclick&#x3D;&quot;setTimeout(myFunction, 3000)&quot;&gt;试一试&lt;&#x2F;button&gt;&lt;script&gt;function myFunction() &#123; alert(&#39;Hello&#39;); &#125;&lt;&#x2F;script&gt; 如何停止执行？clearTimeout()方法停止执行 setTimeout() 中规定的函数。 window.clearTimeout(timeoutVariable) window.clearTimeout() 方法可以不带 window 前缀来写。 clearTimeout() 使用从 setTimeout() 返回的变量：12myVar &#x3D; setTimeout(function, milliseconds);clearTimeout(myVar); 实例 类似上例，但是添加了“停止”按钮： 123&lt;button onclick&#x3D;&quot;myVar &#x3D; setTimeout(myFunction, 3000)&quot;&gt;试一试&lt;&#x2F;button&gt;&lt;button onclick&#x3D;&quot;clearTimeout(myVar)&quot;&gt;停止执行&lt;&#x2F;button&gt; setInterval() 方法setInterval() 方法在每个给定的时间间隔重复给定的函数。 window.setInterval(function, milliseconds); window.setInterval() 方法可以不带 window 前缀来写。 第一个参数是要执行的函数。 第二个参数每个执行之间的时间间隔的长度。 本例每秒执行一次函数 “myTimer”（就像数字手表）。 实例 显示当前时间： 123456var myVar &#x3D; setInterval(myTimer, 1000); function myTimer() &#123; var d &#x3D; new Date(); document.getElementById(&quot;demo&quot;).innerHTML &#x3D; d.toLocaleTimeString();&#125; 如何停止执行？clearInterval() 方法停止 setInterval() 方法中指定的函数的执行。 window.clearInterval(timerVariable) window.clearInterval() 方法可以不带 window 前缀来写。 clearInterval() 方法使用从 setInterval() 返回的变量：12myVar &#x3D; setInterval(function, milliseconds);clearInterval(myVar); 实例 类似上例，但是我们添加了一个“停止时间”按钮： 1234567891011&lt;p id&#x3D;&quot;demo&quot;&gt;&lt;&#x2F;p&gt;&lt;button onclick&#x3D;&quot;clearInterval(myVar)&quot;&gt;停止时间&lt;&#x2F;button&gt;&lt;script&gt;var myVar &#x3D; setInterval(myTimer, 1000); function myTimer() &#123; var d &#x3D; new Date(); document.getElementById(&quot;demo&quot;).innerHTML &#x3D; d.toLocaleTimeString();&#125;&lt;&#x2F;script&gt;","categories":[{"name":"BOM","slug":"BOM","permalink":"http://yoursite.com/categories/BOM/"}],"tags":[{"name":"BOM","slug":"BOM","permalink":"http://yoursite.com/tags/BOM/"}]},{"title":"字符串的新增方法","slug":"06-字符串的新增方法","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T03:53:06.000Z","comments":true,"path":"2020/04/18/06-字符串的新增方法/","link":"","permalink":"http://yoursite.com/2020/04/18/06-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95/","excerpt":"前言本文主要内容： String.fromCodePoint() String.raw() 实例方法：codePointAt() 实例方法：normalize() 实例方法：includes(), startsWith(), endsWith() 实例方法：repeat() 实例方法：padStart()，padEnd() 实例方法：trimStart()，trimEnd() 实例方法：matchAll()","text":"前言本文主要内容： String.fromCodePoint() String.raw() 实例方法：codePointAt() 实例方法：normalize() 实例方法：includes(), startsWith(), endsWith() 实例方法：repeat() 实例方法：padStart()，padEnd() 实例方法：trimStart()，trimEnd() 实例方法：matchAll() String.fromCodePoint() ES5 提供String.fromCharCode()方法，用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于0xFFFF的字符。 12String.fromCharCode(0x20BB7)&#x2F;&#x2F; &quot;ஷ&quot; 上面代码中，String.fromCharCode()不能识别大于0xFFFF的码点，所以0x20BB7就发生了溢出，最高位2被舍弃了，最后返回码点U+0BB7对应的字符，而不是码点U+20BB7对应的字符。 ES6 提供了String.fromCodePoint()方法，可以识别大于0xFFFF的字符，弥补了String.fromCharCode()方法的不足。在作用上，正好与下面的codePointAt()方法相反。 1234String.fromCodePoint(0x20BB7)&#x2F;&#x2F; &quot;𠮷&quot;String.fromCodePoint(0x78, 0x1f680, 0x79) &#x3D;&#x3D;&#x3D; &#39;x\\uD83D\\uDE80y&#39;&#x2F;&#x2F; true 上面代码中，如果String.fromCodePoint方法有多个参数，则它们会被合并成一个字符串返回。 注意，fromCodePoint方法定义在String对象上，而codePointAt方法定义在字符串的实例对象上。 String.raw()ES6 还为原生的 String 对象，提供了一个raw()方法。该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。 12345String.raw&#96;Hi\\n$&#123;2+3&#125;!&#96;&#x2F;&#x2F; 实际返回 &quot;Hi\\\\n5!&quot;，显示的是转义后的结果 &quot;Hi\\n5!&quot;String.raw&#96;Hi\\u000A!&#96;;&#x2F;&#x2F; 实际返回 &quot;Hi\\\\u000A!&quot;，显示的是转义后的结果 &quot;Hi\\u000A!&quot; 如果原字符串的斜杠已经转义，那么String.raw()会进行再次转义。 1234String.raw&#96;Hi\\\\n&#96;&#x2F;&#x2F; 返回 &quot;Hi\\\\\\\\n&quot;String.raw&#96;Hi\\\\n&#96; &#x3D;&#x3D;&#x3D; &quot;Hi\\\\\\\\n&quot; &#x2F;&#x2F; true String.raw()方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。 String.raw()本质上是一个正常的函数，只是专用于模板字符串的标签函数。如果写成正常函数的形式，它的第一个参数，应该是一个具有raw属性的对象，且raw属性的值应该是一个数组，对应模板字符串解析后的值。 123&#x2F;&#x2F; &#96;foo$&#123;1 + 2&#125;bar&#96;&#x2F;&#x2F; 等同于String.raw(&#123; raw: [&#39;foo&#39;, &#39;bar&#39;] &#125;, 1 + 2) &#x2F;&#x2F; &quot;foo3bar&quot; 上面代码中，String.raw()方法的第一个参数是一个对象，它的raw属性等同于原始的模板字符串解析后得到的数组。 作为函数，String.raw()的代码实现基本如下。 12345678910String.raw &#x3D; function (strings, ...values) &#123; let output &#x3D; &#39;&#39;; let index; for (index &#x3D; 0; index &lt; values.length; index++) &#123; output +&#x3D; strings.raw[index] + values[index]; &#125; output +&#x3D; strings.raw[index] return output;&#125; 实例方法：codePointAt()JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode 码点大于0xFFFF的字符），JavaScript 会认为它们是两个字符。 1234567var s &#x3D; &quot;𠮷&quot;;s.length &#x2F;&#x2F; 2s.charAt(0) &#x2F;&#x2F; &#39;&#39;s.charAt(1) &#x2F;&#x2F; &#39;&#39;s.charCodeAt(0) &#x2F;&#x2F; 55362s.charCodeAt(1) &#x2F;&#x2F; 57271 上面代码中，汉字“𠮷”（注意，这个字不是“吉祥”的“吉”）的码点是0x20BB7，UTF-16 编码为0xD842 0xDFB7（十进制为55362 57271），需要4个字节储存。对于这种4个字节的字符，JavaScript 不能正确处理，字符串长度会误判为2，而且charAt()方法无法读取整个字符，charCodeAt()方法只能分别返回前两个字节和后两个字节的值。 ES6 提供了codePointAt()方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。 123456let s &#x3D; &#39;𠮷a&#39;;s.codePointAt(0) &#x2F;&#x2F; 134071s.codePointAt(1) &#x2F;&#x2F; 57271s.codePointAt(2) &#x2F;&#x2F; 97 codePointAt()方法的参数，是字符在字符串中的位置（从 0 开始）。上面代码中，JavaScript 将“𠮷a”视为三个字符，codePointAt方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点 134071（即十六进制的20BB7）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，codePointAt()方法的结果与charCodeAt()方法相同。 总之，codePointAt()方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与charCodeAt()方法相同。 codePointAt()方法返回的是码点的十进制值，如果想要十六进制的值，可以使用toString()方法转换一下。 1234let s &#x3D; &#39;𠮷a&#39;;s.codePointAt(0).toString(16) &#x2F;&#x2F; &quot;20bb7&quot;s.codePointAt(2).toString(16) &#x2F;&#x2F; &quot;61&quot; 你可能注意到了，codePointAt()方法的参数，仍然是不正确的。比如，上面代码中，字符a在字符串s的正确位置序号应该是 1，但是必须向codePointAt()方法传入 2。解决这个问题的一个办法是使用for…of循环，因为它会正确识别 32 位的 UTF-16 字符。 123456let s &#x3D; &#39;𠮷a&#39;;for (let ch of s) &#123; console.log(ch.codePointAt(0).toString(16));&#125;&#x2F;&#x2F; 20bb7&#x2F;&#x2F; 61 另一种方法也可以，使用扩展运算符（…）进行展开运算。 1234567891011121314let arr &#x3D; [...&#39;𠮷a&#39;]; &#x2F;&#x2F; arr.length &#x3D;&#x3D;&#x3D; 2arr.forEach( ch &#x3D;&gt; console.log(ch.codePointAt(0).toString(16)));&#x2F;&#x2F; 20bb7&#x2F;&#x2F; 61codePointAt()方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。function is32Bit(c) &#123; return c.codePointAt(0) &gt; 0xFFFF;&#125;is32Bit(&quot;𠮷&quot;) &#x2F;&#x2F; trueis32Bit(&quot;a&quot;) &#x2F;&#x2F; false 实例方法：normalize()许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode 提供了两种方法。一种是直接提供带重音符号的字符，比如Ǒ（\\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如O（\\u004F）和ˇ（\\u030C）合成Ǒ（\\u004F\\u030C）。 这两种表示方法，在视觉和语义上都等价，但是 JavaScript 不能识别。 1234&#39;\\u01D1&#39;&#x3D;&#x3D;&#x3D;&#39;\\u004F\\u030C&#39; &#x2F;&#x2F;false&#39;\\u01D1&#39;.length &#x2F;&#x2F; 1&#39;\\u004F\\u030C&#39;.length &#x2F;&#x2F; 2 上面代码表示，JavaScript 将合成字符视为两个字符，导致两种表示方法不相等。 ES6 提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。 12&#39;\\u01D1&#39;.normalize() &#x3D;&#x3D;&#x3D; &#39;\\u004F\\u030C&#39;.normalize()&#x2F;&#x2F; true&#96; normalize方法可以接受一个参数来指定normalize的方式，参数的四个可选值如下。 NFC，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。 NFD，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。 NFKC，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize方法不能识别中文。） NFKD，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。12&#39;\\u004F\\u030C&#39;.normalize(&#39;NFC&#39;).length &#x2F;&#x2F; 1 &quot;Ǒ&quot;&#39;\\u004F\\u030C&#39;.normalize(&#39;NFD&#39;).length &#x2F;&#x2F; 2 上面代码表示，NFC参数返回字符的合成形式，NFD参数返回字符的分解形式。 不过，normalize方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过 Unicode 编号区间判断。 实例方法：includes(), startsWith(), endsWith()传统上，JavaScript 只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。 includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 12345let s &#x3D; &#39;Hello world!&#39;;s.startsWith(&#39;Hello&#39;) &#x2F;&#x2F; trues.endsWith(&#39;!&#39;) &#x2F;&#x2F; trues.includes(&#39;o&#39;) &#x2F;&#x2F; true 这三个方法都支持第二个参数，表示开始搜索的位置。 12345let s &#x3D; &#39;Hello world!&#39;;s.startsWith(&#39;world&#39;, 6) &#x2F;&#x2F; trues.endsWith(&#39;Hello&#39;, 5) &#x2F;&#x2F; trues.includes(&#39;Hello&#39;, 6) &#x2F;&#x2F; false 上面代码表示，使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。 实例方法：repeat()repeat方法返回一个新字符串，表示将原字符串重复n次。 123&#39;x&#39;.repeat(3) &#x2F;&#x2F; &quot;xxx&quot;&#39;hello&#39;.repeat(2) &#x2F;&#x2F; &quot;hellohello&quot;&#39;na&#39;.repeat(0) &#x2F;&#x2F; &quot;&quot; 参数如果是小数，会被取整。 1234567&#39;na&#39;.repeat(2.9) &#x2F;&#x2F; &quot;nana&quot;如果repeat的参数是负数或者Infinity，会报错。&#39;na&#39;.repeat(Infinity)&#x2F;&#x2F; RangeError&#39;na&#39;.repeat(-1)&#x2F;&#x2F; RangeError 但是，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于-0，repeat视同为 0。 12345678&#39;na&#39;.repeat(-0.9) &#x2F;&#x2F; &quot;&quot;参数NaN等同于 0。&#39;na&#39;.repeat(NaN) &#x2F;&#x2F; &quot;&quot;如果repeat的参数是字符串，则会先转换成数字。&#39;na&#39;.repeat(&#39;na&#39;) &#x2F;&#x2F; &quot;&quot;&#39;na&#39;.repeat(&#39;3&#39;) &#x2F;&#x2F; &quot;nanana&quot; 实例方法：padStart()，padEnd()ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。 12345&#39;x&#39;.padStart(5, &#39;ab&#39;) &#x2F;&#x2F; &#39;ababx&#39;&#39;x&#39;.padStart(4, &#39;ab&#39;) &#x2F;&#x2F; &#39;abax&#39;&#39;x&#39;.padEnd(5, &#39;ab&#39;) &#x2F;&#x2F; &#39;xabab&#39;&#39;x&#39;.padEnd(4, &#39;ab&#39;) &#x2F;&#x2F; &#39;xaba&#39; 上面代码中，padStart()和padEnd()一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。 如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。 12&#39;xxx&#39;.padStart(2, &#39;ab&#39;) &#x2F;&#x2F; &#39;xxx&#39;&#39;xxx&#39;.padEnd(2, &#39;ab&#39;) &#x2F;&#x2F; &#39;xxx&#39; 如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。 12&#39;abc&#39;.padStart(10, &#39;0123456789&#39;)&#x2F;&#x2F; &#39;0123456abc&#39; 如果省略第二个参数，默认使用空格补全长度。 12&#39;x&#39;.padStart(4) &#x2F;&#x2F; &#39; x&#39;&#39;x&#39;.padEnd(4) &#x2F;&#x2F; &#39;x &#39; padStart()的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串。 123&#39;1&#39;.padStart(10, &#39;0&#39;) &#x2F;&#x2F; &quot;0000000001&quot;&#39;12&#39;.padStart(10, &#39;0&#39;) &#x2F;&#x2F; &quot;0000000012&quot;&#39;123456&#39;.padStart(10, &#39;0&#39;) &#x2F;&#x2F; &quot;0000123456&quot; 另一个用途是提示字符串格式。 12&#39;12&#39;.padStart(10, &#39;YYYY-MM-DD&#39;) &#x2F;&#x2F; &quot;YYYY-MM-12&quot;&#39;09-12&#39;.padStart(10, &#39;YYYY-MM-DD&#39;) &#x2F;&#x2F; &quot;YYYY-09-12&quot; 实例方法：trimStart()，trimEnd()ES2019 对字符串实例新增了trimStart()和trimEnd()这两个方法。它们的行为与trim()一致，trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。 12345const s &#x3D; &#39; abc &#39;;s.trim() &#x2F;&#x2F; &quot;abc&quot;s.trimStart() &#x2F;&#x2F; &quot;abc &quot;s.trimEnd() &#x2F;&#x2F; &quot; abc&quot; 上面代码中，trimStart()只消除头部的空格，保留尾部的空格。trimEnd()也是类似行为。 除了空格键，这两个方法对字符串头部（或尾部）的 tab 键、换行符等不可见的空白符号也有效。 浏览器还部署了额外的两个方法，trimLeft()是trimStart()的别名，trimRight()是trimEnd()的别名。 实例方法：matchAll()matchAll()方法返回一个正则表达式在当前字符串的所有匹配，详见《正则的扩展》的一章。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"流程控制：选择结构(if和switch)","slug":"07-流程控制语句：选择结构（if和switch）","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:47:34.000Z","comments":true,"path":"2020/04/18/07-流程控制语句：选择结构（if和switch）/","link":"","permalink":"http://yoursite.com/2020/04/18/07-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%EF%BC%9A%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84%EF%BC%88if%E5%92%8Cswitch%EF%BC%89/","excerpt":"代码块用{}包围起来的代码，就是代码块。 JS中的代码块，只具有分组的作用，没有其他的用途。","text":"代码块用{}包围起来的代码，就是代码块。 JS中的代码块，只具有分组的作用，没有其他的用途。 代码块中的内容，在外部是完全可见的。举例： 1234567&#123; var a = 2; alert(\"qianguyihao\"); console.log(\"永不止步\");&#125;console.log(\"a = \" + a); 打印结果：（可以看出，虽然变量 a 是定义在代码块中的，但是在外部依然可以访问） 12永不止步a &#x3D; 2 流程控制语句在一个程序执行的过程中，各条语句的执行顺序对程序的结果是有直接影响的。所以，我们必须清楚每条语句的执行流程。而且，很多时候我们要通过控制语句的执行顺序来实现我们要完成的功能。 流程控制语句分类 顺序结构 选择结构：if语句、switch语句 循环结构：while语句、for语句 顺序结构按照代码的先后顺序，依次执行。 if语句if语句有以下三种。 1、条件判断语句 条件成立才执行。如果条件不成立，那就什么都不做。 格式： 1234if (条件表达式) &#123; // 条件为真时，做的事情&#125; 2、条件分支语句格式1： 1234567if (条件表达式) &#123; // 条件为真时，做的事情&#125; else &#123; // 条件为假时，做的事情&#125; 格式2：（多分支的if语句） 123456789101112if (条件表达式1) &#123; // 条件1为真时，做的事情&#125; else if (条件表达式2) &#123; // 条件1不满足，条件2满足时，做的事情&#125; else if (条件表达式3) &#123; // 条件1、2不满足，条件3满足时，做的事情&#125; else &#123; // 条件1、2、3都不满足时，做的事情&#125; 以上所有的语句体中，只执行其中一个。 做个题目123456789101112131415根据BMI（身体质量指数）显示一个人的体型。BMI指数，就是体重、身高的一个计算公式。公式是：BMI &#x3D;体重÷身高的平方比如，老师的体重是81.6公斤，身高是1.71米。那么老师的BMI就是 81.6 ÷ 1.712 等于 27.906022365856163过轻：低于18.5正常：18.5-24.99999999过重：25-27.9999999肥胖：28-32非常肥胖, 高于32用JavaScript开发一个程序，让用户先输入自己的体重，然后输入自己的身高（弹出两次prompt框）。计算它的BMI，根据上表，弹出用户的身体情况。比如“过轻” 、 “正常” 、“过重” 、 “肥胖” 、“非常肥胖”。 答案： 写法1： 1234567891011121314151617//第一步，输入身高和体重var height = parseFloat(prompt(\"请输入身高，单位是米\"));var weight = parseFloat(prompt(\"请输入体重，单位是公斤\"));//第二步，计算BMI指数var BMI = weight / Math.pow(height, 2);//第三步，if语句来判断。注意跳楼现象if (BMI &lt; 18.5) &#123; alert(\"偏瘦\");&#125; else if (BMI &lt; 25) &#123; alert(\"正常\");&#125; else if (BMI &lt; 28) &#123; alert(\"过重\");&#125; else if (BMI &lt;= 32) &#123; alert(\"肥胖\");&#125; else &#123; alert(\"非常肥胖\");&#125; 写法2： 1234567891011121314151617//第一步，输入身高和体重var height = parseFloat(prompt(\"请输入身高，单位是米\"));var weight = parseFloat(prompt(\"请输入体重，单位是公斤\"));//第二步，计算BMI指数var BMI = weight / Math.pow(height, 2);//第三步，if语句来判断。注意跳楼现象if (BMI &gt; 32) &#123; alert(\"非常肥胖\");&#125; else if (BMI &gt;= 28) &#123; alert(\"肥胖\");&#125; else if (BMI &gt;= 25) &#123; alert(\"过重\");&#125; else if (BMI &gt;= 18.5) &#123; alert(\"正常\")&#125; else &#123; alert(\"偏瘦\");&#125; if语句的嵌套我们通过下面这个例子来引出if语句的嵌套。 1234一个加油站为了鼓励车主多加油，所以加的多有优惠。92号汽油，每升6元；如果大于等于20升，那么每升5.9；97号汽油，每升7元；如果大于等于30升，那么每升6.95编写JS程序，用户输入自己的汽油编号，然后输入自己加多少升，弹出价格。 代码实现如下： 123456789101112131415161718192021222324 //第一步，输入var bianhao = parseInt(prompt(\"您想加什么油？填写92或者97\"));var sheng = parseFloat(prompt(\"您想加多少升？\"));//第二步，判断if (bianhao == 92) &#123; //编号是92的时候做的事情 if (sheng &gt;= 20) &#123; var price = sheng * 5.9; &#125; else &#123; var price = sheng * 6; &#125;&#125; else if (bianhao == 97) &#123; //编号是97的时候做的事情 if (sheng &gt;= 30) &#123; var price = sheng * 6.95; &#125; else &#123; var price = sheng * 7; &#125;&#125; else &#123; alert(\"不好意思，没有这个编号的汽油！\");&#125;alert(\"价格是\" + price); switch语句（条件分支语句）switch语句也叫条件分支语句。 格式： 12345678910111213141516switch(表达式) &#123; case 值1： 语句体1; break; case 值2： 语句体2; break; ... ... default： 语句体 n+1; break;&#125; 注意： switch 可以理解为“开关、转换” 。case 可以理解为“案例、选项”。 switch 后面的括号里可以是表达式或者值， 通常是一个变量（通常做法是：先把表达式或者值存放到变量中）。 JS 是属于弱类型语言，case 后面的值1、值2可以是 &#39;a&#39;、6、true 等任意数据类型的值，也可以是表达式。 switch语句的执行流程执行流程如下： （1）首先，计算出表达式的值，和case依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结束。 （2）然后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分。 switch 语句的结束条件【非常重要】 情况a：遇到break就结束，而不是遇到default就结束。（因为break在此处的作用就是退出switch语句） 情况b：执行到程序的末尾就结束。 我们来看下面的两个例子就明白了。 case穿透的问题switch 语句中的break可以省略，但一般不建议（对于新手而言）。否则结果可能不是你想要的，会出现一个现象：case穿透。 举例1：（case穿透的情况） 1234567891011121314151617181920212223242526272829var num = 4;//switch判断语句switch (num) &#123; case 1: console.log(\"星期一\"); break; case 2: console.log(\"星期二\"); break; case 3: console.log(\"星期三\"); break; case 4: console.log(\"星期四\"); //break; case 5: console.log(\"星期五\"); //break; case 6: console.log(\"星期六\"); break; case 7: console.log(\"星期日\"); break; default: console.log(\"你输入的数据有误\"); break;&#125; 上方代码的运行结果，可能会令你感到意外： 123星期四星期五星期六 上方代码的解释：因为在case 4和case 5中都没有break，那语句走到case 6的break才会停止。 举例2： 1234567891011121314151617//switch判断语句var number = 5;switch (number) &#123; default: console.log(\"我是defaul语句\"); // break; case (2): console.log(\"第二个呵呵:\" + number); //break; case (3): console.log(\"第三个呵呵:\" + number); break; case (4): console.log(\"第四个呵呵:\" + number); break;&#125; 上方代码的运行结果，你也许会意外： 123我是defaul语句第二个呵呵:5第三个呵呵:5 上方代码的解释：代码走到 default 时，因为没有遇到 break，所以会继续往下走，直到遇见 break 或者走到程序的末尾。 从这个例子可以看出：switch 语句的结束与 default 的顺序无关。 switch 语句的实战举例：替换 if 语句我们实战开发中，经常需要根据接口的返回码 retCode ，来让前端做不同的展示。 这种场景是业务开发中经常出现的，请一定要掌握。然而，很多人估计会这么写： 写法1：（不推荐。这种写法太挫了） 12345678910111213141516171819202122let retCode = 1003; // 返回码 retCode 的值可能有很多种情况if (retCode == 0) &#123; alert('接口联调成功');&#125; else if (retCode == 101) &#123; alert('活动不存在');&#125; else if (retCode == 103) &#123; alert('活动未开始');&#125; else if (retCode == 104) &#123; alert('活动已结束');&#125; else if (retCode == 1001) &#123; alert('参数错误');&#125; else if (retCode == 1002) &#123; alert('接口频率限制');&#125; else if (retCode == 1003) &#123; alert('未登录');&#125; else if (retCode == 1004) &#123; alert('（风控用户）提示 活动太火爆啦~军万马都在挤，请稍后再试');&#125; else &#123; // 其他异常返回码 alert('系统君失联了，请稍候再试');&#125; 如果你是按照上面的 if else的方式来写各种条件判断，说明你的代码水平太初级了，会被人喷的，千万不要这么写。那要怎么改进呢？继续往下看。 写法2：（推荐。通过 return 的方式，将上面的写法进行改进） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950let retCode = 1003; // 返回码 retCode 的值可能有很多种情况handleRetCode(retCode);// 方法：根据接口不同的返回码，处理前端不同的显示状态function handleRetCode(retCode) &#123; if (retCode == 0) &#123; alert('接口联调成功'); return; &#125; if (retCode == 101) &#123; alert('活动不存在'); return; &#125; if (retCode == 103) &#123; alert('活动未开始'); return; &#125; if (retCode == 104) &#123; alert('活动已结束'); return; &#125; if (retCode == 1001) &#123; alert('参数错误'); return; &#125; if (retCode == 1002) &#123; alert('接口频率限制'); return; &#125; if (retCode == 1003) &#123; alert('未登录'); return; &#125; if (retCode == 1004) &#123; alert('（风控用户）提示 活动太火爆啦~军万马都在挤，请稍后再试'); return; &#125; // 其他异常返回码 alert('系统君失联了，请稍候再试'); return;&#125; 上面的写法2，是比较推荐的写法：直接通过 return 的方式，让 function 里的代码不再继续往下走，这就达到目的了。对了，因为要用到 return ，所以需要单独封装到一个 function 里面。 如果你以后看到有前端小白采用的是写法1，请一定要把写法2传授给他：不需要那么多的 if else，直接用 return 返回就行了。 写法3：（推荐。将 if else 改为 switch） 123456789101112131415161718192021222324252627282930313233343536373839let retCode = 1003; // 返回码 retCode 的值可能有很多种情况switch (retCode) &#123; case 0: alert('接口联调成功'); break; case 101: alert('活动不存在'); break; case 103: alert('活动未开始'); break; case 104: alert('活动已结束'); break; case 1001: alert('参数错误'); break; case 1002: alert('接口频率限制'); break; case 1003: alert('未登录'); break; case 1004: alert('（风控用户）提示 活动太火爆啦~军万马都在挤，请稍后再试'); break; // 其他异常返回码 default: alert('系统君失联了，请稍候再试'); break;&#125; 在实战开发中，方式3是非常推荐的写法，甚至比方式2还要好。我们尽量不要写太多的 if 语句，避免代码嵌套过深。 switch 语句的优雅写法：适时地去掉 break我们先来看看下面这段代码：（不推荐） 12345678910111213141516171819202122232425262728293031323334let day = 2;switch (day) &#123; case 1: console.log('work'); break; case 2: console.log('work'); break; case 3: console.log('work'); break; case 4: console.log('work'); break; case 5: console.log('work'); break; case 6: console.log('relax'); break; case 7: console.log('relax'); break; default: break;&#125; 上面的代码，咋一看，好像没啥毛病。但你有没有发现，重复代码太多了？ 实战开发中，凡是有重复的地方，我们都必须要想办法简化。写代码就是在不断重构的过程。 上面的代码，可以改进如下：（推荐，非常优雅） 1234567891011121314151617181920let day = 2;switch (day) &#123; case 1: case 2: case 3: case 4: case 5: console.log('work'); break; // 在这里放一个 break case 6: case 7: console.log('relax'); break; // 在这里放一个 break default: break;&#125;&#125; 你没看错，就是上面的这种写法，能达到同样的效果，非常优雅。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"运算符","slug":"06-运算符","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T03:53:16.000Z","comments":true,"path":"2020/04/18/06-运算符/","link":"","permalink":"http://yoursite.com/2020/04/18/06-%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"运算符的定义和分类运算符的定义运算符：也叫操作符，是一种符号。通过运算符可以对一个或多个值进行运算，并获取运算结果。 表达式：由数字、运算符、变量的组合（组成的式子）。 表达式最终都会有一个运算结果，我们将这个结果称为表达式的返回值。 比如：+、*、/、( 都是运算符，而（3+5）/2则是表达式。 比如：typeof 就是运算符，可以来获得一个值的类型。它会将该值的类型以字符串的形式返回，返回值可以是 number string boolean undefined object。","text":"运算符的定义和分类运算符的定义运算符：也叫操作符，是一种符号。通过运算符可以对一个或多个值进行运算，并获取运算结果。 表达式：由数字、运算符、变量的组合（组成的式子）。 表达式最终都会有一个运算结果，我们将这个结果称为表达式的返回值。 比如：+、*、/、( 都是运算符，而（3+5）/2则是表达式。 比如：typeof 就是运算符，可以来获得一个值的类型。它会将该值的类型以字符串的形式返回，返回值可以是 number string boolean undefined object。 运算符的分类JS 中的运算符，分类如下： 算数运算符 自增/自减运算符 一元运算符 逻辑运算符 赋值运算符 比较运算符 三元运算符（条件运算符） 下面来逐一讲解。 算数运算符算术运算符：用于执行两个变量或值的算术运算。 常见的算数运算符有以下几种： 运算符 描述 + 加、字符串连接 - 减 * 乘 / 除 % 获取余数（取余、取模） 求余的举例： 假设用户输入345，怎么分别得到3、4、5这三个数呢？ 答案： 12345得到3的方法：345 除以100，得到3.45然后取整，得到3。即：parseInt(345&#x2F;100)得到4的方法：345 除以100，余数是45，除以10，得到4.5，取整。即：parseInt(345 % 100 &#x2F; 10)得到5的方法：345 除以10，余数就是5。即：345 % 10 算数运算符的运算规则（1）先算乘除、后算加减。 （2）小括号( )：能够影响计算顺序，且可以嵌套。没有中括号、没有大括号，只有小括号。 （3）百分号：取余。只关心余数。 举例1：(取余) 1console.log(3 % 5); 输出结果为3。 举例2：（注意运算符的优先级） 1var a = 1 + 2 * 3 % 4 / 3; 结果分析： 原式 = 1 + 6 % 4 / 3 = 1 + 2 / 3 = 1.66666666666666 补充：关于算数运算符的注意事项，详见上一篇文章里的“数据类型转换”的知识点。 浮点数运算的精度问题浮点数值的最高精度是 17 位小数，但在进行算术计算时，会丢失精度，导致计算不够准确。比如： 123console.log(0.1 + 0.2); // 运算结果不是 0.3，而是 0.30000000000000004console.log(0.07 * 100); // 运算结果不是 7，而是 7.000000000000001 因此，不要直接判断两个浮点数是否相等。 自增和自减自增 ++自增分成两种：a++和++a。 （1）一个变量自增以后，原变量的值会立即自增1。也就是说，无论是 a++ 还是++a，都会立即使原变量的值自增1。 （2）我们要注意的是：a是变量，而a++和++a是表达式。 那这两种自增，有啥区别呢？区别是：a++ 和 ++a的值不同：（也就是说，表达式的值不同） a++这个表达式的值等于原变量的值（a自增前的值）。你可以这样理解：先把 a 的值赋值给表达式，然后 a 再自增。 ++a这个表达式的值等于新值 （a自增后的值）。 你可以这样理解：a 先自增，然后再把自增后的值赋值给表达式。 自减 --原理同上。 开发时，大多使用后置的自增/自减，并且代码独占一行，例如：num++，或者 num--。 代码举例12345678910111213141516171819var n1 = 10;var n2 = 20;var result1 = n1++;console.log(n1); // 11console.log(result1); // 10result = ++n1;console.log(n1); //12console.log(result); //12var result2 = n2--;console.log(n2); // 19console.log(result2); // 20result2 = --n2;console.log(n2); // 18console.log(result2); // 18 一元运算符一元运算符，只需要一个操作数。 常见的一元运算符如下。 typeoftypeof就是典型的一元运算符，因为后面只跟一个操作数。 举例如下： 12var a = '123';console.log(typeof a); // 打印结果：string 正号 +（1）正号不会对数字产生任何影响。比如说，2和+2是一样的。 （2）我们可以对一个其他的数据类型使用+，来将其转换为number【重要的小技巧】。比如： 1234567891011var a = true;a = +a; // 注意这行代码的一元运算符操作console.log('a：' + a);console.log(typeof a);console.log('-----------------');var b = '18';b = +b; // 注意这行代码的一元运算符操作console.log('b：' + b);console.log(typeof b); 打印结果： 1234567a：1number-----------------b：18number 负号 -负号可以对数字进行取反。 逻辑运算符逻辑运算符有三个： &amp;&amp; 与（且）：两个都为真，结果才为真。 || 或：只要有一个是真，结果就是真。 ! 非：对一个布尔值进行取反。 连比的写法： 来看看逻辑运算符连比的写法。 举例1： 1console.log(3 &lt; 2 &amp;&amp; 2 &lt; 4); 输出结果为false。 举例2：（判断一个人的年龄是否在18~60岁之间） 12var a = prompt(\"请输入您的年龄\");alert(a&gt;=18 &amp;&amp; a&lt;= 65); PS：上面的这个a&gt;=18 &amp;&amp; a&lt;= 65千万别想当然的写成18&lt;= a &lt;= 65，没有这种语法。 注意事项（1）能参与逻辑运算的，都是布尔值。 （2）JS中的&amp;&amp;属于短路的与，如果第一个值为false，则不会看第二个值。举例： 12345//第一个值为true，会检查第二个值true &amp;&amp; alert(\"看我出不出来！！\"); // 可以弹出 alert 框//第一个值为false，不会检查第二个值false &amp;&amp; alert(\"看我出不出来！！\"); // 不会弹出 alert 框 （3）JS中的||属于短路的或，如果第一个值为true，则不会看第二个值。举例： （4）如果对非布尔值进行逻辑运算，则会先将其转换为布尔值，然后再操作。举例： 12345var a = 10;a = !a;console.log(a); // falseconsole.log(typeof a); // boolean 上面的例子，我们可以看到，对非布尔值进行!操作之后，返回结果为布尔值。 非布尔值的与或运算【重要】 之所以重要，是因为在实际开发中，我们经常用这种代码做容错处理或者兜底处理。 非布尔值进行与或运算时，会先将其转换为布尔值，然后再运算，但返回结果是原值。比如说： 12var result = 5 &amp;&amp; 6; // 运算过程：true &amp;&amp; true;console.log('result：' + result); // 打印结果：6（也就是说最后面的那个值。） 上方代码可以看到，虽然运算过程为布尔值的运算，但返回结果是原值。 那么，返回结果是哪个原值呢？我们来看一下。 与运算的返回结果：（以两个非布尔值的运算为例） 如果第一个值为false，则直接返回第一个值；不会再往后执行。 如果第一个值为true，则返回第二个值（如果所有的值都为true，则返回的是最后一个值）。 或运算的返回结果：（以两个非布尔值的运算为例） 如果第一个值为true，则直接返回第一个值；不会再往后执行。 如果第一个值为false，则返回第二个值（（如果所有的值都为false，则返回的是最后一个值）。 实际开发中，我们经常是这样来做「容错处理」的： 当成功调用一个接口后，返回的数据为 result 对象。这个时候，我们用变量 a 来接收 result 里的图片资源。通常的写法是这样的： 123if (result.resultCode == 0) &#123; var a = result &amp;&amp; result.data &amp;&amp; result.data.imgUrl || 'http://img.smyhvae.com/20160401_01.jpg';&#125; 上方代码的意思是，获取返回结果中的result.data.imgUrl这个图片资源；如果返回结果中没有 result.data.imgUrl 这个字段，就用 http://img.smyhvae.com/20160401_01.jpg 作为兜底图片。这种写法，在实际开发中经常用到。 赋值运算符可以将符号右侧的值赋值给符号左侧的变量。 举例： = 直接赋值。比如 var a = 5 +=。a += 5 等价于 a = a + 5 -=。a -= 5 等价于 a = a - 5 *=。a *= 5 等价于 a = a * 5 /=。a /= 5 等价于 a = a / 5 %=。a %= 5 等价于 a = a % 5 比较运算符比较运算符可以比较两个值之间的大小关系，如果关系成立它会返回true，如果关系不成立则返回false。 比较运算符有很多种，比如： 12345678&gt; 大于号&lt; 小于号&gt;&#x3D; 大于或等于&lt;&#x3D; 小于或等于&#x3D;&#x3D; 等于&#x3D;&#x3D;&#x3D; 全等于!&#x3D; 不等于!&#x3D;&#x3D; 不全等于 比较运算符，得到的结果都是布尔值：要么是true，要么是false。 举例如下： 1var result = 5 &gt; 10; // false 非数值的比较（1）对于非数值进行比较时，会将其转换为数字然后再比较。 举例如下： 12345678910console.log(1 &gt; true); //falseconsole.log(1 &gt;= true); //trueconsole.log(1 &gt; \"0\"); //true//console.log(10 &gt; null); //true//任何值和NaN做任何比较都是falseconsole.log(10 &lt;= \"hello\"); //falseconsole.log(true &gt; false); //true （2）特殊情况：如果符号两侧的值都是字符串时，不会将其转换为数字进行比较。比较两个字符串时，比较的是字符串的Unicode编码。【非常重要，这里是个大坑，很容易踩到】 比较字符编码时，是一位一位进行比较。如果两位一样，则比较下一位。 比如说，当你尝试去比较&quot;123&quot;和&quot;56&quot;这两个字符串时，你会发现，字符串”56”竟然比字符串”123”要大。也就是说，下面这样代码的打印结果，其实是true:（这个我们一定要注意，在日常开发中，很容易忽视） 12// 比较两个字符串时，比较的是字符串的字符编码，所以可能会得到不可预期的结果console.log(\"56\" &gt; \"123\"); // true 因此：当我们在比较两个字符串型的数字时，一定一定要先转型再比较大小，比如 parseInt()。 （3）任何值和NaN做任何比较都是false。 ==符号的强调注意==这个符号，它是判断是否等于，而不是赋值。 （1）==这个符号，还可以验证字符串是否相同。例如： 1console.log(\"我爱你中国\" == \"我爱你中国\"); // 输出结果为true （2）==这个符号并不严谨，会做隐式转换，将不同的数据类型，转为相同类型进行比较（大部分情况下，都是转换为数字）。例如： 12345console.log(\"6\" == 6); // 打印结果：true。这里的字符串\"6\"会先转换为数字6，然后再进行比较console.log(true == \"1\"); // 打印结果：trueconsole.log(0 == -0); // 打印结果：trueconsole.log(null == 0); // 打印结果：false （3）undefined 衍生自 null，所以这两个值做相等判断时，会返回true。 1console.log(undefined == null); //打印结果：true。 （4）NaN不和任何值相等，包括他本身。 12console.log(NaN == NaN); //falseconsole.log(NaN === NaN); //false 问题：那如果我想判断 b的值是否为NaN，该怎么办呢？ 答案：可以通过isNaN()函数来判断一个值是否是NaN。举例： 1console.log(isNaN(b)); 如上方代码所示，如果 b 为 NaN，则返回true；否则返回false。 ===全等符号的强调全等在比较时，不会做类型转换。如果要保证绝对等于（完全等于），即数值和类型完全相等，我们就要用三个等号===。例如： 12console.log(\"6\" === 6); //falseconsole.log(6 === 6); //true 上述内容分析出： ==两个等号，不严谨，”6”和6是true。 ===三个等号，严谨，”6”和6是false。 另外还有：==的反面是!=，===的反面是!==。例如： 123console.log(3 != 8); //trueconsole.log(3 != \"3\"); //false，因为3==\"3\"是true，所以反过来就是false。console.log(3 !== \"3\"); //true，应为3===\"3\"是false，所以反过来是true。 三元运算符三元运算符也叫条件运算符。 语法： 1条件表达式 ? 语句1 : 语句2; 执行的流程： 条件运算符在执行时，首先对条件表达式进行求值： 如果该值为true，则执行语句1，并返回执行结果 如果该值为false，则执行语句2，并返回执行结果 如果条件的表达式的求值结果是一个非布尔值，会将其转换为布尔值然后再运算。 运算符的优先级运算符的优先级如下：（优先级从高到低） .、[]、new () ++、-- !、~、+（单目）、-（单目）、typeof、void、delete %、*、/ +（双目）、-（双目） &lt;&lt;、&gt;&gt;、&gt;&gt;&gt; 关系运算符：&lt;、&lt;=、&gt;、&gt;= ==、!==、===、!== &amp; ^ | &amp;&amp; || ?: =、+=、-=、*=、/=、%=、&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;=、&amp;=、^=、|= , 注意：逻辑与 &amp;&amp; 比逻辑或 || 的优先级更高。 备注：你在实际写代码的时候，如果不清楚哪个优先级更高，可以把括号运用上。 Unicode 编码 这一段中，我们来讲引申的内容：Unicode编码的使用。 各位同学可以先在网上查一下“Unicode 编码表”。 1、在字符串中可以使用转义字符输入Unicode编码。格式如下： 1\\u四位编码 举例如下： 12console.log(\"\\u2600\"); // 这里的 2600 采用的是16进制console.log(\"\\u2602\"); // 这里的 2602 采用的是16进制。 2、我们还可以在 HTML 网页中使用Unicode编码。格式如下： 1&amp;#四位编码; PS：我们知道，Unicode编码采用的是16进制，但是，这里的编码需要使用10进制。 举例如下： 1&lt;h1 style=\"font-size: 100px;\"&gt;&amp;#9860;&lt;/h1&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"正则的拓展","slug":"07-正则的扩展","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:47:24.000Z","comments":true,"path":"2020/04/18/07-正则的扩展/","link":"","permalink":"http://yoursite.com/2020/04/18/07-%E6%AD%A3%E5%88%99%E7%9A%84%E6%89%A9%E5%B1%95/","excerpt":"前言本文主要内容： RegExp 构造函数 字符串的正则方法 u 修饰符 RegExp.prototype.unicode 属性 y 修饰符 RegExp.prototype.sticky 属性 RegExp.prototype.flags 属性 s 修饰符：dotAll 模式 后行断言 Unicode 属性类 具名组匹配 正则匹配索引 String.prototype.matchAll()","text":"前言本文主要内容： RegExp 构造函数 字符串的正则方法 u 修饰符 RegExp.prototype.unicode 属性 y 修饰符 RegExp.prototype.sticky 属性 RegExp.prototype.flags 属性 s 修饰符：dotAll 模式 后行断言 Unicode 属性类 具名组匹配 正则匹配索引 String.prototype.matchAll() RegExp 构造函数 在 ES5 中，RegExp构造函数的参数有两种情况。 第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。 123var regex &#x3D; new RegExp(&#39;xyz&#39;, &#39;i&#39;);&#x2F;&#x2F; 等价于var regex &#x3D; &#x2F;xyz&#x2F;i; 第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。 123var regex &#x3D; new RegExp(&#x2F;xyz&#x2F;i);&#x2F;&#x2F; 等价于var regex &#x3D; &#x2F;xyz&#x2F;i; 但是，ES5 不允许此时使用第二个参数添加修饰符，否则会报错。 12var regex &#x3D; new RegExp(&#x2F;xyz&#x2F;, &#39;i&#39;);&#x2F;&#x2F; Uncaught TypeError: Cannot supply flags when constructing one RegExp from another ES6 改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。 12new RegExp(&#x2F;abc&#x2F;ig, &#39;i&#39;).flags&#x2F;&#x2F; &quot;i&quot; 上面代码中，原有正则对象的修饰符是ig，它会被第二个参数i覆盖。 字符串的正则方法字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()。 ES6 将这 4 个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。 1234String.prototype.match 调用 RegExp.prototype[Symbol.match]String.prototype.replace 调用 RegExp.prototype[Symbol.replace]String.prototype.search 调用 RegExp.prototype[Symbol.search]String.prototype.split 调用 RegExp.prototype[Symbol.split] u 修饰符ES6 对正则表达式添加了u修饰符，含义为“Unicode 模式”，用来正确处理大于\\uFFFF的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。 12&#x2F;^\\uD83D&#x2F;u.test(&#39;\\uD83D\\uDC2A&#39;) &#x2F;&#x2F; false&#x2F;^\\uD83D&#x2F;.test(&#39;\\uD83D\\uDC2A&#39;) &#x2F;&#x2F; true 上面代码中，\\uD83D\\uDC2A是一个四个字节的 UTF-16 编码，代表一个字符。但是，ES5 不支持四个字节的 UTF-16 编码，会将其识别为两个字符，导致第二行代码结果为true。加了u修饰符以后，ES6 就会识别其为一个字符，所以第一行代码结果为false。 一旦加上u修饰符号，就会修改下面这些正则表达式的行为。 （1）点字符 点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于0xFFFF的 Unicode 字符，点字符不能识别，必须加上u修饰符。 1234var s &#x3D; &#39;𠮷&#39;;&#x2F;^.$&#x2F;.test(s) &#x2F;&#x2F; false&#x2F;^.$&#x2F;u.test(s) &#x2F;&#x2F; true 上面代码表示，如果不添加u修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。 （2）Unicode 字符表示法 ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上u修饰符，才能识别当中的大括号，否则会被解读为量词。 123&#x2F;\\u&#123;61&#125;&#x2F;.test(&#39;a&#39;) &#x2F;&#x2F; false&#x2F;\\u&#123;61&#125;&#x2F;u.test(&#39;a&#39;) &#x2F;&#x2F; true&#x2F;\\u&#123;20BB7&#125;&#x2F;u.test(&#39;𠮷&#39;) &#x2F;&#x2F; true 上面代码表示，如果不加u修饰符，正则表达式无法识别\\u{61}这种表示法，只会认为这匹配 61 个连续的u。 （3）量词 使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的 Unicode 字符。 1234&#x2F;a&#123;2&#125;&#x2F;.test(&#39;aa&#39;) &#x2F;&#x2F; true&#x2F;a&#123;2&#125;&#x2F;u.test(&#39;aa&#39;) &#x2F;&#x2F; true&#x2F;𠮷&#123;2&#125;&#x2F;.test(&#39;𠮷𠮷&#39;) &#x2F;&#x2F; false&#x2F;𠮷&#123;2&#125;&#x2F;u.test(&#39;𠮷𠮷&#39;) &#x2F;&#x2F; true （4）预定义模式 u修饰符也影响到预定义模式，能否正确识别码点大于0xFFFF的 Unicode 字符。 12&#x2F;^\\S$&#x2F;.test(&#39;𠮷&#39;) &#x2F;&#x2F; false&#x2F;^\\S$&#x2F;u.test(&#39;𠮷&#39;) &#x2F;&#x2F; true 上面代码的\\S是预定义模式，匹配所有非空白字符。只有加了u修饰符，它才能正确匹配码点大于0xFFFF的 Unicode 字符。 利用这一点，可以写出一个正确返回字符串长度的函数。 123456789function codePointLength(text) &#123; var result &#x3D; text.match(&#x2F;[\\s\\S]&#x2F;gu); return result ? result.length : 0;&#125;var s &#x3D; &#39;𠮷𠮷&#39;;s.length &#x2F;&#x2F; 4codePointLength(s) &#x2F;&#x2F; 2 （5）i 修饰符 有些 Unicode 字符的编码不同，但是字型很相近，比如，\\u004B与\\u212A都是大写的K。 12&#x2F;[a-z]&#x2F;i.test(&#39;\\u212A&#39;) &#x2F;&#x2F; false&#x2F;[a-z]&#x2F;iu.test(&#39;\\u212A&#39;) &#x2F;&#x2F; true 上面代码中，不加u修饰符，就无法识别非规范的K字符。 （6）转义 没有u修饰符的情况下，正则中没有定义的转义（如逗号的转义,）无效，而在u模式会报错。 12&#x2F;\\,&#x2F; &#x2F;&#x2F; &#x2F;\\,&#x2F;&#x2F;\\,&#x2F;u &#x2F;&#x2F; 报错 上面代码中，没有u修饰符时，逗号前面的反斜杠是无效的，加了u修饰符就报错。 RegExp.prototype.unicode 属性正则实例对象新增unicode属性，表示是否设置了u修饰符。 12345const r1 &#x3D; &#x2F;hello&#x2F;;const r2 &#x3D; &#x2F;hello&#x2F;u;r1.unicode &#x2F;&#x2F; falser2.unicode &#x2F;&#x2F; true 上面代码中，正则表达式是否设置了u修饰符，可以从unicode属性看出来。 y 修饰符除了u修饰符，ES6 还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。 y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。 123456789var s &#x3D; &#39;aaa_aa_a&#39;;var r1 &#x3D; &#x2F;a+&#x2F;g;var r2 &#x3D; &#x2F;a+&#x2F;y;r1.exec(s) &#x2F;&#x2F; [&quot;aaa&quot;]r2.exec(s) &#x2F;&#x2F; [&quot;aaa&quot;]r1.exec(s) &#x2F;&#x2F; [&quot;aa&quot;]r2.exec(s) &#x2F;&#x2F; null 上面代码有两个正则表达式，一个使用g修饰符，另一个使用y修饰符。这两个正则表达式各执行了两次，第一次执行的时候，两者行为相同，剩余字符串都是_aa_a。由于g修饰没有位置要求，所以第二次执行会返回结果，而y修饰符要求匹配必须从头部开始，所以返回null。 如果改一下正则表达式，保证每次都能头部匹配，y修饰符就会返回结果了。 12345var s &#x3D; &#39;aaa_aa_a&#39;;var r &#x3D; &#x2F;a+_&#x2F;y;r.exec(s) &#x2F;&#x2F; [&quot;aaa_&quot;]r.exec(s) &#x2F;&#x2F; [&quot;aa_&quot;] 上面代码每次匹配，都是从剩余字符串的头部开始。 使用lastIndex属性，可以更好地说明y修饰符。 12345678910111213141516const REGEX &#x3D; &#x2F;a&#x2F;g;&#x2F;&#x2F; 指定从2号位置（y）开始匹配REGEX.lastIndex &#x3D; 2;&#x2F;&#x2F; 匹配成功const match &#x3D; REGEX.exec(&#39;xaya&#39;);&#x2F;&#x2F; 在3号位置匹配成功match.index &#x2F;&#x2F; 3&#x2F;&#x2F; 下一次匹配从4号位开始REGEX.lastIndex &#x2F;&#x2F; 4&#x2F;&#x2F; 4号位开始匹配失败REGEX.exec(&#39;xaya&#39;) &#x2F;&#x2F; null 上面代码中，lastIndex属性指定每次搜索的开始位置，g修饰符从这个位置开始向后搜索，直到发现匹配为止。 y修饰符同样遵守lastIndex属性，但是要求必须在lastIndex指定的位置发现匹配。 123456789101112131415const REGEX &#x3D; &#x2F;a&#x2F;y;&#x2F;&#x2F; 指定从2号位置开始匹配REGEX.lastIndex &#x3D; 2;&#x2F;&#x2F; 不是粘连，匹配失败REGEX.exec(&#39;xaya&#39;) &#x2F;&#x2F; null&#x2F;&#x2F; 指定从3号位置开始匹配REGEX.lastIndex &#x3D; 3;&#x2F;&#x2F; 3号位置是粘连，匹配成功const match &#x3D; REGEX.exec(&#39;xaya&#39;);match.index &#x2F;&#x2F; 3REGEX.lastIndex &#x2F;&#x2F; 4 实际上，y修饰符号隐含了头部匹配的标志^。 12&#x2F;b&#x2F;y.exec(&#39;aba&#39;)&#x2F;&#x2F; null 上面代码由于不能保证头部匹配，所以返回null。y修饰符的设计本意，就是让头部匹配的标志^在全局匹配中都有效。 下面是字符串对象的replace方法的例子。 12const REGEX &#x3D; &#x2F;a&#x2F;gy;&#39;aaxa&#39;.replace(REGEX, &#39;-&#39;) &#x2F;&#x2F; &#39;--xa&#39; 上面代码中，最后一个a因为不是出现在下一次匹配的头部，所以不会被替换。 单单一个y修饰符对match方法，只能返回第一个匹配，必须与g修饰符联用，才能返回所有匹配。 12&#39;a1a2a3&#39;.match(&#x2F;a\\d&#x2F;y) &#x2F;&#x2F; [&quot;a1&quot;]&#39;a1a2a3&#39;.match(&#x2F;a\\d&#x2F;gy) &#x2F;&#x2F; [&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;] y修饰符的一个应用，是从字符串提取 token（词元），y修饰符确保了匹配之间不会有漏掉的字符。 12345678910111213141516const TOKEN_Y &#x3D; &#x2F;\\s*(\\+|[0-9]+)\\s*&#x2F;y;const TOKEN_G &#x3D; &#x2F;\\s*(\\+|[0-9]+)\\s*&#x2F;g;tokenize(TOKEN_Y, &#39;3 + 4&#39;)&#x2F;&#x2F; [ &#39;3&#39;, &#39;+&#39;, &#39;4&#39; ]tokenize(TOKEN_G, &#39;3 + 4&#39;)&#x2F;&#x2F; [ &#39;3&#39;, &#39;+&#39;, &#39;4&#39; ]function tokenize(TOKEN_REGEX, str) &#123; let result &#x3D; []; let match; while (match &#x3D; TOKEN_REGEX.exec(str)) &#123; result.push(match[1]); &#125; return result;&#125; 上面代码中，如果字符串里面没有非法字符，y修饰符与g修饰符的提取结果是一样的。但是，一旦出现非法字符，两者的行为就不一样了。 1234tokenize(TOKEN_Y, &#39;3x + 4&#39;)&#x2F;&#x2F; [ &#39;3&#39; ]tokenize(TOKEN_G, &#39;3x + 4&#39;)&#x2F;&#x2F; [ &#39;3&#39;, &#39;+&#39;, &#39;4&#39; ] 上面代码中，g修饰符会忽略非法字符，而y修饰符不会，这样就很容易发现错误。 RegExp.prototype.sticky 属性与y修饰符相匹配，ES6 的正则实例对象多了sticky属性，表示是否设置了y修饰符。 12var r &#x3D; &#x2F;hello\\d&#x2F;y;r.sticky &#x2F;&#x2F; true RegExp.prototype.flags 属性ES6 为正则表达式新增了flags属性，会返回正则表达式的修饰符。 123456789&#x2F;&#x2F; ES5 的 source 属性&#x2F;&#x2F; 返回正则表达式的正文&#x2F;abc&#x2F;ig.source&#x2F;&#x2F; &quot;abc&quot;&#x2F;&#x2F; ES6 的 flags 属性&#x2F;&#x2F; 返回正则表达式的修饰符&#x2F;abc&#x2F;ig.flags&#x2F;&#x2F; &#39;gi&#39; s 修饰符：dotAll 模式正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用u修饰符解决；另一个是行终止符（line terminator character）。 所谓行终止符，就是该字符表示一行的终结。以下四个字符属于“行终止符”。 123456U+000A 换行符（\\n）U+000D 回车符（\\r）U+2028 行分隔符（line separator）U+2029 段分隔符（paragraph separator）&#x2F;foo.bar&#x2F;.test(&#39;foo\\nbar&#39;)&#x2F;&#x2F; false 上面代码中，因为.不匹配\\n，所以正则表达式返回false。 但是，很多时候我们希望匹配的是任意单个字符。 1&#x2F;foo.bar&#x2F;s.test(&#39;foo\\nbar&#39;) &#x2F;&#x2F; true 这被称为dotAll模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个dotAll属性，返回一个布尔值，表示该正则表达式是否处在dotAll模式。 1234567const re &#x3D; &#x2F;foo.bar&#x2F;s;&#x2F;&#x2F; 另一种写法&#x2F;&#x2F; const re &#x3D; new RegExp(&#39;foo.bar&#39;, &#39;s&#39;);re.test(&#39;foo\\nbar&#39;) &#x2F;&#x2F; truere.dotAll &#x2F;&#x2F; truere.flags &#x2F;&#x2F; &#39;s&#39; /s修饰符和多行修饰符/m不冲突，两者一起使用的情况下，.匹配所有字符，而^和$匹配每一行的行首和行尾。 后行断言JavaScript 语言的正则表达式，只支持先行断言（lookahead）和先行否定断言（negative lookahead），不支持后行断言（lookbehind）和后行否定断言（negative lookbehind）。ES2018 引入后行断言，V8 引擎 4.9 版（Chrome 62）已经支持。 “先行断言”指的是，x只有在y前面才匹配，必须写成/x(?=y)/。比如，只匹配百分号之前的数字，要写成/\\d+(?=%)/。“先行否定断言”指的是，x只有不在y前面才匹配，必须写成/x(?!y)/。比如，只匹配不在百分号之前的数字，要写成/\\d+(?!%)/。 12&#x2F;\\d+(?&#x3D;%)&#x2F;.exec(&#39;100% of US presidents have been male&#39;) &#x2F;&#x2F; [&quot;100&quot;]&#x2F;\\d+(?!%)&#x2F;.exec(&#39;that’s all 44 of them&#39;) &#x2F;&#x2F; [&quot;44&quot;] 上面两个字符串，如果互换正则表达式，就不会得到相同结果。另外，还可以看到，“先行断言”括号之中的部分（(?=%)），是不计入返回结果的。 “后行断言”正好与“先行断言”相反，x只有在y后面才匹配，必须写成/(?&lt;=y)x/。比如，只匹配美元符号之后的数字，要写成/(?&lt;=\\$)\\d+/。“后行否定断言”则与“先行否定断言”相反，x只有不在y后面才匹配，必须写成/(?&lt;!y)x/。比如，只匹配不在美元符号后面的数字，要写成/(?&lt;!\\$)\\d+/。 12&#x2F;(?&lt;&#x3D;\\$)\\d+&#x2F;.exec(&#39;Benjamin Franklin is on the $100 bill&#39;) &#x2F;&#x2F; [&quot;100&quot;]&#x2F;(?&lt;!\\$)\\d+&#x2F;.exec(&#39;it’s is worth about €90&#39;) &#x2F;&#x2F; [&quot;90&quot;] 上面的例子中，“后行断言”的括号之中的部分（(?&lt;=\\$)），也是不计入返回结果。 下面的例子是使用后行断言进行字符串替换。 123const RE_DOLLAR_PREFIX &#x3D; &#x2F;(?&lt;&#x3D;\\$)foo&#x2F;g;&#39;$foo %foo foo&#39;.replace(RE_DOLLAR_PREFIX, &#39;bar&#39;);&#x2F;&#x2F; &#39;$bar %foo foo&#39; 上面代码中，只有在美元符号后面的foo才会被替换。 “后行断言”的实现，需要先匹配/(?&lt;=y)x/的x，然后再回到左边，匹配y的部分。这种“先右后左”的执行顺序，与所有其他正则操作相反，导致了一些不符合预期的行为。 首先，后行断言的组匹配，与正常情况下结果是不一样的。 12&#x2F;(?&lt;&#x3D;(\\d+)(\\d+))$&#x2F;.exec(&#39;1053&#39;) &#x2F;&#x2F; [&quot;&quot;, &quot;1&quot;, &quot;053&quot;]&#x2F;^(\\d+)(\\d+)$&#x2F;.exec(&#39;1053&#39;) &#x2F;&#x2F; [&quot;1053&quot;, &quot;105&quot;, &quot;3&quot;] 上面代码中，需要捕捉两个组匹配。没有“后行断言”时，第一个括号是贪婪模式，第二个括号只能捕获一个字符，所以结果是105和3。而“后行断言”时，由于执行顺序是从右到左，第二个括号是贪婪模式，第一个括号只能捕获一个字符，所以结果是1和053。 其次，“后行断言”的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。 12&#x2F;(?&lt;&#x3D;(o)d\\1)r&#x2F;.exec(&#39;hodor&#39;) &#x2F;&#x2F; null&#x2F;(?&lt;&#x3D;\\1d(o))r&#x2F;.exec(&#39;hodor&#39;) &#x2F;&#x2F; [&quot;r&quot;, &quot;o&quot;] 上面代码中，如果后行断言的反斜杠引用（\\1）放在括号的后面，就不会得到匹配结果，必须放在前面才可以。因为后行断言是先从左到右扫描，发现匹配以后再回过头，从右到左完成反斜杠引用。 Unicode 属性类ES2018 引入了一种新的类的写法\\p{...}和\\P{...}，允许正则表达式匹配符合 Unicode 某种属性的所有字符。 12const regexGreekSymbol &#x3D; &#x2F;\\p&#123;Script&#x3D;Greek&#125;&#x2F;u;regexGreekSymbol.test(&#39;π&#39;) &#x2F;&#x2F; true 上面代码中，\\p{Script=Greek}指定匹配一个希腊文字母，所以匹配π成功。 Unicode 属性类要指定属性名和属性值。 \\p{UnicodePropertyName=UnicodePropertyValue} 对于某些属性，可以只写属性名，或者只写属性值。 12\\p&#123;UnicodePropertyName&#125;\\p&#123;UnicodePropertyValue&#125; \\P{…}是\\p{…}的反向匹配，即匹配不满足条件的字符。 注意，这两种类只对 Unicode 有效，所以使用的时候一定要加上u修饰符。如果不加u修饰符，正则表达式使用\\p和\\P会报错，ECMAScript 预留了这两个类。 由于 Unicode 的各种属性非常多，所以这种新的类的表达能力非常强。 12const regex &#x3D; &#x2F;^\\p&#123;Decimal_Number&#125;+$&#x2F;u;regex.test(&#39;𝟏𝟐𝟑𝟜𝟝𝟞𝟩𝟪𝟫𝟬𝟭𝟮𝟯𝟺𝟻𝟼&#39;) &#x2F;&#x2F; true 上面代码中，属性类指定匹配所有十进制字符，可以看到各种字型的十进制字符都会匹配成功。 具名组匹配正则表达式使用圆括号进行组匹配。 1const RE_DATE &#x3D; &#x2F;(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)&#x2F;; 上面代码中，正则表达式里面有三组圆括号。使用exec方法，就可以将这三组匹配结果提取出来。 123456const RE_DATE &#x3D; &#x2F;(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)&#x2F;;const matchObj &#x3D; RE_DATE.exec(&#39;1999-12-31&#39;);const year &#x3D; matchObj[1]; &#x2F;&#x2F; 1999const month &#x3D; matchObj[2]; &#x2F;&#x2F; 12const day &#x3D; matchObj[3]; &#x2F;&#x2F; 31 组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号（比如matchObj[1]）引用，要是组的顺序变了，引用的时候就必须修改序号。 ES2018 引入了具名组匹配（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。 123456const RE_DATE &#x3D; &#x2F;(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)&#x2F;;const matchObj &#x3D; RE_DATE.exec(&#39;1999-12-31&#39;);const year &#x3D; matchObj.groups.year; &#x2F;&#x2F; 1999const month &#x3D; matchObj.groups.month; &#x2F;&#x2F; 12const day &#x3D; matchObj.groups.day; &#x2F;&#x2F; 31 上面代码中，“具名组匹配”在圆括号内部，模式的头部添加“问号 + 尖括号 + 组名”（?&lt;year&gt;），然后就可以在exec方法返回结果的groups属性上引用该组名。同时，数字序号（matchObj[1]）依然有效。 具名组匹配等于为每一组匹配加上了 ID，便于描述匹配的目的。如果组的顺序变了，也不用改变匹配后的处理代码。 如果具名组没有匹配，那么对应的groups对象属性会是undefined。 12345const RE_OPT_A &#x3D; &#x2F;^(?&lt;as&gt;a+)?$&#x2F;;const matchObj &#x3D; RE_OPT_A.exec(&#39;&#39;);matchObj.groups.as &#x2F;&#x2F; undefined&#39;as&#39; in matchObj.groups &#x2F;&#x2F; true 上面代码中，具名组as没有找到匹配，那么matchObj.groups.as属性值就是undefined，并且as这个键名在groups是始终存在的。 正则匹配索引正则匹配结果的开始位置和结束位置，目前获取并不是很方便。正则实例的exec()方法，返回结果有一个index属性，可以获取整个匹配结果的开始位置，但是如果包含组匹配，每个组匹配的开始位置，很难拿到。 现在有一个第三阶段提案，为exec()方法的返回结果加上indices属性，在这个属性上面可以拿到匹配的开始位置和结束位置。 123456const text &#x3D; &#39;zabbcdef&#39;;const re &#x3D; &#x2F;ab&#x2F;;const result &#x3D; re.exec(text);result.index &#x2F;&#x2F; 1result.indices &#x2F;&#x2F; [ [1, 3] ] 上面例子中，exec()方法的返回结果result，它的index属性是整个匹配结果（ab）的开始位置，而它的indices属性是一个数组，成员是每个匹配的开始位置和结束位置的数组。由于该例子的正则表达式没有组匹配，所以indices数组只有一个成员，表示整个匹配的开始位置是1，结束位置是3。 注意，开始位置包含在匹配结果之中，但是结束位置不包含在匹配结果之中。比如，匹配结果为ab，分别是原始字符串的第1位和第2位，那么结束位置就是第3位。 如果正则表达式包含组匹配，那么indices属性对应的数组就会包含多个成员，提供每个组匹配的开始位置和结束位置。 12345const text &#x3D; &#39;zabbcdef&#39;;const re &#x3D; &#x2F;ab+(cd)&#x2F;;const result &#x3D; re.exec(text);result.indices &#x2F;&#x2F; [ [ 1, 6 ], [ 4, 6 ] ] 上面例子中，正则表达式包含一个组匹配，那么indices属性数组就有两个成员，第一个成员是整个匹配结果（abbcd）的开始位置和结束位置，第二个成员是组匹配（cd）的开始位置和结束位置。 下面是多个组匹配的例子。 12345const text &#x3D; &#39;zabbcdef&#39;;const re &#x3D; &#x2F;ab+(cd(ef))&#x2F;;const result &#x3D; re.exec(text);result.indices &#x2F;&#x2F; [ [1, 8], [4, 8], [6, 8] ] 上面例子中，正则表达式包含两个组匹配，所以indices属性数组就有三个成员。 如果正则表达式包含具名组匹配，indices属性数组还会有一个groups属性。该属性是一个对象，可以从该对象获取具名组匹配的开始位置和结束位置。 如果获取组匹配不成功，indices属性数组的对应成员则为undefined，indices.groups属性对象的对应成员也是undefined。 String.prototype.matchAll()如果一个正则表达式在字符串里面有多个匹配，现在一般使用g修饰符或y修饰符，在循环里面逐一取出。 123456789101112131415var regex &#x3D; &#x2F;t(e)(st(\\d?))&#x2F;g;var string &#x3D; &#39;test1test2test3&#39;;var matches &#x3D; [];var match;while (match &#x3D; regex.exec(string)) &#123; matches.push(match);&#125;matches&#x2F;&#x2F; [&#x2F;&#x2F; [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;, index: 0, input: &quot;test1test2test3&quot;],&#x2F;&#x2F; [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;, index: 5, input: &quot;test1test2test3&quot;],&#x2F;&#x2F; [&quot;test3&quot;, &quot;e&quot;, &quot;st3&quot;, &quot;3&quot;, index: 10, input: &quot;test1test2test3&quot;]&#x2F;&#x2F; ] 上面代码中，while循环取出每一轮的正则匹配，一共三轮。 ES2020 增加了String.prototype.matchAll()方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。 1234567891011const string &#x3D; &#39;test1test2test3&#39;;&#x2F;&#x2F; g 修饰符加不加都可以const regex &#x3D; &#x2F;t(e)(st(\\d?))&#x2F;g;for (const match of string.matchAll(regex)) &#123; console.log(match);&#125;&#x2F;&#x2F; [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;, index: 0, input: &quot;test1test2test3&quot;]&#x2F;&#x2F; [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;, index: 5, input: &quot;test1test2test3&quot;]&#x2F;&#x2F; [&quot;test3&quot;, &quot;e&quot;, &quot;st3&quot;, &quot;3&quot;, index: 10, input: &quot;test1test2test3&quot;] 上面代码中，由于string.matchAll(regex)返回的是遍历器，所以可以用for...of循环取出。相对于返回数组，返回遍历器的好处在于，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。 遍历器转为数组是非常简单的，使用…运算符和Array.from()方法就可以了。 12345&#x2F;&#x2F; 转为数组方法一[...string.matchAll(regex)]&#x2F;&#x2F; 转为数组方法二Array.from(string.matchAll(regex))","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"数值的拓展","slug":"08-数值的扩展","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:52:22.000Z","comments":true,"path":"2020/04/18/08-数值的扩展/","link":"","permalink":"http://yoursite.com/2020/04/18/08-%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95/","excerpt":"前言本文主要内容： Number.isFinite(), Number.isNaN() Number.parseInt(), Number.parseFloat() Number.isInteger() BigInt 数据类型","text":"前言本文主要内容： Number.isFinite(), Number.isNaN() Number.parseInt(), Number.parseFloat() Number.isInteger() BigInt 数据类型 Number.isFinite(), Number.isNaN() ES6 在Number对象上，新提供了Number.isFinite()和Number.isNaN()两个方法。 Number.isFinite()用来检查一个数值是否为有限的（finite），即不是Infinity。 注意，如果参数类型不是数值，Number.isFinite一律返回false。 Number.isNaN()用来检查一个值是否为NaN。 它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，非NaN一律返回false。 Number.parseInt(), Number.parseFloat()ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。 1234567&#x2F;&#x2F; ES5的写法parseInt(&#39;12.34&#39;) &#x2F;&#x2F; 12parseFloat(&#39;123.45#&#39;) &#x2F;&#x2F; 123.45&#x2F;&#x2F; ES6的写法Number.parseInt(&#39;12.34&#39;) &#x2F;&#x2F; 12Number.parseFloat(&#39;123.45#&#39;) &#x2F;&#x2F; 123.45 这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。 Number.isInteger()Number.isInteger()用来判断一个数值是否为整数。 BigInt 数据类型简介JavaScript 所有数字都保存成 64 位浮点数，这给数值的表示带来了两大限制。一是数值的精度只能到 53 个二进制位（相当于 16 个十进制位），大于这个范围的整数，JavaScript 是无法精确表示的，这使得 JavaScript 不适合进行科学和金融方面的精确计算。二是大于或等于2的1024次方的数值，JavaScript 无法表示，会返回Infinity。 ES2020 引入了一种新的数据类型 BigInt（大整数），来解决这个问题。BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。 12345678const a &#x3D; 2172141653n;const b &#x3D; 15346349309n;&#x2F;&#x2F; BigInt 可以保持精度a * b &#x2F;&#x2F; 33334444555566667777n&#x2F;&#x2F; 普通整数无法保持精度Number(a) * Number(b) &#x2F;&#x2F; 33334444555566670000 为了与 Number 类型区别，BigInt 类型的数据必须添加后缀n。 typeof运算符对于 BigInt 类型的数据返回bigint。 BigInt 可以使用负号（-），但是不能使用正号（+），因为会与 asm.js 冲突。 JavaScript 以前不能计算70的阶乘（即70!），因为超出了可以表示的精度。 BigInt 对象JavaScript 原生提供BigInt对象，可以用作构造函数生成 BigInt 类型的数值。转换规则基本与Number()一致，将其他类型的值转为 BigInt。 1234BigInt(123) &#x2F;&#x2F; 123nBigInt(&#39;123&#39;) &#x2F;&#x2F; 123nBigInt(false) &#x2F;&#x2F; 0nBigInt(true) &#x2F;&#x2F; 1n BigInt()构造函数必须有参数，而且参数必须可以正常转为数值，下面的用法都会报错。 参数如果是小数，也会报错。 BigInt 对象继承了 Object 对象的两个实例方法。 BigInt.prototype.toString() BigInt.prototype.valueOf() 转换规则可以使用Boolean()、Number()和String()这三个方法，将 BigInt 可以转为布尔值、数值和字符串类型。 1234Boolean(0n) &#x2F;&#x2F; falseBoolean(1n) &#x2F;&#x2F; trueNumber(1n) &#x2F;&#x2F; 1String(1n) &#x2F;&#x2F; &quot;1&quot; 上面代码中，注意最后一个例子，转为字符串时后缀n会消失。 另外，取反运算符（!）也可以将 BigInt 转为布尔值。 几乎所有的数值运算符都可以用在 BigInt，但是有两个例外。 不带符号的右移位运算符&gt;&gt;&gt; 一元的求正运算符+ BigInt 不能与普通数值进行混合运算。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"浮动","slug":"07-浮动","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:48:08.000Z","comments":true,"path":"2020/04/18/07-浮动/","link":"","permalink":"http://yoursite.com/2020/04/18/07-%E6%B5%AE%E5%8A%A8/","excerpt":"本文主要内容 标准文档流 标准文档流的特性 行内元素和块级元素 行内元素和块级元素的相互转换 浮动的性质 浮动的清除 浏览器的兼容性问题 浮动中margin相关 关于margin的IE6兼容问题","text":"本文主要内容 标准文档流 标准文档流的特性 行内元素和块级元素 行内元素和块级元素的相互转换 浮动的性质 浮动的清除 浏览器的兼容性问题 浮动中margin相关 关于margin的IE6兼容问题 标准文档流web页面的制作，是个“流”，必须从上而下，像“织毛衣”。 标准文档流的特性（1）空白折叠现象： 无论多少个空格、换行、tab，都会折叠为一个空格。 （2）高矮不齐，底边对齐： （3）自动换行，一行写不满，换行写。 行内元素和块级元素标准文档流等级森严。标签分为两种等级： 行内元素 块级元素 行内元素和块级元素的区别：（非常重要） 行内元素： 与其他行内元素并排； 不能设置宽、高。默认的宽度，就是文字的宽度。 块级元素： 霸占一行，不能与其他任何元素并列； 能接受宽、高。如果不设置宽度，那么宽度将默认变为父亲的100%。 行内元素和块级元素的分类： 从HTML的角度来讲，标签分为： 文本级标签：p、span、a、b、i、u、em。 容器级标签：div、h系列、li、dt、dd。 PS：为甚么说p是文本级标签呢？因为p里面只能放文字&amp;图片&amp;表单元素，p里面不能放h和ul，p里面也不能放p。 从CSS的角度讲，CSS的分类和上面的很像，就p不一样： 行内元素：除了p之外，所有的文本级标签，都是行内元素。p是个文本级，但是是个块级元素。 块级元素：所有的容器级标签都是块级元素，还有p标签。 行内元素和块级元素的相互转换我们可以通过display属性将块级元素和行内元素进行相互转换。display即“显示模式”。 块级元素可以转换为行内元素：一旦，给一个块级元素（比如div）设置： 1display: inline; 那么，这个标签将立即变为行内元素，此时它和一个span无异。inline就是“行内”。也就是说： 此时这个div不能设置宽度、高度； 此时这个div可以和别人并排了。 行内元素转换为块级元素：同样的道理，一旦给一个行内元素（比如span）设置： 1display: block; 那么，这个标签将立即变为块级元素，此时它和一个div无异。block”是“块”的意思。也就是说： 此时这个span能够设置宽度、高度 此时这个span必须霸占一行了，别人无法和他并排 如果不设置宽度，将撑满父亲 标准流里面的限制非常多，导致很多页面效果无法实现。如果我们现在就要并排、并且就要设置宽高，那该怎么办呢？办法是：脱离标准流 css中一共有三种手段，使一个元素脱离标准文档流： （1）浮动 （2）绝对定位 （3）固定定位 浮动的性质 浮动是css里面布局用的最多的属性。 现在有两个div，分别设置宽高。我们知道，它们的效果如下： 此时，如果给这两个div增加一个浮动属性，比如float: left;，效果如下： 这就达到了浮动的效果。此时，两个元素并排了，并且两个元素都能够设置宽度、高度了（这在上一段的标准流中，不能实现）。 浮动想学好，一定要知道三个性质。接下来讲一讲。 性质1：浮动的元素脱标脱标即脱离标准流。我们来看几个例子。 证明1： 上图中，在默认情况下，两个div标签是上下进行排列的。现在由于float属性让上图中的第一个&lt;div&gt;标签出现了浮动，于是这个标签在另外一个层面上进行排列。而第二个&lt;div&gt;还在自己的层面上遵从标准流进行排列。 证明2： span标签在标准流中，是不能设置宽高的（因为是行内元素）。但是，一旦设置为浮动之后，即使不转成块级元素，也能够设置宽高了。 所以：一旦一个元素浮动了，那么，将能够并排了，并且能够设置宽高了。无论它原来是个div还是个span。所有标签，浮动之后，已经不区分行内、块级了。 性质2：浮动的元素互相贴靠我们给三个div均设置了float: left;属性之后，然后设置宽高。当改变浏览器窗口大小时，可以看到div的贴靠效果。 3号如果有足够空间，那么就会靠着2号。如果没有足够的空间，那么会靠着1号。如果没有足够的空间靠着1号大哥，3号自己去贴左墙。 同样，float还有一个属性值是right，这个和属性值left是对称的。 性质3：浮动的元素有“字围”效果来看一张图就明白了。我们让div浮动，p不浮动。 上图中，我们发现：div挡住了p，但不会挡住p中的文字，形成“字围”效果。 总结：标准流中的文字不会被浮动的盒子遮挡住。（文字就像水一样） 关于浮动我们要强调一点，浮动这个东西，为避免混乱，我们在初期一定要遵循一个原则：永远不是一个东西单独浮动，浮动都是一起浮动，要浮动，大家都浮动。 性质4：收缩收缩：一个浮动的元素，如果没有设置width，那么将自动收缩为内容的宽度（这点非常像行内元素）。 上图中，div本身是块级元素，如果不设置width，它会单独霸占整行；但是，设置div浮动后，它会收缩 浮动的清除 这里所说的清除浮动，指的是清除浮动与浮动之间的影响。 前言通过上面这个例子，我们发现，此例中的网页就是通过浮动实现并排的。 比如说一个网页有header、content、footer这三部分。就拿content部分来举例，如果设置content的儿子为浮动，但是，这个儿子又是一个全新的标准流，于是儿子的儿子仍然在标准流里。 给里面的&lt;li&gt;标签加浮动。效果却成了下面这个样子： 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=\"text/css\"&gt; *&#123; &#125; li&#123; float: left; width: 100px; height: 20px; background-color: pink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box1\"&gt; &lt;ul&gt; &lt;li&gt;生命壹号1&lt;/li&gt; &lt;li&gt;生命壹号2&lt;/li&gt; &lt;li&gt;生命壹号3&lt;/li&gt; &lt;li&gt;生命壹号4&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=\"box2\"&gt; &lt;ul&gt; &lt;li&gt;许嵩1&lt;/li&gt; &lt;li&gt;许嵩2&lt;/li&gt; &lt;li&gt;许嵩3&lt;/li&gt; &lt;li&gt;许嵩4&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 第二组中的第1个li，去贴靠第一组中的最后一个li了（我们本以为这些li会分成两排）。 所以要清除浮动。 方法1：给浮动元素的祖先元素加高度造成上述这个现象的根本原因是：li的父亲div没有设置高度，导致这两个div的高度均为0px（我们可以通过网页的审查元素进行查看）。div的高度为零，导致不能给自己浮动的孩子，撑起一个容器。 撑不起一个容器，导致自己的孩子没办法在自己的内部进行正确的浮动。 好，现在就算给这个div设置高度，可如果div自己的高度小于孩子的高度，也会出现不正常的现象。 给div设置一个正确的合适的高度（至少保证高度大于儿子的高度），就可以看到正确的现象。 总结： 如果一个元素要浮动，那么它的祖先元素一定要有高度。 有高度的盒子，才能关住浮动。 只要浮动在一个有高度的盒子中，那么这个浮动就不会影响后面的浮动元素。所以就是清除浮动带来的影响了。 方法2：clear:both;网页制作中，高度height其实很少出现。为什么？因为能被内容撑高！也就是说，刚刚我们讲解的方法1，工作中用得很少。 那么，能不能不写height，也把浮动清除了呢？也让浮动之间，互不影响呢？ 这个时候，我们可以使用clear:both;这个属性。如下： 1clear:both; clear就是清除，both指的是左浮动、右浮动都要清除。clear:both的意思就是：不允许左侧和右侧有浮动对象。 这种方法有一个非常大的、致命的问题，它所在的标签，margin属性失效了。 margin失效的本质原因是：上图中的box1和box2，高度为零。 方法3：隔墙法上面这个例子中，为了防止第二个div贴靠到第二个div，我们可以在这两个div中间用一个新的div隔开，然后给这个新的div设置clear: both;属性；同时，既然这个新的div无法设置margin属性，我们可以给它设置height，以达到margin的效果。这便是隔墙法。 内墙法： 近些年，有演化出了“内墙法”： 12345&lt;div&gt; &lt;p&gt;&lt;&#x2F;p&gt; --浮动 &lt;p&gt;&lt;&#x2F;p&gt; --浮动 &lt;div&gt;设置高度撑出高度&lt;div&gt;&lt;&#x2F;div&gt; 记住一句重要的话：一个父亲是不能被浮动的儿子撑出高度的。举例如下： 与外墙法相比，内墙法的优势（本质区别）在于：内墙法可以给它所在的家撑出宽度（让box1有高）。即：可以自适应内容。 而外墙法，虽然一道墙可以把两个div隔开，但是这两个div没有高，也就是说，无法wrap_content。 清除浮动方法4：overflow:hidden;我们可以使用如下属性： 1overflow:hidden; overflow即“溢出”， hidden即“隐藏”。这个属性的意思是“溢出隐藏”。顾名思义：所有溢出边框的内容，都要隐藏掉。 overflow:hidden;的本意是清除溢出到盒子外面的文字。但是，前端开发工程师发现了，它能做偏方。如下： 一个父亲不能被自己浮动的儿子，撑出高度。但是，只要给父亲加上overflow:hidden; 那么，父亲就能被儿子撑出高了。这是一个偏方。 浮动清除的总结 我们在上一段讲了四种清除浮动的方法，本段来进行一个总结。 浮动的元素，只能被有高度的盒子关住。 也就是说，如果盒子内部有浮动，这个盒子有高，那么妥妥的，浮动不会互相影响。 1、加高法工作上，我们绝对不会给所有的盒子加高度，这是因为麻烦，并且不能适应页面的快速变化。 1234567891011&lt;div&gt; //设置height &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;div&gt; //设置height &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; 2、clear:both;法最简单的清除浮动的方法，就是给盒子增加clear:both；表示自己的内部元素，不受其他盒子的影响。 1234567891011&lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;div&gt; //clear:both; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; 浮动确实被清除了，不会互相影响了。但是有一个问题，就是margin失效。两个div之间，没有任何的间隙了。 3、隔墙法在两部分浮动元素中间，建一个墙。隔开两部分浮动，让后面的浮动元素，不去追前面的浮动元素。墙用自己的身体当做了间隙。 12345678910111213&lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;div class=\"cl h10\"&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; 我们发现，隔墙法好用，但是第一个div，还是没有高度。如果我们现在想让第一个div，自动根据自己的儿子撑出高度，我们就要想一些“小伎俩”。 内墙法： 123456789101112&lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;div class=\"cl h10\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; 内墙法的优点就是，不仅仅能够让后部分的p不去追前部分的p了，并且能把第一个div撑出高度。这样，这个div的背景、边框就能够根据p的高度来撑开了。 4、overflow:hidden;这个属性的本意，就是将所有溢出盒子的内容，隐藏掉。但是，我们发现这个东西能够用于浮动的清除。我们知道，一个父亲，不能被自己浮动的儿子撑出高度，但是，如果这个父亲加上了overflow:hidden；那么这个父亲就能够被浮动的儿子撑出高度了。这个现象，不能解释，就是浏览器的偏方。并且,overflow:hidden;能够让margin生效。 浏览器的兼容性问题 讲一下上述知识点涉及到的浏览器兼容问题。 兼容性1（微型盒子）兼容性的第一条：IE6不支持小于12px的盒子，任何小于12px的盒子，在IE6中看都大。即：IE 6不支持微型盒子。 IE6留了一个后门：只要给css属性之前，加上下划线，这个属性就是IE6的专有属性。 兼容性2兼容性的第二条：IE6不支持用overflow:hidden;来清除浮动。 解决办法，以毒攻毒。追加一条： 1_zoom:1; 完整写法： 12overflow: hidden;_zoom:1; 实际上，_zoom:1;能够触发浏览器hasLayout机制。这个机制，不要深究了，因为只有IE6有。我们只需要让IE6好用，具体的实现机制，可以自行查阅。 需要强调的是，overflow:hidden;的本意，就是让溢出盒子的border的内容隐藏，这个功能是IE6兼容的。不兼容的是overflow:hidden;清除浮动的时候。 总结： 我们刚才学习的两个IE6的兼容问题，都是通过多写一条hack来解决的，这个我们称为伴生属性，即两个属性，要写一起写。 属性1： 12height:6px;_font-size:0; 属性2： 12overflow:hidden;_zoom:1; margin相关 我们来讲一下浮动中和margin相关的知识。 margin塌陷/margin重叠标准文档流中，竖直方向的margin不叠加，取较大的值作为margin(水平方向的margin是可以叠加的，即水平方向没有塌陷现象)。如下图所示： 如果不在标准流，比如盒子都浮动了，那么两个盒子之间是没有塌陷现象的。 盒子居中margin:0 auto;margin的值可以为auto，表示自动。当left、right两个方向都是auto的时候，盒子居中了： 12margin-left: auto;margin-right: auto; 盒子居中的简写为： 1margin:0 auto; 对上方代码的理解：上下的margin为0，左右的margin都尽可能的大，于是就居中了。 注意： （1）只有标准流的盒子，才能使用margin:0 auto;居中。也就是说，当一个盒子浮动了、绝对定位了、固定定位了，都不能使用margin:0 auto; （2）使用margin:0 auto;的盒子，必须有width，有明确的width。（可以这样理解，如果没有明确的witdh，那么它的witdh就是霸占整行，没有意义） （3）margin:0 auto;是让盒子居中，不是让盒子里的文本居中。文本的居中，要使用text-align:center; 善于使用父亲的padding，而不是儿子的margin我们来看一个奇怪的现象。现在有下面这样一个结构：（div中放一个p） 123&lt;div&gt; &lt;p&gt;&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; 上面的结构中，我们尝试通过给儿子p一个margin-top:50px;的属性，让其与父亲保持50px的上边距。结果却看到了下面的奇怪的现象： 此时我们给父亲div加一个border属性，就正常了： 如果父亲没有border，那么儿子的margin实际上踹的是“流”，踹的是这“行”。所以，父亲整体也掉下来了。 margin这个属性，本质上描述的是兄弟和兄弟之间的距离； 最好不要用这个marign表达父子之间的距离。 所以，如果要表达父子之间的距离，我们一定要善于使用父亲的padding，而不是儿子的margin。 关于margin的IE6兼容问题IE6的双倍margin的bug：当出现连续浮动的元素，携带与浮动方向相同的margin时，队首的元素，会双倍marign。 12345&lt;ul&gt; &lt;li&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt; 解决方案： （1）使浮动的方向和margin的方向，相反。 所以，你就会发现，我们特别喜欢，浮动的方向和margin的方向相反。并且，前端开发工程师，把这个当做习惯了。 12float: left;margin-right: 40px; （2）使用hack 单独给队首的元素，写一个一半的margin： 1&lt;li class&#x3D;&quot;no1&quot;&gt;&lt;&#x2F;li&gt; 123ul li.no1&#123; _margin-left:20px;&#125; Fireworks和othersFireworksfireworks是Adobe公司的一个设计软件。功能非常多。Fireworks的默认文件格式是png。 标尺的快捷键：Ctrl + Alt+ R others首行缩进两个汉字： 1text-indent: 2em; 上方属性中，单位比较奇怪，叫做em，em就是汉字的一个宽度。indent的意思是缩进。","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS属性：定位属性","slug":"08-CSS属性：定位属性","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T04:56:52.000Z","comments":true,"path":"2020/04/18/08-CSS属性：定位属性/","link":"","permalink":"http://yoursite.com/2020/04/18/08-CSS%E5%B1%9E%E6%80%A7%EF%BC%9A%E5%AE%9A%E4%BD%8D%E5%B1%9E%E6%80%A7/","excerpt":"本文主要内容：CSS的定位属性主要有三种，分别是绝对定位、相对定位、固定定位。 1234567position: absolute; &lt;!-- 绝对定位 --&gt;position: relative; &lt;!-- 相对定位 --&gt;position: fixed; &lt;!-- 固定定位 --&gt;position: sticky; &lt;!-- 粘性定位 --&gt;","text":"本文主要内容：CSS的定位属性主要有三种，分别是绝对定位、相对定位、固定定位。 1234567position: absolute; &lt;!-- 绝对定位 --&gt;position: relative; &lt;!-- 相对定位 --&gt;position: fixed; &lt;!-- 固定定位 --&gt;position: sticky; &lt;!-- 粘性定位 --&gt; ## 相对定位 相对定位：让元素相对于自己原来的位置，进行位置调整（可用于盒子的位置微调）。 我们之前学习的背景属性中，是通过如下格式： 1background-position:向右偏移量 向下偏移量; 但这回的定位属性，是通过如下格式： 123position: relative;left: 50px;top: 50px; 相对定位不脱标相对定位：不脱标，老家留坑，别人不会把它原来的位置挤走。 也就是说，相对定位的真实位置还在老家，只不过影子出去了，可以到处飘。 相对定位的用途如果想做“压盖”效果（把一个div放到另一个div之上），我们一般不用相对定位来做。相对定位，就两个作用： （1）微调元素 （2）做绝对定位的参考，子绝父相 相对定位的定位值 left：盒子右移 right：盒子左移 top：盒子下移 bottom：盒子上移 PS：负数表示相反的方向。 ↘： 123position: relative;left: 40px;top: 10px; ↙： 123position: relative;right: 100px;top: 100px; ↖： 123position: relative;right: 100px;bottom: 100px; ↗： 123position: relative;left: 200px;bottom: 200px; 绝对定位绝对定位：定义横纵坐标。原点在父容器的左上角或左下角。横坐标用left表示，纵坐标用top或者bottom表示。 格式举例如下： 123position: absolute; &#x2F;*绝对定位*&#x2F;left: 10px; &#x2F;*横坐标*&#x2F;top&#x2F;bottom: 20px; &#x2F;*纵坐标*&#x2F; 绝对定位脱标绝对定位的盒子脱离了标准文档流。 所以，所有的标准文档流的性质，绝对定位之后都不遵守了。 绝对定位之后，标签就不区分所谓的行内元素、块级元素了，不需要display:block就可以设置宽、高了。 绝对定位的参考点（重要）（1）如果用top描述，那么参考点就是页面的左上角，而不是浏览器的左上角： （2）如果用bottom描述，那么参考点就是浏览器首屏窗口尺寸（好好理解“首屏”二字），对应的页面的左下角： 以盒子为参考点: absolute一个绝对定位的元素，如果父辈元素中也出现了已定位（无论是绝对定位、相对定位，还是固定定位）的元素，那么将以父辈这个元素，为参考点。 （1） 要听最近的已经定位的祖先元素的，不一定是父亲，可能是爷爷： （2）不一定是相对定位，任何定位，都可以作为儿子的参考点： 子绝父绝、子绝父相、子绝父固，都是可以给儿子定位的。但是在工程上，如果子绝、父绝，没有一个盒子在标准流里面了，所以页面就不稳固，没有任何实战用途。 工程应用： “子绝父相”有意义：这样可以保证父亲没有脱标，儿子脱标在父亲的范围里面移动。于是，工程上经常这样做： 父亲浮动，设置相对定位（零偏移），然后让儿子绝对定位一定的距离。 （3）绝对定位的儿子，无视参考的那个盒子的padding： 工程应用： 绝对定位非常适合用来做“压盖”效果。 让绝对定位中的盒子在父亲里居中我们知道，如果想让一个标准流中的盒子在父亲里居中（水平方向看），可以将其设置margin: 0 auto属性。 可如果盒子是绝对定位的，此时已经脱标了，如果还想让其居中（位于父亲的正中间），可以这样做： 12345678div &#123; width: 600px; height: 60px; position: absolute; 绝对定位的盒子 left: 50%; 首先，让左边线居中 top: 0; margin-left: -300px; 然后，向左移动宽度（600px）的一半&#125; 我们可以总结成一个公式： left:50%; margin-left:负的宽度的一半 固定定位: fixed固定定位：就是相对浏览器窗口进行定位。无论页面如何滚动，这个盒子显示的位置不变。 备注：IE6不兼容。 用途1：网页右下角的“返回到顶部” 比如我们经常看到的网页右下角显示的“返回到顶部”，就可以固定定位。 1234567891011121314&lt;style type=\"text/css\"&gt; .backtop&#123; position: fixed; bottom: 100px; right: 30px; width: 60px; height: 60px; background-color: gray; text-align: center; line-height:30px; color:white; text-decoration: none; /*去掉超链接的下划线*/ &#125;&lt;/style&gt; 用途2：顶部导航条 我们经常能看到固定在网页顶端的导航条，可以用固定定位来做。 需要注意的是，假设顶部导航条的高度是60px，那么，为了防止其他的内容被导航条覆盖，我们要给body标签设置60px的padding-top。 粘性定位 sticky元素根据正常文档流进行定位，然后相对它的最近滚动祖先（nearest scrolling ancestor）和 containing block (最近块级祖先 nearest block-level ancestor)，包括table-related元素，基于top, right, bottom, 和 left的值进行偏移。偏移值不会影响任何其他元素的位置。 该值总是创建一个新的层叠上下文（stacking context）。注意，一个sticky元素会“固定”在离它最近的一个拥有“滚动机制”的祖先上（当该祖先的overflow 是 hidden, scroll, auto, 或 overlay时），即便这个祖先不是真的滚动祖先。这个阻止了所有“sticky”行为（详情见Github issue on W3C CSSWG）。 5、z-index属性：z-index属性：表示谁压着谁。数值大的压盖住数值小的。 有如下特性： （1）属性值大的位于上层，属性值小的位于下层。 （2）z-index值没有单位，就是一个正整数。默认的z-index值是0。 （3）如果大家都没有z-index值，或者z-index值一样，那么在HTML代码里写在后面，谁就在上面能压住别人。定位了的元素，永远能够压住没有定位的元素。 （4）只有定位了的元素，才能有z-index值。也就是说，不管相对定位、绝对定位、固定定位，都可以使用z-index值。而浮动的元素不能用。 （5）从父现象：由父元素z-index数值大小决定。意思是，如果父亲1比父亲2大，那么，即使儿子1比儿子2小，儿子1也能在最上层。 z-index属性的应用还是很广泛的。当好几个已定位的标签出现覆盖的现象时，我们可以用这个z-index属性决定，谁处于最上方。也就是层级的应用。 层级： （1）必须有定位（除去static） （2）用z-index来控制层级数。 总结： 值 描述 absolute 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。 元素的位置通过 \"left\", \"top\", \"right\" 以及 \"bottom\" 属性进行规定。 fixed 生成绝对定位的元素，相对于浏览器窗口进行定位。 元素的位置通过 \"left\", \"top\", \"right\" 以及 \"bottom\" 属性进行规定。 relative 生成相对定位的元素，相对于其正常位置进行定位。 因此，\"left:20\" 会向元素的 LEFT 位置添加 20 像素。 static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。 inherit 规定应该从父元素继承 position 属性的值。","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"JavaScript-Cookies","slug":"08-JavaScript-Cookies","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:53:00.000Z","comments":true,"path":"2020/04/18/08-JavaScript-Cookies/","link":"","permalink":"http://yoursite.com/2020/04/18/08-JavaScript-Cookies/","excerpt":"前言Cookie 让您在网页中存储用户信息。","text":"前言Cookie 让您在网页中存储用户信息。 什么是 cookie？Cookie 是在您的计算机上存储在小的文本文件中的数据。 当 web 服务器向浏览器发送网页后，连接被关闭，服务器会忘记用户的一切。 Cookie 是为了解决“如何记住用户信息”而发明的： 当用户访问网页时，他的名字可以存储在 cookie 中。下次用户访问该页面时，cookie 会“记住”他的名字。 Cookie 保存在名称值对中，如： username = Bill Gates 当浏览器从服务器请求一个网页时，将属于该页的 cookie 添加到该请求中。这样服务器就获得了必要的数据来“记住”用户的信息。 如果浏览器已关闭本地 cookie 支持，则以下实例均无法工作。 通过 JavaScript 创建 cookieJavaScript 可以用 document.cookie 属性创建、读取、删除 cookie。 通过 JavaScript，可以这样创建 cookie： document.cookie = &quot;username=Bill Gates&quot;; 您还可以添加有效日期expires（UTC 时间）。默认情况下，在浏览器关闭时会删除 cookie：Expires这个是代表当前时间的，这个属性已经逐渐被Max-Age所取代. document.cookie = &quot;username=John Doe; expires=Sun, 31 Dec 2017 12:00:00 UTC&quot;; 通过 path 参数，您可以告诉浏览器 cookie 属于什么路径。默认情况下，cookie 属于当前页。 1document.cookie &#x3D; &quot;username&#x3D;Bill Gates; expires&#x3D;Sun, 31 Dec 2017 12:00:00 UTC; path&#x3D;&#x2F;&quot;; 通过 JavaScript 读取 cookie通过 JavaScript，可以这样读取 cookie： 1var x &#x3D; document.cookie; document.cookie 会在一条字符串中返回所有 cookie，比如：cookie1=value; cookie2=value; cookie3=value; 通过 JavaScript 改变 cookie通过使用 JavaScript，你可以像你创建 cookie 一样改变它： 1document.cookie &#x3D; &quot;username&#x3D;Steve Jobs; expires&#x3D;Sun, 31 Dec 2017 12:00:00 UTC; path&#x3D;&#x2F;&quot;; 旧 cookie 被覆盖。 通过 JavaScript 删除 cookie删除 cookie 非常简单。 删除 cookie 时不必指定 cookie 值： 直接把 expires 参数设置为过去的日期即可： 1document.cookie &#x3D; &quot;username&#x3D;; expires&#x3D;Thu, 01 Jan 1970 00:00:00 UTC; path&#x3D;&#x2F;;&quot;; 您应该定义 cookie 路径以确保删除正确的 cookie。 如果你不指定路径，一些浏览器不会让你删除 cookie。 Cookie 字符串document.cookie 属性看起来像一个正常的文本字符串。但它不是。 即使你向 document.cookie 写一份完整的 cookie 字符串，当再次读取时，你只能看到它的名称-值对。 如果设置了新 cookie，则旧的 cookie 不会被覆盖。新的 Cookie 会被添加到 document.cookie，所以如果你读取 document.cookie，你得到的东西会像这样： cookie1 = value; cookie2 = value; 显示所有 cookie 创建 cookie 1 创建 cookie 2 删除 cookie 1 删除 cookie 2如果你想找到一个指定 cookie 的值，你必须编写 JavaScript 函数来搜索 cookie 字符串中的 cookie 值。 JavaScript Cookie 实例在下面的示例中，我们将创建一个 cookie 来存储访问者的名称。 访客第一次到达网页时，会要求他填写姓名。然后将该名称存储在 cookie 中。 下次访客到达同一页时，他将收到一条欢迎消息。 例如，我们将创建 3 个JavaScript函数： 设置 cookie 值的函数 获取 cookie 值的函数 检查 cookie 值的函数 设置 cookie 的函数 首先，我们创建一个函数，将访问者的名字存储在 cookie 变量中： 实例 123456function setCookie(cname, cvalue, exdays) &#123; var d &#x3D; new Date(); d.setTime(d.getTime() + (exdays*24*60*60*1000)); var expires &#x3D; &quot;expires&#x3D;&quot;+ d.toUTCString(); document.cookie &#x3D; cname + &quot;&#x3D;&quot; + cvalue + &quot;;&quot; + expires + &quot;;path&#x3D;&#x2F;&quot;;&#125; 例子解释： 上面这个函数的的参数是：cookie 的名字（cname），cookie 的值（cvalue），以及知道 cookie 过期的天数（exdays）。 通过把 cookie 名称、cookie 值和过期字符串相加，该函数就设置了 cookie。 获取 cookie 的函数然后，我们创建一个函数返回指定 cookie 的值： 实例 123456789101112131415function getCookie(cname) &#123; var name &#x3D; cname + &quot;&#x3D;&quot;; var decodedCookie &#x3D; decodeURIComponent(document.cookie); var ca &#x3D; decodedCookie.split(&#39;;&#39;); for(var i &#x3D; 0; i &lt;ca.length; i++) &#123; var c &#x3D; ca[i]; while (c.charAt(0) &#x3D;&#x3D; &#39; &#39;) &#123; c &#x3D; c.substring(1); &#125; if (c.indexOf(name) &#x3D;&#x3D; 0) &#123; return c.substring(name.length, c.length); &#125; &#125; return &quot;&quot;;&#125; 函数解释： 把 cookie 作为参数（cname）。 创建变量（name）与要搜索的文本（CNAME”=”）。 解码 cookie 字符串，处理带有特殊字符的 cookie，例如 “$”。 用分号把 document.cookie 拆分到名为 ca（decodedCookie.split(‘;’)）的数组中。 遍历 ca 数组（i = 0; i &lt; ca.length; i++），然后读出每个值 c = ca[i]。 如果找到 cookie（c.indexOf(name) == 0），则返回该 cookie 的值（c.substring(name.length, c.length）。 如果未找到 cookie，则返回 “”。 检测 cookie 的函数最后，我们创建检查 cookie 是否设置的函数。 如果已设置 cookie，将显示一个问候。 如果未设置 cookie，会显示一个提示框，询问用户的名字，并存储用户名 cookie 365 天，通过调用 setCookie 函数： 实例 1234567891011function checkCookie() &#123; var username &#x3D; getCookie(&quot;username&quot;); if (username !&#x3D; &quot;&quot;) &#123; alert(&quot;Welcome again &quot; + username); &#125; else &#123; username &#x3D; prompt(&quot;Please enter your name:&quot;, &quot;&quot;); if (username !&#x3D; &quot;&quot; &amp;&amp; username !&#x3D; null) &#123; setCookie(&quot;username&quot;, username, 365); &#125; &#125;&#125; 现在组合起来 实例 123456789101112131415161718192021222324252627282930313233function setCookie(cname, cvalue, exdays) &#123; var d &#x3D; new Date(); d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000)); var expires &#x3D; &quot;expires&#x3D;&quot;+d.toUTCString(); document.cookie &#x3D; cname + &quot;&#x3D;&quot; + cvalue + &quot;;&quot; + expires + &quot;;path&#x3D;&#x2F;&quot;;&#125;function getCookie(cname) &#123; var name &#x3D; cname + &quot;&#x3D;&quot;; var ca &#x3D; document.cookie.split(&#39;;&#39;); for(var i &#x3D; 0; i &lt; ca.length; i++) &#123; var c &#x3D; ca[i]; while (c.charAt(0) &#x3D;&#x3D; &#39; &#39;) &#123; c &#x3D; c.substring(1); &#125; if (c.indexOf(name) &#x3D;&#x3D; 0) &#123; return c.substring(name.length, c.length); &#125; &#125; return &quot;&quot;;&#125;function checkCookie() &#123; var user &#x3D; getCookie(&quot;username&quot;); if (user !&#x3D; &quot;&quot;) &#123; alert(&quot;Welcome again &quot; + user); &#125; else &#123; user &#x3D; prompt(&quot;Please enter your name:&quot;, &quot;&quot;); if (user !&#x3D; &quot;&quot; &amp;&amp; user !&#x3D; null) &#123; setCookie(&quot;username&quot;, user, 365); &#125; &#125;&#125;","categories":[{"name":"BOM","slug":"BOM","permalink":"http://yoursite.com/categories/BOM/"}],"tags":[{"name":"BOM","slug":"BOM","permalink":"http://yoursite.com/tags/BOM/"}]},{"title":"CSS33选择器","slug":"09-CSS3选择器详解","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:55:14.000Z","comments":true,"path":"2020/04/18/09-CSS3选择器详解/","link":"","permalink":"http://yoursite.com/2020/04/18/09-CSS3%E9%80%89%E6%8B%A9%E5%99%A8%E8%AF%A6%E8%A7%A3/","excerpt":"本文主要内容： CSS3属性选择器 结构伪类选择器 伪元素选择器","text":"本文主要内容： CSS3属性选择器 结构伪类选择器 伪元素选择器 CSS3介绍 CSS3在CSS2基础上，增强或新增了许多特性， 弥补了CSS2的众多不足之处，使得Web开发变得更为高效和便捷。 CSS3的现状 浏览器支持程度不够好，有些需要添加私有前缀 移动端支持优于PC端 不断改进中 应用相对广泛 应对的策略：渐进增强 （1）坚持渐进增强的原则：让低版本浏览器能正常访问页面，高版本的浏览器用户体验更好。【重要】 比如说，同样是一个头像，可能在低版本的浏览器中，头像方的；在高版本的浏览器中，头像是圆的。 （2）考虑用户群体。 （3）遵照产品的方案。 浏览器的版本问题由于CSS3普遍存在兼容性问题，为了避免因兼容性带来的干扰，浏览器的建议版本为： Chrome浏览器 version 46+ Firefox浏览器 firefox 42+ CSS3 选择器我们之前学过 CSS 的选择器，比如： 12345678910111213141516171819div 标签选择器.box 类名选择器#box id选择器div p 后代选择器div.box 交集选择器div,p,span 并集选择器div&gt;p 子代选择器* : 通配符div+p: 选中div后面相邻的第一个pdiv~p: 选中的div后面所有的p CSS3新增了许多灵活查找元素的方法，极大的提高了查找元素的效率和精准度。CSS3选择器与 jQuery 中所提供的绝大部分选择器兼容。 属性选择器属性选择器的标志性符号是 []。 匹配含义： 1^：开头 $：结尾 *：包含 格式： E[title] 选中页面的E元素，并且E存在 title 属性即可。 E[title=&quot;abc&quot;]选中页面的E元素，并且E需要带有title属性，且属性值完全等于abc。 E[attr~=val] 选择具有 att 属性且属性值为：用空格分隔的字词列表，其中一个等于 val 的E元素。 E[attr|=val] 表示要么是一个单独的属性值，要么这个属性值是以“-”分隔的。 E[title^=&quot;abc&quot;] 选中页面的E元素，并且E需要带有 title 属性,属性值以 abc 开头。 E[title$=&quot;abc&quot;] 选中页面的E元素，并且E需要带有 title 属性,属性值以 abc 结尾。 E[title*=&quot;abc&quot;] 选中页面的E元素，并且E需要带有 title 属性,属性值任意位置包含abc。 结构伪类选择器伪类选择器的标志性符号是 :。 CSS中有一些伪类选择器，比如:link、:active、:visited、:hover，这些是动态伪类选择器。 CSS3又新增了其它的伪类选择器。这一小段，我们来学习CSS3中的结构伪类选择器：即通过结构来进行筛选。 1、格式：（第一部分） E:first-child 匹配父元素的第一个子元素E。 E:last-child 匹配父元素的最后一个子元素E。 E:nth-child(n) 匹配父元素的第n个子元素E。注意，盒子的编号是从1开始算起，不是从0开始算起。 E:nth-child(odd) 匹配奇数 E:nth-child(even) 匹配偶数 E:nth-last-child(n) 匹配父元素的倒数第n个子元素E。 理解： （1）这里我们要好好理解父元素的含义，它指的是：以 E 元素的父元素为参考。 （2）注意：以上选择器中所选到的元素的类型，必须是指定的类型E，如果选不中，则无效。这个要好好理解，具体可以看CSS参考手册中的E:nth-child(n)的示例。我们可以理解成：先根据选择器找到选中的全部位置，如果发现某个位置不是类型E，则该位置失效。 （3）另外，E:nth-child(n)这个属性也很有意思。 我们只要记住： n 表示 0,1,2,3,4,5,6,7,8…..就很容易明白了。 2、格式：（第二部分） E:first-of-type 匹配同类型中的第一个同级兄弟元素E。 E:last-of-type 匹配同类型中的最后一个同级兄弟元素E。 E:nth-of-type(n) 匹配同类型中的第n个同级兄弟元素E。 E:nth-last-of-type(n) 匹配同类型中的倒数第n个同级兄弟元素E。 既然上面这几个选择器带有type，我们可以这样理解：先在同级里找到所有的E类型，然后根据 n 进行匹配。 3、格式：（第三部分） E:empty 匹配没有任何子节点（包括空格等text节点）的元素E。 E:target 匹配相关URL指向的E元素。要配合锚点使用。 伪元素选择器伪元素选择器的标志性符号是 ::。 1、格式：（第一部分） E::before 设置在 元素E 前面（依据对象树的逻辑结构）的内容，配合content属性一起使用。 E::after 设置在 元素E 后面（依据对象树的逻辑结构）的内容，配合content属性一起使用。 E:after、E:before在旧版本里是伪类，在 CSS3 这个新版本里是伪元素。新版本里，E:after、E:before会被自动识别为E::after、E::before，按伪元素来对待，这样做的目的是用来做兼容处理。 通过伪元素选择器，就可以添加出类似于span标签的效果（记得要结合 content 属性使用）。 通过这两个属性添加的伪元素，是行内元素，需要转换成块元素才能设置宽高。 2、格式：（第二部分） E::first-letter 设置元素 E 里面的第一个字符的样式。 E::first-line 设置元素 E 里面的第一行的样式。 E::selection 设置元素 E 里面被鼠标选中的区域的样式（一般设置颜色和背景色）。","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"流程控制：循环结构(for和while)","slug":"08-流程控制语句：循环结构（for和while）","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:52:50.000Z","comments":true,"path":"2020/04/18/08-流程控制语句：循环结构（for和while）/","link":"","permalink":"http://yoursite.com/2020/04/18/08-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%EF%BC%9A%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%EF%BC%88for%E5%92%8Cwhile%EF%BC%89/","excerpt":"for循环for循环的语法","text":"for循环for循环的语法 语法： 123for(①初始化表达式; ②条件表达式; ④更新表达式)&#123; ③语句...&#125; 执行流程： 1234567①执行初始化表达式，初始化变量（初始化表达式只会执行一次）②执行条件表达式，判断是否执行循环： 如果为true，则执行循环③ 如果为false，终止循环④执行更新表达式，更新表达式执行完毕继续重复② for循环举例： 123for (var i = 1; i &lt;= 100; i++) &#123; console.log(i);&#125; 上方代码的解释： for循环举例123for (var i = 1; i &lt; 13; i = i + 4) &#123; console.log(i);&#125; 上方代码的遍历步骤： 12345678910111213程序一运行，将执行var i &#x3D; 1;这条语句， 所以i的值是1。然后程序会验证一下i &lt; 13是否满足，1&lt;13是真，所以执行一次循环体（就是大括号里面的语句）。执行完循环体之后，会执行i&#x3D;i+4这条语句，所以i的值，是5。程序会会验证一下i &lt; 13是否满足，5&lt;13是真，所以执行一次循环体（就是大括号里面的语句）。执行完循环体之后，会执行i&#x3D;i+4这条语句，所以i的值，是9。程序会会验证一下i &lt; 13是否满足，9&lt;13是真，所以执行一次循环体（就是大括号里面的语句）。执行完循环体之后，会执行i&#x3D;i+4这条语句，所以i的值，是13。程序会会验证一下i &lt; 13是否满足，13&lt;13是假，所以不执行循环体了，将退出循环。最终输出输出结果为：1、5、9 接下来做几个题目。 题目1： 1234for (var i = 1; i &lt; 10; i = i + 3) &#123; i = i + 1; console.log(i);&#125; 输出结果：2、6、10 题目2： 1234for (var i = 1; i &lt;= 10; i++) &#123;&#125;console.log(i); 输出结果：11 题目3： 1234for(var i = 1; i &lt; 7; i = i + 3)&#123;&#125;console.log(i); 输出结果：7 题目4： 123for (var i = 1; i &gt; 0; i++) &#123; console.log(i);&#125; 死循环。 while循环语句while循环语法： 123while(条件表达式)&#123; 语句...&#125; 执行流程： 1234567while语句在执行时，先对条件表达式进行求值判断： 如果值为true，则执行循环体： 循环体执行完毕以后，继续对表达式进行判断 如果为true，则继续执行循环体，以此类推 如果值为false，则终止循环 如果有必要的话，我们可以使用 break 来终止循环。 do…while循环语法： 123do&#123; 语句...&#125;while(条件表达式) 执行流程： 12345do...while语句在执行时，会先执行循环体： 循环体执行完毕以后，在对while后的条件表达式进行判断： 如果结果为true，则继续执行循环体，执行完毕继续判断以此类推 如果结果为false，则终止循环 while循环和 do…while循环的区别这两个语句的功能类似，不同的是： while是先判断后执行，而do…while是先执行后判断。 也就是说，do…while可以保证循环体至少执行一次，而while不能。 while循环举例题目：假如投资的年利率为5%，试求从1000块增长到5000块，需要花费多少年？ 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=\"\"&gt;&lt;head&gt; &lt;meta&gt; &lt;meta&gt; &lt;meta&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; /* * 假如投资的年利率为5%，试求从1000块增长到5000块，需要花费多少年 * * 1000 1000*1.05 * 1050 1050*1.05 */ //定义一个变量，表示当前的钱数 var money = 1000; //定义一个计数器 var count = 0; //定义一个while循环来计算每年的钱数 while (money &lt; 5000) &#123; money *= 1.05; //使count自增 count++; &#125; console.log(money); console.log(\"一共需要\" + count + \"年\"); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 打印结果： 1235003.18854203379一共需要33年 另外，你也可以自己算一下，假如投资的年利率为5%，从1000块增长到1万块，需要花费48年： 1210401.269646942128一共需要48年 break 和 continue 这个知识点非常重要。 break break可以用来退出switch语句或退出整个循环语句（循环语句包括for循环、while循环。不包括if。if里不能用 break 和 continue，否则会报错）。 break会立即终止离它最近的那个循环语句。 可以为循环语句创建一个label，来标识当前的循环（格式：label:循环语句）。使用break语句时，可以在break后跟着一个label，这样break将会结束指定的循环，而不是最近的。 举例1：通过 break 终止循环语句 123456for (var i = 0; i &lt; 5; i++) &#123; console.log('i的值:' + i); if (i == 2) &#123; break; // 注意，虽然在 if 里 使用了 break，但这里的 break 是服务于外面的 for 循环。 &#125;&#125; 打印结果： 123i的值:0i的值:1i的值:2 举例2：label的使用 12345678outer:for (var i = 0; i &lt; 5; i++) &#123; console.log(\"外层循环 i 的值：\" + i) for (var j = 0; j &lt; 5; j++) &#123; break outer; // 直接跳出outer所在的外层循环（这个outer是我自定义的label） console.log(\"内层循环 j 的值:\" + j); &#125;&#125; 打印结果： 1外层循环 i 的值：0 continue continue可以用来跳过当次循环，继续下一次循环。 同样，continue默认只会离他最近的循环起作用。 举例： 123456for (var i = 0; i &lt; 10; i++) &#123; if (i % 2 == 0) &#123; continue; &#125; console.log('i的值:' + i);&#125; 打印结果： 123456789i的值:1i的值:3i的值:5i的值:7i的值:9 各种练习练习一：质数相关题目：在页面中接收一个用户输入的数字，并判断该数是否是质数。 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; /* 质数：只能被1和它自身整除的数，1不是质数也不是合数，质数必须是大于1的自然数。 */ var num = prompt(\"请输入一个大于1的整数:\"); //判断这个值是否合法 if (num &lt;= 1) &#123; alert(\"该值不合法！\"); &#125; else &#123; //先用flag标志位，来保存当前的数的状态 //默认当前num是质数 var flag = true; //判断num是否是质数 //获取2-num之间的数 for (var i = 2; i &lt; num; i++) &#123; //console.log(i); //判断num是否能被i整除 if (num % i == 0) &#123; //一旦发现：如果num能被i整除，则说明num一定不是质数， //此时：设置flag为false，然后跳出 for 循环 flag = false; break; &#125; &#125; //如果num是质数则输出 if (flag) &#123; alert(num + \"是质数！！！\"); &#125; else &#123; alert(\"这个不是质数\") &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 练习二：质数相关题目：打印1~100之间的所有质数 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; /* * 打印出1-100之间所有的质数 */ //打印2-100之间所有的数 for (var i = 2; i &lt;= 100; i++) &#123; //创建一个布尔值，用来保存结果，默认i是质数 var flag = true; //判断i是否是质数 //获取到2-i之间的所有的数 for (var j = 2; j &lt; i; j++) &#123; //判断i是否能被j整除 if (i % j == 0) &#123; //如果进入判断则证明i不是质数,修改flag值为false flag = false; &#125; &#125; //如果是质数，则打印i的值 if (flag) &#123; console.log(i); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 练习三：99乘法表代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; body &#123; width: 2000px; &#125; span &#123; display: inline-block; width: 80px; &#125; &lt;/style&gt; &lt;script type=\"text/javascript\"&gt; /* * 1.打印99乘法表 * 1*1=1 * 1*2=2 2*2=4 * 1*3=3 2*3=6 3*3=9 * 1*4=4 2*4=8 3*4=12 4*4=16 * ....9*9=81 * * 2.打印出1-100之间所有的质数 */ //创建外层循环，用来控制乘法表的高度 for (var i = 1; i &lt;= 9; i++) &#123; //创建一个内层循环来控制图形的宽度 for (var j = 1; j &lt;= i; j++) &#123; document.write(\"&lt;span&gt;\" + j + \"*\" + i + \"=\" + i * j + \"&lt;/span&gt;\"); &#125; //输出一个换行 document.write(\"&lt;br /&gt;\"); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"函数的拓展","slug":"09-函数的扩展","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T03:54:38.000Z","comments":true,"path":"2020/04/18/09-函数的扩展/","link":"","permalink":"http://yoursite.com/2020/04/18/09-%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95/","excerpt":"前言 函数参数的默认值 rest 参数 严格模式 name 属性 箭头函数 尾调用优化 函数参数的尾逗号 Function.prototype.toString() catch 命令的参数省略","text":"前言 函数参数的默认值 rest 参数 严格模式 name 属性 箭头函数 尾调用优化 函数参数的尾逗号 Function.prototype.toString() catch 命令的参数省略 函数参数的默认值 基本用法：ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。 1234567function log(x, y &#x3D; &#39;World&#39;) &#123; console.log(x, y);&#125;log(&#39;Hello&#39;) &#x2F;&#x2F; Hello Worldlog(&#39;Hello&#39;, &#39;China&#39;) &#x2F;&#x2F; Hello Chinalog(&#39;Hello&#39;, &#39;&#39;) &#x2F;&#x2F; Hello 可以看到，ES6 的写法比 ES5 简洁许多，而且非常自然。下面是另一个例子。 1234567function Point(x &#x3D; 0, y &#x3D; 0) &#123; this.x &#x3D; x; this.y &#x3D; y;&#125;const p &#x3D; new Point();p &#x2F;&#x2F; &#123; x: 0, y: 0 &#125; 除了简洁，ES6 的写法还有两个好处：首先，阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。 参数变量是默认声明的，所以不能用let或const再次声明。 使用参数默认值时，函数不能有同名参数 。 12345678910&#x2F;&#x2F; 不报错function foo(x, x, y) &#123; &#x2F;&#x2F; ...&#125;&#x2F;&#x2F; 报错function foo(x, x, y &#x3D; 1) &#123; &#x2F;&#x2F; ...&#125;&#x2F;&#x2F; SyntaxError: Duplicate parameter name not allowed in this context 另外，一个容易忽略的地方是，参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。 123456789let x &#x3D; 99;function foo(p &#x3D; x + 1) &#123; console.log(p);&#125;foo() &#x2F;&#x2F; 100x &#x3D; 100;foo() &#x2F;&#x2F; 101 上面代码中，参数p的默认值是x + 1。这时，每次调用函数foo，都会重新计算x + 1，而不是默认p等于 100。 与解构赋值默认值结合使用参数默认值可以与解构赋值的默认值，结合起来使用。 12345678function foo(&#123;x, y &#x3D; 5&#125;) &#123; console.log(x, y);&#125;foo(&#123;&#125;) &#x2F;&#x2F; undefined 5foo(&#123;x: 1&#125;) &#x2F;&#x2F; 1 5foo(&#123;x: 1, y: 2&#125;) &#x2F;&#x2F; 1 2foo() &#x2F;&#x2F; TypeError: Cannot read property &#39;x&#39; of undefined 上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值生成。如果函数foo调用时没提供参数，变量x和y就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况。 12345function foo(&#123;x, y &#x3D; 5&#125; &#x3D; &#123;&#125;) &#123; console.log(x, y);&#125;foo() &#x2F;&#x2F; undefined 5 上面代码指定，如果没有提供参数，函数foo的参数默认为一个空对象。 下面是另一个解构赋值默认值的例子。 123456789function fetch(url, &#123; body &#x3D; &#39;&#39;, method &#x3D; &#39;GET&#39;, headers &#x3D; &#123;&#125; &#125;) &#123; console.log(method);&#125;fetch(&#39;http:&#x2F;&#x2F;example.com&#39;, &#123;&#125;)&#x2F;&#x2F; &quot;GET&quot;fetch(&#39;http:&#x2F;&#x2F;example.com&#39;)&#x2F;&#x2F; 报错 上面代码中，如果函数fetch的第二个参数是一个对象，就可以为它的三个属性设置默认值。这种写法不能省略第二个参数，如果结合函数参数的默认值，就可以省略第二个参数。这时，就出现了双重默认值。 123456function fetch(url, &#123; body &#x3D; &#39;&#39;, method &#x3D; &#39;GET&#39;, headers &#x3D; &#123;&#125; &#125; &#x3D; &#123;&#125;) &#123; console.log(method);&#125;fetch(&#39;http:&#x2F;&#x2F;example.com&#39;)&#x2F;&#x2F; &quot;GET&quot; 上面代码中，函数fetch没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量method才会取到默认值GET。 作为练习，请问下面两种写法有什么差别？ 123456789&#x2F;&#x2F; 写法一function m1(&#123;x &#x3D; 0, y &#x3D; 0&#125; &#x3D; &#123;&#125;) &#123; return [x, y];&#125;&#x2F;&#x2F; 写法二function m2(&#123;x, y&#125; &#x3D; &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125; 上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。 123456789101112131415161718&#x2F;&#x2F; 函数没有参数的情况m1() &#x2F;&#x2F; [0, 0]m2() &#x2F;&#x2F; [0, 0]&#x2F;&#x2F; x 和 y 都有值的情况m1(&#123;x: 3, y: 8&#125;) &#x2F;&#x2F; [3, 8]m2(&#123;x: 3, y: 8&#125;) &#x2F;&#x2F; [3, 8]&#x2F;&#x2F; x 有值，y 无值的情况m1(&#123;x: 3&#125;) &#x2F;&#x2F; [3, 0]m2(&#123;x: 3&#125;) &#x2F;&#x2F; [3, undefined]&#x2F;&#x2F; x 和 y 都无值的情况m1(&#123;&#125;) &#x2F;&#x2F; [0, 0];m2(&#123;&#125;) &#x2F;&#x2F; [undefined, undefined]m1(&#123;z: 3&#125;) &#x2F;&#x2F; [0, 0]m2(&#123;z: 3&#125;) &#x2F;&#x2F; [undefined, undefined] 参数默认值的位置通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。 12345678910111213141516171819&#x2F;&#x2F; 例一function f(x &#x3D; 1, y) &#123; return [x, y];&#125;f() &#x2F;&#x2F; [1, undefined]f(2) &#x2F;&#x2F; [2, undefined]f(, 1) &#x2F;&#x2F; 报错f(undefined, 1) &#x2F;&#x2F; [1, 1]&#x2F;&#x2F; 例二function f(x, y &#x3D; 5, z) &#123; return [x, y, z];&#125;f() &#x2F;&#x2F; [undefined, 5, undefined]f(1) &#x2F;&#x2F; [1, 5, undefined]f(1, ,2) &#x2F;&#x2F; 报错f(1, undefined, 2) &#x2F;&#x2F; [1, 5, 2] 上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入undefined。 如果传入undefined，将触发该参数等于默认值，null则没有这个效果。 函数的 length 属性指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。 123(function (a) &#123;&#125;).length &#x2F;&#x2F; 1(function (a &#x3D; 5) &#123;&#125;).length &#x2F;&#x2F; 0(function (a, b, c &#x3D; 5) &#123;&#125;).length &#x2F;&#x2F; 2 上面代码中，length属性的返回值，等于函数的参数个数减去指定了默认值的参数个数。比如，上面最后一个函数，定义了 3 个参数，其中有一个参数c指定了默认值，因此length属性等于3减去1，最后得到2。 这是因为length属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，后文的 rest 参数也不会计入length属性。 12(function (a &#x3D; 0, b, c) &#123;&#125;).length &#x2F;&#x2F; 0(function (a, b &#x3D; 1, c) &#123;&#125;).length &#x2F;&#x2F; 1 如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。 作用域一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。 1234567var x &#x3D; 1;function f(x, y &#x3D; x) &#123; console.log(y);&#125;f(2) &#x2F;&#x2F; 2 上面代码中，参数y的默认值等于变量x。调用函数f时，参数形成一个单独的作用域。在这个作用域里面，默认值变量x指向第一个参数x，而不是全局变量x，所以输出是2。 再看下面的例子。 12345678let x &#x3D; 1;function f(y &#x3D; x) &#123; let x &#x3D; 2; console.log(y);&#125;f() &#x2F;&#x2F; 1 上面代码中，函数f调用时，参数y = x形成一个单独的作用域。这个作用域里面，变量x本身没有定义，所以指向外层的全局变量x。函数调用时，函数体内部的局部变量x影响不到默认值变量x。如果此时，全局变量x不存在，就会报错。 应用利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。 12345678910function throwIfMissing() &#123; throw new Error(&#39;Missing parameter&#39;);&#125;function foo(mustBeProvided &#x3D; throwIfMissing()) &#123; return mustBeProvided;&#125;foo()&#x2F;&#x2F; Error: Missing parameter 上面代码的foo函数，如果调用的时候没有参数，就会调用默认值throwIfMissing函数，从而抛出一个错误。 从上面代码还可以看到，参数mustBeProvided的默认值等于throwIfMissing函数的运行结果（注意函数名throwIfMissing之后有一对圆括号），这表明参数的默认值不是在定义时执行，而是在运行时执行。如果参数已经赋值，默认值中的函数就不会运行。 另外，可以将参数默认值设为undefined，表明这个参数是可以省略的。 rest 参数ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。 1234567891011function add(...values) &#123; let sum &#x3D; 0; for (var val of values) &#123; sum +&#x3D; val; &#125; return sum;&#125;add(2, 5, 3) &#x2F;&#x2F; 10 上面代码的add函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。 下面是一个 rest 参数代替arguments变量的例子。 1234567&#x2F;&#x2F; arguments变量的写法function sortNumbers() &#123; return Array.prototype.slice.call(arguments).sort();&#125;&#x2F;&#x2F; rest参数的写法const sortNumbers &#x3D; (...numbers) &#x3D;&gt; numbers.sort(); 上面代码的两种写法，比较后可以发现，rest 参数的写法更自然也更简洁。 arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。下面是一个利用 rest 参数改写数组push方法的例子。 123456789function push(array, ...items) &#123; items.forEach(function(item) &#123; array.push(item); console.log(item); &#125;);&#125;var a &#x3D; [];push(a, 1, 2, 3) 注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。 严格模式从 ES5 开始，函数内部可以设定为严格模式。 1234function doSomething(a, b) &#123; &#39;use strict&#39;; &#x2F;&#x2F; code&#125; ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。 12345678910111213141516171819202122232425&#x2F;&#x2F; 报错function doSomething(a, b &#x3D; a) &#123; &#39;use strict&#39;; &#x2F;&#x2F; code&#125;&#x2F;&#x2F; 报错const doSomething &#x3D; function (&#123;a, b&#125;) &#123; &#39;use strict&#39;; &#x2F;&#x2F; code&#125;;&#x2F;&#x2F; 报错const doSomething &#x3D; (...a) &#x3D;&gt; &#123; &#39;use strict&#39;; &#x2F;&#x2F; code&#125;;const obj &#x3D; &#123; &#x2F;&#x2F; 报错 doSomething(&#123;a, b&#125;) &#123; &#39;use strict&#39;; &#x2F;&#x2F; code &#125;&#125;; 这样规定的原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。 name 属性函数的name属性，返回该函数的函数名。 12function foo() &#123;&#125;foo.name &#x2F;&#x2F; &quot;foo&quot; 这个属性早就被浏览器广泛支持，但是直到 ES6，才将其写入了标准。 需要注意的是，ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的name属性，会返回空字符串，而 ES6 的name属性会返回实际的函数名。 箭头函数基本用法ES6 允许使用“箭头”（=&gt;）定义函数。 123456var f &#x3D; v &#x3D;&gt; v;&#x2F;&#x2F; 等同于var f &#x3D; function (v) &#123; return v;&#125;; 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。 12345&#x2F;&#x2F; 报错let getTempItem &#x3D; id &#x3D;&gt; &#123; id: id, name: &quot;Temp&quot; &#125;;&#x2F;&#x2F; 不报错let getTempItem &#x3D; id &#x3D;&gt; (&#123; id: id, name: &quot;Temp&quot; &#125;); 如果箭头函数只有一行语句，且不需要返回值，可以采用下面的写法，就不用写大括号了。 let fn = () =&gt; void doesNotReturn(); 箭头函数可以与变量解构结合使用。 123456const full &#x3D; (&#123; first, last &#125;) &#x3D;&gt; first + &#39; &#39; + last;&#x2F;&#x2F; 等同于function full(person) &#123; return person.first + &#39; &#39; + person.last;&#125; 箭头函数使得表达更加简洁。 箭头函数的一个用处是简化回调函数。 使用注意点箭头函数有几个使用注意点。 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。 12345678910function foo() &#123; setTimeout(() &#x3D;&gt; &#123; console.log(&#39;id:&#39;, this.id); &#125;, 100);&#125;var id &#x3D; 21;foo.call(&#123; id: 42 &#125;);&#x2F;&#x2F; id: 42 上面代码中，setTimeout的参数是一个箭头函数，这个箭头函数的定义生效是在foo函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时this应该指向全局对象window，这时应该输出21。但是，箭头函数导致this总是指向函数定义生效时所在的对象（本例是{id: 42}），所以输出的是42。 箭头函数可以让setTimeout里面的this，绑定定义时所在的作用域，而不是指向运行时所在的作用域。下面是另一个例子。 1234567891011121314151617function Timer() &#123; this.s1 &#x3D; 0; this.s2 &#x3D; 0; &#x2F;&#x2F; 箭头函数 setInterval(() &#x3D;&gt; this.s1++, 1000); &#x2F;&#x2F; 普通函数 setInterval(function () &#123; this.s2++; &#125;, 1000);&#125;var timer &#x3D; new Timer();setTimeout(() &#x3D;&gt; console.log(&#39;s1: &#39;, timer.s1), 3100);setTimeout(() &#x3D;&gt; console.log(&#39;s2: &#39;, timer.s2), 3100);&#x2F;&#x2F; s1: 3&#x2F;&#x2F; s2: 0 上面代码中，Timer函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的this绑定定义时所在的作用域（即Timer函数），后者的this指向运行时所在的作用域（即全局对象）。所以，3100 毫秒之后，timer.s1被更新了 3 次，而timer.s2一次都没更新。 箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。 this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。 除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。 另外，由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。 长期以来，JavaScript 语言的this对象一直是一个令人头痛的问题，在对象方法中使用this，必须非常小心。箭头函数”绑定”this，很大程度上解决了这个困扰。 不适用场合由于箭头函数使得this从“动态”变成“静态”，下面两个场合不应该使用箭头函数。 第一个场合是定义对象的方法，且该方法内部包括this。123456const cat &#x3D; &#123; lives: 9, jumps: () &#x3D;&gt; &#123; this.lives--; &#125;&#125; 上面代码中，cat.jumps()方法是一个箭头函数，这是错误的。调用cat.jumps()时，如果是普通函数，该方法内部的this指向cat；如果写成上面那样的箭头函数，使得this指向全局对象，因此不会得到预期结果。这是因为对象不构成单独的作用域，导致jumps箭头函数定义时的作用域就是全局作用域。 第二个场合是需要动态this的时候，也不应使用箭头函数。 1234var button &#x3D; document.getElementById(&#39;press&#39;);button.addEventListener(&#39;click&#39;, () &#x3D;&gt; &#123; this.classList.toggle(&#39;on&#39;);&#125;); 上面代码运行时，点击按钮会报错，因为button的监听函数是一个箭头函数，导致里面的this就是全局对象。如果改成普通函数，this就会动态指向被点击的按钮对象。 另外，如果函数体很复杂，有许多行，或者函数内部有大量的读写操作，不单纯是为了计算值，这时也不应该使用箭头函数，而是要使用普通函数，这样可以提高代码可读性。 嵌套的箭头函数箭头函数内部，还可以再使用箭头函数。下面是一个 ES5 语法的多重嵌套函数。 12345678910function insert(value) &#123; return &#123;into: function (array) &#123; return &#123;after: function (afterValue) &#123; array.splice(array.indexOf(afterValue) + 1, 0, value); return array; &#125;&#125;; &#125;&#125;;&#125;insert(2).into([1, 3]).after(1); &#x2F;&#x2F;[1, 2, 3] 上面这个函数，可以使用箭头函数改写。 123456let insert &#x3D; (value) &#x3D;&gt; (&#123;into: (array) &#x3D;&gt; (&#123;after: (afterValue) &#x3D;&gt; &#123; array.splice(array.indexOf(afterValue) + 1, 0, value); return array;&#125;&#125;)&#125;);insert(2).into([1, 3]).after(1); &#x2F;&#x2F;[1, 2, 3] 尾调用优化什么是尾调用？尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。 123function f(x)&#123; return g(x);&#125; 上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。 尾调用优化尾调用之所以与其他调用不同，就在于它的特殊的调用位置。 我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。 123456789101112131415function f() &#123; let m &#x3D; 1; let n &#x3D; 2; return g(m + n);&#125;f();&#x2F;&#x2F; 等同于function f() &#123; return g(3);&#125;f();&#x2F;&#x2F; 等同于g(3); 上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除f(x)的调用帧，只保留g(3)的调用帧。 这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。 注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。 1234567function addOne(a)&#123; var one &#x3D; 1; function inner(b)&#123; return b + one; &#125; return inner(a);&#125; 上面的函数不会进行尾调用优化，因为内层函数inner用到了外层函数addOne的内部变量one。 注意，目前只有 Safari 浏览器支持尾调用优化，Chrome 和 Firefox 都不支持。 尾递归函数调用自身，称为递归。如果尾调用自身，就称为尾递归。 函数参数的尾逗号ES2017 允许函数的最后一个参数有尾逗号（trailing comma）。 此前，函数定义和调用时，都不允许最后一个参数后面出现逗号。 123456789function clownsEverywhere( param1, param2) &#123; &#x2F;* ... *&#x2F; &#125;clownsEverywhere( &#39;foo&#39;, &#39;bar&#39;); 上面代码中，如果在param2或bar后面加一个逗号，就会报错。 如果像上面这样，将参数写成多行（即每个参数占据一行），以后修改代码的时候，想为函数clownsEverywhere添加第三个参数，或者调整参数的次序，就势必要在原来最后一个参数后面添加一个逗号。这对于版本管理系统来说，就会显示添加逗号的那一行也发生了变动。这看上去有点冗余，因此新的语法允许定义和调用时，尾部直接有一个逗号。 Function.prototype.toString()ES2019 对函数实例的toString()方法做出了修改。 toString()方法返回函数代码本身，以前会省略注释和空格。 1234function &#x2F;* foo comment *&#x2F; foo () &#123;&#125;foo.toString()&#x2F;&#x2F; function foo() &#123;&#125; 上面代码中，函数foo的原始代码包含注释，函数名foo和圆括号之间有空格，但是toString()方法都把它们省略了。 修改后的toString()方法，明确要求返回一模一样的原始代码。 1234function &#x2F;* foo comment *&#x2F; foo () &#123;&#125;foo.toString()&#x2F;&#x2F; &quot;function &#x2F;* foo comment *&#x2F; foo () &#123;&#125;&quot; catch 命令的参数省略JavaScript 语言的try…catch结构，以前明确要求catch命令后面必须跟参数，接受try代码块抛出的错误对象。 12345try &#123; &#x2F;&#x2F; ...&#125; catch (err) &#123; &#x2F;&#x2F; 处理错误&#125; 上面代码中，catch命令后面带有参数err。 很多时候，catch代码块可能用不到这个参数。但是，为了保证语法正确，还是必须写。ES2019 做出了改变，允许catch语句省略参数。 12345try &#123; &#x2F;&#x2F; ...&#125; catch &#123; &#x2F;&#x2F; ...&#125;","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"对象简介和对象的基本操作","slug":"09-对象简介和对象的基本操作","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:55:06.000Z","comments":true,"path":"2020/04/18/09-对象简介和对象的基本操作/","link":"","permalink":"http://yoursite.com/2020/04/18/09-%E5%AF%B9%E8%B1%A1%E7%AE%80%E4%BB%8B%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","excerpt":"对象简介面向对象简介面向对象：可以创建自定义的类型，很好的支持继承和多态。 面向对象的特征：封装、继承、多态。","text":"对象简介面向对象简介面向对象：可以创建自定义的类型，很好的支持继承和多态。 面向对象的特征：封装、继承、多态。 对象的概念在 JavaScript 中，对象是一组无序的相关属性和方法的集合。 对象的作用是：封装信息。比如Student类里可以封装学生的姓名、年龄、成绩等。 对象具有特征（属性）和行为（方法）。 为什么需要对象保存一个值时，可以使用变量，保存多个值（一组值）时，可以使用数组。 比如，如果要保存一个人的信息，通过数组的方式可以这样保存： 1var arr = ['王二', 35, '男', '180']; 上面这种表达方式比较乱。而如果用JS中的对象来表达，结构会更清晰。如下： 123456var person = &#123;&#125;;person.name = '王二';person.age = 35;person.sex = '男';person.height = '180'; 由此可见，对象里面的属性均是键值对： 键：相当于属性名。 值：相当于属性值，可以是任意类型的值（数字类型、字符串类型、布尔类型，函数类型等）。 两条补充补充1：对象的属性值可以是任何的数据类型，也可以是个函数：（也称之为方法） 12345678var obj = new Object();obj.sayName = function () &#123; console.log('smyhvae');&#125;;console.log(obj.sayName); //没加括号，就是获取方法console.log('-----------');console.log(obj.sayName()); //加了括号，就是调用方法。即：执行函数内容，并执行函数体的内容 补充2：对象中的属性值，也可以是一个对象。 举例： 123456789101112//创建对象 obj1var obj1 = new Object();obj1.test = undefined;//创建对象 obj2var obj2 = new Object();obj2.name = \"smyhvae\";//将整个 obj2 对象，设置为 obj1 的属性obj1.test = obj2;console.log(obj1.test.name); 打印结果为：smyhvae 对象和数据类型之间的关系数据类型分类： 基本数据类型（值类型）：String 字符串、Number 数值、Boolean 布尔值、Null 空值、Undefined 未定义。 引用数据类型（引用类型）：Object 对象。 基本数据类型： 基本数据类型的值直接保存在栈内存中，值与值之间是独立存在，修改一个变量不会影响其他的变量。 对象： 只要不是那五种基本数据类型，就全都是对象。 如果使用基本数据类型的数据，我们所创建的变量都是独立，不能成为一个整体。 对象属于一种复合的数据类型，在对象中可以保存多个不同数据类型的属性。 换而言之，对象的值是保存在堆内存中的，而对象的引用（即变量）是保存在栈内存中的。 如果两个变量保存的是同一个对象引用，当一个通过一个变量修改属性时，另一个也会受到影响。 例如： 1234567var obj = new Object();obj.name = \"孙悟空\";var obj2 = obj;//修改obj的name属性obj.name = \"猪八戒\"; 上面的代码中，当我修改obj的name属性后，会发现，obj2的name属性也会被修改。因为obj和obj2指向的是堆内存中的同一个地址。 对象的分类1.内置对象： 由ES标准中定义的对象，在任何的ES的实现中都可以使用 比如：Math、String、Number、Boolean、Function、Object…. 2.宿主对象： 由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象。 比如 BOM DOM。比如console、document。 3.自定义对象： 由开发人员自己创建的对象 对象的基本操作创建对象使用new关键字调用的函数，是构造函数constructor。构造函数是专门用来创建对象的函数。 例如： 1var obj = new Object(); 记住，使用typeof检查一个对象时，会返回object。 向对象中添加属性在对象中保存的值称为属性。 向对象添加属性的语法： 1对象.属性名 = 属性值; 举例： 123456789101112var obj = new Object();//向obj中添加一个name属性obj.name = \"孙悟空\";//向obj中添加一个gender属性obj.gender = \"男\";//向obj中添加一个age属性obj.age = 18;console.log(JSON.stringify(obj)); // 将 obj 以字符串的形式打印出来 打印结果： 12345&#123; &quot;name&quot;:&quot;孙悟空&quot;, &quot;gender&quot;:&quot;男&quot;, &quot;age&quot;:18&#125; 获取对象中的属性方式1： 语法： 1对象.属性名 如果获取对象中没有的属性，不会报错而是返回undefined。 举例： 1234567891011121314var obj = new Object();//向obj中添加一个name属性obj.name = \"孙悟空\";//向obj中添加一个gender属性obj.gender = \"男\";//向obj中添加一个age属性obj.age = 18;// 获取对象中的属性，并打印出来console.log(obj.gender); // 打印结果：男console.log(obj.color); // 打印结果：undefined 方式2：可以使用[]这种形式去操作属性 对象的属性名不强制要求遵守标识符的规范，不过我们尽量要按照标识符的规范去做。 但如果确实要使用特殊的属性名，就不能采用.的方式来操作对象的属性。比如说，123这种属性名，如果我们直接写成obj.123 = 789来操作属性，是会报错的。那怎么办呢？办法如下： 语法格式如下：（读取时，也是采用这种方式） 12// 注意，括号里的属性名，必须要加引号对象['属性名'] = 属性值 上面这种语法格式，举例如下： 1obj['123'] = 789; 重要：使用[]这种形式去操作属性，更加的灵活，因为，我们可以在[]中直接传递一个变量。 修改对象的属性值语法： 1对象.属性名 = 新值 1obj.name = \"tom\"; 删除对象的属性语法： 1delete obj.name; in 运算符通过该运算符可以检查一个对象中是否含有指定的属性。如果有则返回true，没有则返回false。 语法： 1\"属性名\" in 对象 举例： 12//检查obj中是否含有name属性console.log(\"name\" in obj); 我们平时使用的对象不一定是自己创建的，可能是别人提供的，这个时候，in 运算符可以派上用场。 对象字面量如果要创建一个对象，我们可以使用下面这种方式： 1var obj = new Object(); 但是上面的这种方式，比较麻烦，我们还有更简洁的方式来创建一个对象。如下。 使用对象字面量来创建一个对象： 1var obj = &#123;&#125;; 使用对象字面量，可以在创建对象时，直接指定对象中的属性。语法：{属性名:属性值,属性名:属性值….} 例如： 12345678910111213var obj2 = &#123; name: \"猪八戒\", age: 13, gender: \"男\", test: &#123; name: \"沙僧\" &#125; //我们还可以在对象中增加一个方法。以后可以通过obj2.sayName()的方式调用这个方法 sayName: function()&#123; console.log('smyhvae'); &#125;&#125;; 对象字面量的属性名可以加引号也可以不加，建议不加。如果要使用一些特殊的名字，则必须加引号。 属性名和属性值是一组一组的键值对结构，键和值之间使用:连接，多个值对之间使用,隔开。如果一个属性之后没有其他的属性了，就不要写,，因为它是对象的最后一个属性。 遍历对象中的属性：for … in语法： 123for (var 变量 in 对象名) &#123;&#125; 解释：对象中有几个属性，循环体就会执行几次。每次执行时，会将对象中的每个属性的 属性名 赋值给变量。 语法举例： 1234for (var key in obj) &#123; console.log(key); // 这里的 key 是：对象属性的键 console.log(obj[key]); // 这里的 obj[key] 是：对象属性的值&#125; 举例： 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; var obj = &#123; name: \"smyhvae\", age: 26, gender: \"男\", address: \"shenzhen\", sayHi: function() &#123; console.log(this.name); &#125; &#125;; // 遍历对象中的属性 for (var key in obj) &#123; console.log(\"属性名:\" + key); console.log(\"属性值:\" + obj[key]); // 注意，因为这里的属性名 keu 是变量，所以，如果想获取属性值，不能写成 obj.key，而是要写成 obj[key] &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 打印结果： 12345678910111213141516属性名:name属性值:smyhvae属性名:age属性值:26属性名:gender属性值:男属性名:address属性值:shenzhen属性名:sayHi属性值:function() &#123; console.log(this.name); &#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"函数","slug":"10-函数","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:54:48.000Z","comments":true,"path":"2020/04/18/10-函数/","link":"","permalink":"http://yoursite.com/2020/04/18/10-%E5%87%BD%E6%95%B0/","excerpt":"前言关于函数的核心内容： 函数有哪几种定义和调用方式 this：函数内部的 this 指向、如何改变 this 的指向。 函数的严格模式 高阶函数：函数作为参数传递、函数作为返回值传递 闭包：闭包的作用 递归：递归的两个条件 深拷贝和浅拷贝的区别","text":"前言关于函数的核心内容： 函数有哪几种定义和调用方式 this：函数内部的 this 指向、如何改变 this 的指向。 函数的严格模式 高阶函数：函数作为参数传递、函数作为返回值传递 闭包：闭包的作用 递归：递归的两个条件 深拷贝和浅拷贝的区别 函数的介绍 函数：就是将一些功能或语句进行封装，在需要的时候，通过调用的形式，执行这些语句。 函数也是一个对象 使用typeof检查一个函数对象时，会返回function 函数的作用： 将大量重复的语句抽取出来，写在函数里，以后需要这些语句的时候，可以直接调用函数，避免重复劳动。 简化编程，让编程模块化。高内聚、低耦合。 来看个例子： 12345678console.log(\"你好\");sayHello(); // 调用函数// 定义函数function sayHello()&#123; console.log(\"欢迎\"); console.log(\"welcome\");&#125; 函数的定义/声明方式一：利用函数关键字自定义函数（命名函数）使用函数声明来创建一个函数（也就是 function 关键字）。语法： 123function 函数名([形参1,形参2...形参N])&#123; // 备注：语法中的中括号，表示“可选” 语句...&#125; 举例： 123function fun1(a, b)&#123; return a+b;&#125; 解释如下： function：是一个关键字。中文是“函数”、“功能”。 函数名字：命名规定和变量的命名规定一样。只能是字母、数字、下划线、美元符号，不能以数字开头。 参数：可选。 大括号里面，是这个函数的语句。 PS：在有些编辑器中，方法写完之后，我们在方法的前面输入/**，然后回车，会发现，注释的格式会自动补齐。 方式二：函数表达式（匿名函数）使用函数表达式来创建一个函数。语法： 123var 变量名 = function([形参1,形参2...形参N])&#123; 语句....&#125; 举例： 123var fun2 = function() &#123; console.log(\"我是匿名函数中封装的代码\");&#125;; 解释如下： 上面的 fun2 是变量名，不是函数名。 函数表达式的声明方式跟声明变量类似，只不过变量里面存的是值，而函数表达式里面存的是函数。 函数表达式也可以传递参数。 从方式二的举例中可以看出：所谓的“函数表达式”，其实就是将匿名函数赋值给一个变量。 方式三：使用构造函数 new Function()使用构造函数new Function()来创建一个对象。这种方式，用的少。 语法： 1var 变量名/函数名 = new Function('形参1', '形参2', '函数体'); 注意，Function 里面的参数都必须是字符串格式。也就是说，形参也必须放在字符串里；函数体也是放在字符串里包裹起来，放在 Function 的最后一个参数的位置。 代码举例： 123var fun3 = new Function('a', 'b', 'console.log(\"我是函数内部的内容\"); console.log(a + b);');fun3(1, 2); // 调用函数 打印结果： 12我是函数内部的内容3 分析： 方式3的写法很少用，原因如下： 不方便书写：写法过于啰嗦和麻烦。 执行效率较低：首先需要把字符串转换为 js 代码，然后再执行。 总结1、所有的函数，都是 Fuction 的“实例”（或者说是“实例对象”）。函数本质上都是通过 new Function 得到的。 2、函数既然是实例对象，那么，函数也属于“对象”。还可以通过如下特征，来佐证函数属于对象： （1）我们直接打印某一个函数，比如 console.log(fun2)，发现它的里面有__proto__。 （2）我们还可以打印 console.log(fun2 instanceof Object)，发现打印结果为 true。这说明 fun2 函数就是属于 Object。 函数的调用方式1：普通函数的调用函数调用的语法： 1函数名(); 或者： 1函数名.call(); 代码举例： 1234567891011function fn1() &#123; console.log('我是函数体里面的内容1');&#125;function fn2() &#123; console.log('我是函数体里面的内容2');&#125;fn1(); // 调用函数fn2.call(); // 调用函数 方式2：通过对象的方法来调用12345678var obj = &#123; a: 'qianguyihao', fn2: function() &#123; console.log('千古壹号，永不止步!'); &#125;,&#125;;obj.fn2(); // 调用函数 如果一个函数是作为一个对象的属性保存，那么，我们称这个函数是这个对象的方法。 PS：关于函数和方法的区别，本文的后续内容里有讲到，可以往下面翻。 方式3：立即执行函数代码举例： 123(function() &#123; console.log('我是立即执行函数');&#125;)(); 立即执行函数在定义后，会自动调用。 PS：关于立即执行函数，本文的后续内容里有讲到，可以往下面翻。 上面讲到的这三种方式，是用得最多的。接下来讲到的三种方式，暂时看不懂也没关系，可以等学完其他的知识点，再回过头来看。 方式4：通过构造函数来调用代码举例： 12345function Fun3() &#123; console.log('啦啦啦啦啦');&#125;new Fun3(); 这种方式用得不多。 方式5：绑定事件函数代码举例： 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"btn\"&gt;我是按钮，请点击我&lt;/div&gt; &lt;script&gt; var btn = document.getElementById('btn'); //2.绑定事件 btn.onclick = function() &#123; console.log('点击按钮后，要做的事情'); &#125;; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 这里涉及到DOM操作和事件的知识点，后续再讲。 方式6：定时器函数代码举例：（每间隔一秒，将 数字 加1） 12345 let num = 1;setInterval(function () &#123; num ++; console.log(num);&#125;, 1000); 这里涉及到定时器的知识点。 函数的参数：形参和实参函数的参数包括形参和实参。 形参： 概念：形式上的参数。定义函数时传递的参数，当时并不知道是什么值。 定义函数时，可以在函数的()中来指定一个或多个形参。 多个形参之间使用,隔开，声明形参就相当于在函数内部声明了对应的变量，但是并不赋值。 实参： 概念：实际上的参数。调用函数时传递的参数，实参将会传递给函数中对应的形参。 在调用函数时，可以在函数的 ()中指定实参。 注意：实际参数和形式参数的个数，一般要相同。 举例： 123456789// 调用函数sum(3,4);sum(\"3\",4);sum(\"Hello\",\"World\");// 定义函数：求和function sum(a, b) &#123; console.log(a + b);&#125; 控制台输出结果： 123734helloworld 实参的类型函数的实参可以是任意的数据类型。 调用函数时，解析器不会检查实参的类型，所以要注意，是否有可能会接收到非法的参数，如果有可能则需要对参数进行类型的检查。 实参的数量（实参和形参的个数不匹配时）调用函数时，解析器也不会检查实参的数量。 如果实参的数量多余形参的数量，多余实参不会被赋值。 如果实参的数量少于形参的数量，多余的形参会被定义为 undefined。表达式的运行结果为 NaN。 代码举例： 1234567function sum(a, b) &#123; console.log(a + b);&#125;sum(1, 2);sum(1, 2, 3);sum(1); 打印结果： 1234533NaN 注意：在 JS 中，形参的默认值是 undefined。 函数的返回值举例： 123456console.log(sum(3, 4)); // 将函数的返回值打印出来//函数：求和function sum(a, b) &#123; return a + b;&#125; return 的作用是结束方法。 注意： return 的值将会作为函数的执行结果返回，可以定义一个变量，来接收该结果。 在函数中，return后的语句都不会执行（函数在执行完 return 语句之后停止并立即退出函数） 如果return语句后不跟任何值，就相当于返回一个undefined 如果函数中不写return，则也会返回undefined 返回值可以是任意的数据类型，可以是对象，也可以是函数。 return 只能返回一个值。如果用逗号隔开多个值，则以最后一个为准。 函数名、函数体和函数加载问题（重要，请记住）我们要记住：函数名 == 整个函数。举例： 123456console.log(fn) == console.log(function fn()&#123;alert(1)&#125;);//定义fn方法function fn()&#123; alert(1)&#125;; 我们知道，当我们在调用一个函数时，通常使用函数()这种格式；可如果，我们是直接使用函数这种格式，它的作用相当于整个函数。 函数的加载问题：JS加载的时候，只加载函数名，不加载函数体。所以如果想使用内部的成员变量，需要调用函数。 fn() 和 fn 的区别【重要】 fn()：调用函数。调用之后，还获取了函数的返回值。 fn：函数对象。相当于直接获取了整个函数对象。 break、continue、return 的区别 break ：结束当前的循环体（如 for、while） continue ：跳出本次循环，继续执行下次循环（如 for、while） return ：1、退出循环。2、返回 return 语句中的值，同时结束当前的函数体内的代码，退出当前函数。 立即执行函数现有匿名函数如下： 1234function(a, b) &#123; console.log(\"a = \" + a); console.log(\"b = \" + b);&#125;; 立即执行函数如下： 1234(function(a, b) &#123; console.log(\"a = \" + a); console.log(\"b = \" + b);&#125;)(123, 456); 立即执行函数：函数定义完，立即被调用，这种函数叫做立即执行函数。 立即执行函数往往只会执行一次。为什么呢？因为没有变量保存它，执行完了之后，就找不到它了。 方法函数也可以成为对象的属性。如果一个函数是作为一个对象的属性保存，那么，我们称这个函数是这个对象的方法。 调用这个函数就说调用对象的方法（method）。函数和方法，有什么本质的区别吗？它只是名称上的区别，并没有其他的区别。 函数举例： 12// 调用函数fn(); 方法举例： 12// 调用方法obj.fn(); 我们可以这样说，如果直接是fn()，那就说明是函数调用。如果是XX.fn()的这种形式，那就说明是方法调用。 arguments 的使用当我们不确定有多少个参数传递的时候，可以用 arguments 来获取。在 JavaScript 中，arguments 实际上是当前函数的一个内置对象。所有函数都内置了一个 arguments 对象（只有函数才有 arguments 对象），arguments 对象中存储了传递的所有实参. arguments的展示形式是一个伪数组。伪数组具有以下特点： 可以进行遍历；具有数组的 length 属性。 按索引方式存储数据。 不具有数组的 push()、pop() 等方法。 代码举例：利用 arguments 求函数实参中的最大值 代码实现： 123456789101112function getMaxValue() &#123; var max = arguments[0]; // 通过 arguments 遍历实参 for (var i = 0; i &lt; arguments.length; i++) &#123; if (max &lt; arguments[i]) &#123; max = arguments[i]; &#125; &#125; return max;&#125;console.log(getMaxValue(1, 3, 7, 5)); 箭头函数箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super或new.target。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。 基本语法： 12345678910(param1, param2, …, paramN) &#x3D;&gt; &#123; statements &#125; (param1, param2, …, paramN) &#x3D;&gt; expression&#x2F;&#x2F;相当于：(param1, param2, …, paramN) &#x3D;&gt;&#123; return expression; &#125;&#x2F;&#x2F; 当只有一个参数时，圆括号是可选的：(singleParam) &#x3D;&gt; &#123; statements &#125;singleParam &#x3D;&gt; &#123; statements &#125;&#x2F;&#x2F; 没有参数的函数应该写成一对圆括号。() &#x3D;&gt; &#123; statements &#125; 引入箭头函数有两个方面的作用：更简短的函数并且不绑定this。 没有单独的this 在箭头函数出现之前，每一个新函数根据它是被如何调用的来定义这个函数的this值： 如果是该函数是一个构造函数，this指针指向一个新的对象 在严格模式下的函数调用下，this指向undefined 如果是该函数是一个对象的方法，则它的this指针指向这个对象 等等 不绑定arguments箭头函数不绑定Arguments 对象。 使用 new 操作符箭头函数不能用作构造器，和 new一起用会抛出错误。 12var Foo &#x3D; () &#x3D;&gt; &#123;&#125;;var foo &#x3D; new Foo(); &#x2F;&#x2F; TypeError: Foo is not a constructor 箭头函数没有prototype属性。使用 yield 关键字 yield 关键字通常不能在箭头函数中使用（除非是嵌套在允许使用的函数内）。因此，箭头函数不能用作函数生成器。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"数组的拓展","slug":"10-数组的扩展","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T03:56:42.000Z","comments":true,"path":"2020/04/18/10-数组的扩展/","link":"","permalink":"http://yoursite.com/2020/04/18/10-%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95/","excerpt":"前言本文主要内容： 扩展运算符 Array.from() Array.of() 数组实例的 copyWithin() 数组实例的 find() 和 findIndex() 数组实例的 fill() 数组实例的 entries()，keys() 和 values() 数组实例的 includes() 数组实例的 flat()，flatMap() 数组的空位 Array.prototype.sort() 的排序稳定性","text":"前言本文主要内容： 扩展运算符 Array.from() Array.of() 数组实例的 copyWithin() 数组实例的 find() 和 findIndex() 数组实例的 fill() 数组实例的 entries()，keys() 和 values() 数组实例的 includes() 数组实例的 flat()，flatMap() 数组的空位 Array.prototype.sort() 的排序稳定性 扩展运算符 含义扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。 12345678console.log(...[1, 2, 3])&#x2F;&#x2F; 1 2 3console.log(1, ...[2, 3, 4], 5)&#x2F;&#x2F; 1 2 3 4 5[...document.querySelectorAll(&#39;div&#39;)]&#x2F;&#x2F; [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;] 扩展运算符与正常的函数参数可以结合使用，非常灵活。 123function f(v, w, x, y, z) &#123; &#125;const args &#x3D; [0, 1];f(-1, ...args, 2, ...[3]); 扩展运算符后面还可以放置表达式。 1234const arr &#x3D; [ ...(x &gt; 0 ? [&#39;a&#39;] : []), &#39;b&#39;,]; 如果扩展运算符后面是一个空数组，则不产生任何效果。 替代apply应用Math.max方法，简化求出一个数组最大元素的写法。 12345678&#x2F;&#x2F; ES5 的写法Math.max.apply(null, [14, 3, 77])&#x2F;&#x2F; ES6 的写法Math.max(...[14, 3, 77])&#x2F;&#x2F; 等同于Math.max(14, 3, 77); Array.from()Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。 下面是一个类似数组的对象，Array.from将它转为真正的数组。 123456789101112let arrayLike &#x3D; &#123; &#39;0&#39;: &#39;a&#39;, &#39;1&#39;: &#39;b&#39;, &#39;2&#39;: &#39;c&#39;, length: 3&#125;;&#x2F;&#x2F; ES5的写法var arr1 &#x3D; [].slice.call(arrayLike); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]&#x2F;&#x2F; ES6的写法let arr2 &#x3D; Array.from(arrayLike); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] 只要是部署了 Iterator 接口的数据结构，Array.from都能将其转为数组。 扩展运算符（…）也可以将某些数据结构转为数组. 对于还没有部署该方法的浏览器，可以用Array.prototype.slice方法替代。 Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。 1234567Array.from(arrayLike, x &#x3D;&gt; x * x);&#x2F;&#x2F; 等同于Array.from(arrayLike).map(x &#x3D;&gt; x * x);Array.from([1, 2, 3], (x) &#x3D;&gt; x * x)&#x2F;&#x2F; [1, 4, 9] Array.of()Array.of方法用于将一组值，转换为数组。 123Array.of(3, 11, 8) &#x2F;&#x2F; [3,11,8]Array.of(3) &#x2F;&#x2F; [3]Array.of(3).length &#x2F;&#x2F; 1 这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。 数组实例的 copyWithin()数组实例的copyWithin()方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。 Array.prototype.copyWithin(target, start = 0, end = this.length) 它接受三个参数。 target（必需）：从该位置开始替换数据。如果为负值，表示倒数。 start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。 end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。 数组实例的 find() 和 findIndex()数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 12[1, 4, -5, 10].find((n) &#x3D;&gt; n &lt; 0)&#x2F;&#x2F; -5 数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 这两个方法都可以发现NaN，弥补了数组的indexOf方法的不足。 数组实例的 fill()fill方法使用给定值，填充一个数组。 12345[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7)&#x2F;&#x2F; [7, 7, 7]new Array(3).fill(7)&#x2F;&#x2F; [7, 7, 7] fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。 数组实例的 entries()，keys() 和 values()ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。 数组实例的 includes()Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。ES2016 引入了该方法。 123[1, 2, 3].includes(2) &#x2F;&#x2F; true[1, 2, 3].includes(4) &#x2F;&#x2F; false[1, 2, NaN].includes(NaN) &#x2F;&#x2F; true 该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。 数组实例的 flat()，flatMap()数组的成员有时还是数组，Array.prototype.flat()用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。 12[1, 2, [3, 4]].flat()&#x2F;&#x2F; [1, 2, 3, 4] 上面代码中，原数组的成员里面有一个数组，flat()方法将子数组的成员取出来，添加在原来的位置。 flat()默认只会“拉平”一层，如果想要拉平多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1。 如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。 flatMap()方法对原数组的每个成员执行一个函数（相当于执行Array.prototype.map()），然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组。 123&#x2F;&#x2F; 相当于 [[2, 4], [3, 6], [4, 8]].flat()[2, 3, 4].flatMap((x) &#x3D;&gt; [x, x * 2])&#x2F;&#x2F; [2, 4, 3, 6, 4, 8] flatMap()只能展开一层数组。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"CSS3属性详解1","slug":"10-CSS3属性详解1","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:54:56.000Z","comments":true,"path":"2020/04/18/10-CSS3属性详解1/","link":"","permalink":"http://yoursite.com/2020/04/18/10-CSS3%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A31/","excerpt":"—## 本文主要内容： 文本 盒模型中的 box-sizing 属性 处理兼容性问题：私有前缀 边框 背景属性 渐变","text":"—## 本文主要内容： 文本 盒模型中的 box-sizing 属性 处理兼容性问题：私有前缀 边框 背景属性 渐变 文本text-shadow：设置文本的阴影格式举例： 1text-shadow: 20px 27px 22px pink; 参数解释：水平位移 垂直位移 模糊程度 阴影颜色。 text-shadow 可以设置多个阴影，每个阴影之间使用逗号隔开。我们来看个例子。 盒模型中的 box-sizing 属性CSS3 对盒模型做出了新的定义，即允许开发人员指定盒子宽度和高度的计算方式。 这就需要用到 box-sizing属性。它的属性值可以是：content-box、border-box。解释如下。 外加模式：（css的默认方式） 1box-sizing: content-box; 解释：此时设置的 width 和 height 是内容区域的宽高。盒子的实际宽度 = 设置的 width + padding + border。此时改变 padding 和 border 的大小，也不会改变内容的宽高，而是盒子的总宽高发生变化。 内减模式：【需要注意】 1box-sizing: border-box; 解释：此时设置的 width 和 height 是盒子的总宽高。盒子的实际宽度 = 设置的 width。此时改变 padding 和 border 的大小，会改变内容的宽高，盒子的总宽高不变。 处理兼容性问题：私有前缀处理兼容性问题的常见方法：为属性添加私有前缀。 如此方法不能解决，应尽量避免使用，无需刻意去处理CSS3的兼容性问题。 私有前缀的举例： 比如说，我想给指定的div设置下面这样一个属性： 1background: linear-gradient(left, green, yellow); 上面这个属性的作用是：添加从左到右的线性渐变，颜色从绿色变为黄色。 此时，我们可以为浏览器添加不同的私有前缀，属性就可以生效了。 格式如下： 1234-webkit-: 谷歌 苹果-moz-:火狐-ms-：IE-o-：欧朋 格式举例如下： 12345background: -webkit-linear-gradient(left, green, yellow);background: -moz-linear-gradient(left, green, yellow);background: -ms-linear-gradient(left, green, yellow);background: -o-linear-gradient(left, green, yellow);background: linear-gradient(left, green, yellow); 边框边框的属性很多，其中边框圆角和边框阴影这两个属性，应用十分广泛，兼容性也相对较好，且符合渐进增强的原则，需要重点熟悉。 边框圆角：border-radius 属性边框的每个圆角，本质上是一个圆，圆有水平半径和垂直半径：如果二者相等，就是圆；如果二者不等， 就是椭圆。 单个属性的写法： 1234567border-top-left-radius: 60px 120px; //参数解释：水平半径 垂直半径border-top-right-radius: 60px 120px;border-bottom-left-radius: 60px 120px;border-bottom-right-radius: 60px 120px; 复合写法： 12345border-radius: 60px&#x2F;120px; &#x2F;&#x2F;参数：水平半径&#x2F;垂直半径border-radius: 20px 60px 100px 140px; &#x2F;&#x2F;从左上开始，顺时针赋值。如果当前角没有值，取对角的值border-radius: 20px 60px; 最简洁的写法：（四个角的半径都相同时） 1border-radius: 60px; 边框阴影：box-shadow 属性格式举例： 123box-shadow: 水平偏移 垂直偏移 模糊程度 阴影大小 阴影颜色box-shadow: 15px 21px 48px -2px #666; 参数解释： 水平偏移：正值向右 负值向左。 垂直偏移：正值向下 负值向上。 模糊程度：不能为负值。 1box-shadow:3px 3px 3px 3px #666 inset; 注意：设置边框阴影不会改变盒子的大小，即不会影响其兄弟元素的布局。 我们还可以设置多重边框阴影，实现更好的效果，增强立体感。 边框图片边框图片有以下属性： 1234567891011121314/* 边框图片的路径*/border-image-source: url(\"images/border.png\");/* 图片边框的裁剪*/border-image-slice: 27;/*图片边框的宽度*/border-image-width: 27px;/*边框图片的平铺*//* repeat :正常平铺 但是可能会显示不完整*//*round: 平铺 但是保证 图片完整*//*stretch: 拉伸显示*/border-image-repeat: stretch; 我们也可以写成一个综合属性： 1border-image: url(\"images/border.png\") 27/20px round;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS3属性：动画","slug":"11-CSS3属性详解：动画详解","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:53:38.000Z","comments":true,"path":"2020/04/18/11-CSS3属性详解：动画详解/","link":"","permalink":"http://yoursite.com/2020/04/18/11-CSS3%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%8A%A8%E7%94%BB%E8%AF%A6%E8%A7%A3/","excerpt":"—## 本文主要内容： 过渡：transition 2D 转换 transform 3D 转换 transform 动画：animation","text":"—## 本文主要内容： 过渡：transition 2D 转换 transform 3D 转换 transform 动画：animation 过渡：transition transition的中文含义是过渡。过渡是CSS3中具有颠覆性的一个特征，可以实现元素不同状态间的平滑过渡（补间动画），经常用来制作动画效果。 补间动画：自动完成从起始状态到终止状态的的过渡。不用管中间的状态。 帧动画：通过一帧一帧的画面按照固定顺序和速度播放。如电影胶片。 transition 包括以下属性： transition-property: all; 如果希望所有的属性都发生过渡，就使用all。 transition-duration: 1s; 过渡的持续时间。 transition-timing-function: linear; 运动曲线。属性值可以是： linear 线性 ease 减速 ease-in 加速 ease-out 减速 ease-in-out 先加速后减速 transition-delay: 1s; 过渡延迟。多长时间后再执行这个过渡动画。 上面的四个属性也可以写成综合属性： 123transition: 让哪些属性进行过度 过渡的持续时间 运动曲线 延迟时间;transition: all 3s linear 0s; 其中，transition-property这个属性是尤其需要注意的，不同的属性值有不同的现象。我们来示范一下。 如果设置 transition-property: width，意思是只让盒子的宽度在变化时进行过渡。 如果设置 transition-property: all，意思是让盒子的所有属性（包括宽度、背景色等）在变化时都进行过渡。 2D 转换转换是 CSS3 中具有颠覆性的一个特征，可以实现元素的位移、旋转、变形、缩放，甚至支持矩阵方式。 转换再配合过渡和动画，可以取代大量早期只能靠 Flash 才可以实现的效果。 在 CSS3 当中，通过 transform 转换来实现 2D 转换或者 3D 转换。 2D转换包括：缩放、移动、旋转。 我们依次来讲解。 1、缩放：scale格式： 123transform: scale(x, y);transform: scale(2, 0.5); 参数解释： x：表示水平方向的缩放倍数。y：表示垂直方向的缩放倍数。如果只写一个值就是等比例缩放。 取值：大于1表示放大，小于1表示缩小。不能为百分比。 2、位移：translate格式： 123transform: translate(水平位移, 垂直位移);transform: translate(-50%, -50%); 参数解释： 参数为百分比，相对于自身移动。 正值：向右和向下。 负值：向左和向上。如果只写一个值，则表示水平移动。 应用：让绝对定位中的盒子在父亲里居中 我们知道，如果想让一个标准流中的盒子在父亲里居中（水平方向看），可以将其设置margin: 0 auto属性。 可如果盒子是绝对定位的，此时已经脱标了，如果还想让其居中（位于父亲的正中间），可以这样做： 12345678div &#123; width: 600px; height: 60px; position: absolute; 绝对定位的盒子 left: 50%; 首先，让左边线居中 top: 0; margin-left: -300px; 然后，向左移动宽度（600px）的一半&#125; 现在，我们还可以利用偏移 translate 来做，这也是比较推荐的写法： 123456789div &#123; width: 600px; height: 60px; background-color: red; position: absolute; 绝对定位的盒子 left: 50%; 首先，让左边线居中 top: 0; transform: translate(-50%); 然后，利用translate，往左走自己宽度的一半【推荐写法】&#125; 3、旋转：rotate格式： 123transform: rotate(角度);transform: rotate(45deg); 参数解释：正值 顺时针；负值：逆时针。 我们给盒子设置了 transform 中的 rotate 旋转，但同时还要给盒子设置 transition 过渡。如果没有这行过渡的代码，旋转会直接一步到位。 rotate 旋转时，默认是以盒子的正中心为坐标原点的。如果想改变旋转的坐标原点，可以用transform-origin属性。格式如下： 12345transform-origin: 水平坐标 垂直坐标;transform-origin: 50px 50px;transform-origin: center bottom; //旋转时，以盒子底部的中心为坐标原点 ： 4、倾斜暂略。 3D 转换1、旋转：rotateX、rotateY、rotateZ旋转的方向：（左手法则） 左手握住旋转轴，竖起拇指指向旋转轴的正方向，正向就是其余手指卷曲的方向。 从上面这句话，我们也能看出：所有的3d旋转，对着正方向去看，都是顺时针旋转。 格式： 12345transform: rotateX(360deg); //绕 X 轴旋转360度transform: rotateY(360deg); //绕 Y 轴旋转360度transform: rotateZ(360deg); //绕 Z 轴旋转360度 2、移动：translateX、translateY、translateZ格式： 12345transform: translateX(100px); //沿着 X 轴移动transform: translateY(360px); //沿着 Y 轴移动transform: translateZ(360px); //沿着 Z 轴移动 3、透视：perspective电脑显示屏是一个 2D 平面，图像之所以具有立体感（3D效果），其实只是一种视觉呈现，通过透视可以实现此目的。 透视可以将一个2D平面，在转换的过程当中，呈现3D效果。但仅仅只是视觉呈现出 3d 效果，并不是正真的3d。 格式有两种写法： 作为一个属性，设置给父元素，作用于所有3D转换的子元素 作为 transform 属性的一个值，做用于元素自身。 格式举例： 1perspective: 500px; 4、3D呈现（transform-style）3D元素构建是指某个图形是由多个元素构成的，可以给这些元素的父元素设置transform-style: preserve-3d来使其变成一个真正的3D图形。属性值可以如下： 123transform-style: preserve-3d; /* 让 子盒子 位于三维空间里 */transform-style: flat; /* 让子盒子位于此元素所在的平面内（子盒子被扁平化） */ 案例：立方体 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .box &#123; width: 250px; height: 250px; border: 1px dashed red; margin: 100px auto; position: relative; border-radius: 50%; /* 让子盒子保持3d效果*/ transform-style: preserve-3d; /*transform:rotateX(30deg) rotateY(-30deg);*/ animation: gun 8s linear infinite; &#125; .box &gt; div &#123; width: 100%; height: 100%; position: absolute; text-align: center; line-height: 250px; font-size: 60px; color: #daa520; &#125; .left &#123; background-color: rgba(255, 0, 0, 0.3); /* 变换中心*/ transform-origin: left; /* 变换*/ transform: rotateY(90deg) translateX(-125px); &#125; .right &#123; background: rgba(0, 0, 255, 0.3); transform-origin: right; /* 变换*/ transform: rotateY(90deg) translateX(125px); &#125; .forward &#123; background: rgba(255, 255, 0, 0.3); transform: translateZ(125px); &#125; .back &#123; background: rgba(0, 255, 255, 0.3); transform: translateZ(-125px); &#125; .up &#123; background: rgba(255, 0, 255, 0.3); transform: rotateX(90deg) translateZ(125px); &#125; .down &#123; background: rgba(99, 66, 33, 0.3); transform: rotateX(-90deg) translateZ(125px); &#125; @keyframes gun &#123; 0% &#123; transform: rotateX(0deg) rotateY(0deg); &#125; 100% &#123; transform: rotateX(360deg) rotateY(360deg); &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"box\"&gt; &lt;div class=\"up\"&gt;上&lt;/div&gt; &lt;div class=\"down\"&gt;下&lt;/div&gt; &lt;div class=\"left\"&gt;左&lt;/div&gt; &lt;div class=\"right\"&gt;右&lt;/div&gt; &lt;div class=\"forward\"&gt;前&lt;/div&gt; &lt;div class=\"back\"&gt;后&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 动画动画是CSS3中具有颠覆性的特征，可通过设置多个节点 来精确控制一个或一组动画，常用来实现复杂的动画效果。 1、定义动画的步骤（1）通过@keyframes定义动画； （2）将这段动画通过百分比，分割成多个节点；然后各节点中分别定义各属性； （3）在指定元素里，通过 animation 属性调用动画。 之前,我们在 js 中定义一个函数的时候，是先定义，再调用： 12345js 定义函数： function fun()&#123; 函数体 &#125; 调用： fun(); 同样，我们在 CSS3 中定义动画的时候，也是先定义，再调用： 12345678定义动画： @keyframes 动画名&#123; from&#123; 初始状态 &#125; to&#123; 结束状态 &#125; &#125; 调用： animation: 动画名称 持续时间； 其中，animation属性的格式如下： 12345animation: 定义的动画名称 持续时间 执行次数 是否反向 运动曲线 延迟执行。(infinite 表示无限次)animation: move1 1s alternate linear 3;animation: move2 4s; 2、动画属性我们刚刚在调用动画时，animation属性的格式如下： animation属性的格式如下： 12345animation: 定义的动画名称 持续时间 执行次数 是否反向 运动曲线 延迟执行。(infinite 表示无限次)animation: move1 1s alternate linear 3;animation: move2 4s; 可以看出，这里的 animation 是综合属性，接下来，我们把这个综合属性拆分看看。 （1）动画名称： 1animation-name: move; （2）执行一次动画的持续时间： 1animation-duration: 4s; 备注：上面两个属性，是必选项，且顺序固定。 （3）动画的执行次数： 1animation-iteration-count: 1; //iteration的含义表示迭代 属性值infinite表示无数次。 （3）动画的方向： 1animation-direction: alternate; 属性值：normal 正常，alternate 反向。 （4）动画延迟执行： 1animation-delay: 1s; （5）设置动画结束时，盒子的状态： 1animation-fill-mode: forwards; 属性值： forwards：保持动画结束后的状态（默认）， backwards：动画结束后回到最初的状态。 （6）运动曲线： 1animation-timing-function: ease-in; 属性值可以是：linear ease-in-out steps()等。 注意，如果把属性值写成steps()，则表示动画不是连续执行，而是间断地分成几步执行。我们接下来专门讲一下属性值 steps()。 steps()的效果我们还是拿上面的例子来举例，如果在调用动画时，我们写成： 1animation: move2 4s steps(2); 有了属性值 steps()，我们就可以作出很多不连续地动画效果。比如时钟；再比如，通过多张静态的鱼，作出一张游动的鱼。 step()举例：时钟的简易模型 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div &#123; width: 3px; height: 200px; background-color: #000; margin: 100px auto; transform-origin: center bottom; /* 旋转的中心点是底部 */ animation: myClock 60s steps(60) infinite; &#125; @keyframes myClock &#123; 0% &#123; transform: rotate(0deg); &#125; 100% &#123; transform: rotate(360deg); &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 上方代码，我们通过一个黑色的长条div，旋转360度，耗时60s，分成60步完成。即可实现。","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"对象的拓展","slug":"11-对象的扩展","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:53:28.000Z","comments":true,"path":"2020/04/18/11-对象的扩展/","link":"","permalink":"http://yoursite.com/2020/04/18/11-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95/","excerpt":"前言本文主要内容： 属性的简洁表示法 属性名表达式 方法的 name 属性 属性的可枚举性和遍历 super 关键字 对象的扩展运算符 链判断运算符 Null 判断运算符","text":"前言本文主要内容： 属性的简洁表示法 属性名表达式 方法的 name 属性 属性的可枚举性和遍历 super 关键字 对象的扩展运算符 链判断运算符 Null 判断运算符 属性的简洁表示法 ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。 1234567const foo &#x3D; &#39;bar&#39;;const baz &#x3D; &#123;foo&#125;;baz &#x2F;&#x2F; &#123;foo: &quot;bar&quot;&#125;&#x2F;&#x2F; 等同于const baz &#x3D; &#123;foo: foo&#125;; 上面代码中，变量foo直接写在大括号里面。这时，属性名就是变量名, 属性值就是变量值。下面是另一个例子。 1234567891011function f(x, y) &#123; return &#123;x, y&#125;;&#125;&#x2F;&#x2F; 等同于function f(x, y) &#123; return &#123;x: x, y: y&#125;;&#125;f(1, 2) &#x2F;&#x2F; Object &#123;x: 1, y: 2&#125; 除了属性简写，方法也可以简写。 12345678910111213const o &#x3D; &#123; method() &#123; return &quot;Hello!&quot;; &#125;&#125;;&#x2F;&#x2F; 等同于const o &#x3D; &#123; method: function() &#123; return &quot;Hello!&quot;; &#125;&#125;; 下面是一个实际的例子。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546let birth &#x3D; &#39;2000&#x2F;01&#x2F;01&#39;;const Person &#x3D; &#123; name: &#39;张三&#39;, &#x2F;&#x2F;等同于birth: birth birth, &#x2F;&#x2F; 等同于hello: function ()... hello() &#123; console.log(&#39;我的名字是&#39;, this.name); &#125;&#125;;这种写法用于函数的返回值，将会非常方便。function getPoint() &#123; const x &#x3D; 1; const y &#x3D; 10; return &#123;x, y&#125;;&#125;getPoint()&#x2F;&#x2F; &#123;x:1, y:10&#125;CommonJS 模块输出一组变量，就非常合适使用简洁写法。let ms &#x3D; &#123;&#125;;function getItem (key) &#123; return key in ms ? ms[key] : null;&#125;function setItem (key, value) &#123; ms[key] &#x3D; value;&#125;function clear () &#123; ms &#x3D; &#123;&#125;;&#125;module.exports &#x3D; &#123; getItem, setItem, clear &#125;;&#x2F;&#x2F; 等同于module.exports &#x3D; &#123; getItem: getItem, setItem: setItem, clear: clear&#125;; 属性的赋值器（setter）和取值器（getter），事实上也是采用这种写法。 1234567891011121314const cart &#x3D; &#123; _wheels: 4, get wheels () &#123; return this._wheels; &#125;, set wheels (value) &#123; if (value &lt; this._wheels) &#123; throw new Error(&#39;数值太小了！&#39;); &#125; this._wheels &#x3D; value; &#125;&#125; 简洁写法在打印对象时也很有用。 123456789101112let user &#x3D; &#123; name: &#39;test&#39;&#125;;let foo &#x3D; &#123; bar: &#39;baz&#39;&#125;;console.log(user, foo)&#x2F;&#x2F; &#123;name: &quot;test&quot;&#125; &#123;bar: &quot;baz&quot;&#125;console.log(&#123;user, foo&#125;)&#x2F;&#x2F; &#123;user: &#123;name: &quot;test&quot;&#125;, foo: &#123;bar: &quot;baz&quot;&#125;&#125; 上面代码中，console.log直接输出user和foo两个对象时，就是两组键值对，可能会混淆。把它们放在大括号里面输出，就变成了对象的简洁表示法，每组键值对前面会打印对象名，这样就比较清晰了。 注意，简写的对象方法不能用作构造函数，会报错。 1234567const obj &#x3D; &#123; f() &#123; this.foo &#x3D; &#39;bar&#39;; &#125;&#125;;new obj.f() &#x2F;&#x2F; 报错 上面代码中，f是一个简写的对象方法，所以obj.f不能当作构造函数使用。 属性名表达式JavaScript 定义对象的属性，有两种方法。 12345&#x2F;&#x2F; 方法一obj.foo &#x3D; true;&#x2F;&#x2F; 方法二obj[&#39;a&#39; + &#39;bc&#39;] &#x3D; 123; 上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。 但是，如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用方法一（标识符）定义属性。 var obj = { foo: true, abc: 123};ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。 12345678910111213141516171819let lastWord &#x3D; &#39;last word&#39;;const a &#x3D; &#123; &#39;first word&#39;: &#39;hello&#39;, [lastWord]: &#39;world&#39;&#125;;a[&#39;first word&#39;] &#x2F;&#x2F; &quot;hello&quot;a[lastWord] &#x2F;&#x2F; &quot;world&quot;a[&#39;last word&#39;] &#x2F;&#x2F; &quot;world&quot;表达式还可以用于定义方法名。let obj &#x3D; &#123; [&#39;h&#39; + &#39;ello&#39;]() &#123; return &#39;hi&#39;; &#125;&#125;;obj.hello() &#x2F;&#x2F; hi 注意，属性名表达式与简洁表示法，不能同时使用，会报错。 12345678&#x2F;&#x2F; 报错const foo &#x3D; &#39;bar&#39;;const bar &#x3D; &#39;abc&#39;;const baz &#x3D; &#123; [foo] &#125;;&#x2F;&#x2F; 正确const foo &#x3D; &#39;bar&#39;;const baz &#x3D; &#123; [foo]: &#39;abc&#39;&#125;; 注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]，这一点要特别小心。 方法的 name 属性函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。 1234567const person &#x3D; &#123; sayName() &#123; console.log(&#39;hello!&#39;); &#125;,&#125;;person.sayName.name &#x2F;&#x2F; &quot;sayName&quot; 上面代码中，方法的name属性返回函数名（即方法名）。 如果对象的方法使用了取值函数（getter）和存值函数（setter），则name属性不是在该方法上面，而是该方法的属性的描述对象的get和set属性上面，返回值是方法名前加上get和set。 123456789101112const obj &#x3D; &#123; get foo() &#123;&#125;, set foo(x) &#123;&#125;&#125;;obj.foo.name&#x2F;&#x2F; TypeError: Cannot read property &#39;name&#39; of undefinedconst descriptor &#x3D; Object.getOwnPropertyDescriptor(obj, &#39;foo&#39;);descriptor.get.name &#x2F;&#x2F; &quot;get foo&quot;descriptor.set.name &#x2F;&#x2F; &quot;set foo&quot; 有两种特殊情况：bind方法创造的函数，name属性返回bound加上原函数的名字；Function构造函数创造的函数，name属性返回anonymous。 123456(new Function()).name &#x2F;&#x2F; &quot;anonymous&quot;var doSomething &#x3D; function() &#123; &#x2F;&#x2F; ...&#125;;doSomething.bind().name &#x2F;&#x2F; &quot;bound doSomething&quot; 如果对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述。 12345678const key1 &#x3D; Symbol(&#39;description&#39;);const key2 &#x3D; Symbol();let obj &#x3D; &#123; [key1]() &#123;&#125;, [key2]() &#123;&#125;,&#125;;obj[key1].name &#x2F;&#x2F; &quot;[description]&quot;obj[key2].name &#x2F;&#x2F; &quot;&quot; 上面代码中，key1对应的 Symbol 值有描述，key2没有。 属性的可枚举性和遍历可枚举性对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。 12345678let obj &#x3D; &#123; foo: 123 &#125;;Object.getOwnPropertyDescriptor(obj, &#39;foo&#39;)&#x2F;&#x2F; &#123;&#x2F;&#x2F; value: 123,&#x2F;&#x2F; writable: true,&#x2F;&#x2F; enumerable: true,&#x2F;&#x2F; configurable: true&#x2F;&#x2F; &#125; 描述对象的enumerable属性，称为“可枚举性”，如果该属性为false，就表示某些操作会忽略当前属性。 目前，有四个操作会忽略enumerable为false的属性。 for...in循环：只遍历对象自身的和继承的可枚举的属性。 Object.keys()：返回对象自身的所有可枚举的属性的键名。 JSON.stringify()：只串行化对象自身的可枚举的属性。 Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。 这四个操作之中，前三个是 ES5 就有的，最后一个Object.assign()是 ES6 新增的。其中，只有for…in会返回继承的属性，其他三个方法都会忽略继承的属性，只处理对象自身的属性。实际上，引入“可枚举”（enumerable）这个概念的最初目的，就是让某些属性可以规避掉for…in操作，不然所有内部属性和方法都会被遍历到。比如，对象原型的toString方法，以及数组的length属性，就通过“可枚举性”，从而避免被for…in遍历到。 属性的遍历ES6 一共有 5 种方法可以遍历对象的属性。 （1）for...in for...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。 （2）Object.keys(obj) Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。 （3）Object.getOwnPropertyNames(obj) Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。 （4）Object.getOwnPropertySymbols(obj) Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。 （5）Reflect.ownKeys(obj) Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。 以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。 首先遍历所有数值键，按照数值升序排列。 其次遍历所有字符串键，按照加入时间升序排列。 最后遍历所有Symbol键，按照加入时间升序排列。 12Reflect.ownKeys(&#123; [Symbol()]:0, b:0, 10:0, 2:0, a:0 &#125;)&#x2F;&#x2F; [&#39;2&#39;, &#39;10&#39;, &#39;b&#39;, &#39;a&#39;, Symbol()] 上面代码中，Reflect.ownKeys方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性2和10，其次是字符串属性b和a，最后是 Symbol 属性。 super 关键字我们知道，this关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象。 12345678910111213const proto &#x3D; &#123; foo: &#39;hello&#39;&#125;;const obj &#x3D; &#123; foo: &#39;world&#39;, find() &#123; return super.foo; &#125;&#125;;Object.setPrototypeOf(obj, proto);obj.find() &#x2F;&#x2F; &quot;hello&quot; 上面代码中，对象obj.find()方法之中，通过super.foo引用了原型对象proto的foo属性。 注意，super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。 12345678910111213141516&#x2F;&#x2F; 报错const obj &#x3D; &#123; foo: super.foo&#125;&#x2F;&#x2F; 报错const obj &#x3D; &#123; foo: () &#x3D;&gt; super.foo&#125;&#x2F;&#x2F; 报错const obj &#x3D; &#123; foo: function () &#123; return super.foo &#125;&#125; 上面三种super的用法都会报错，因为对于 JavaScript 引擎来说，这里的super都没有用在对象的方法之中。第一种写法是super用在属性里面，第二种和第三种写法是super用在一个函数里面，然后赋值给foo属性。目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。 JavaScript 引擎内部，super.foo等同于Object.getPrototypeOf(this).foo（属性）或Object.getPrototypeOf(this).foo.call(this)（方法）。 对象的扩展运算符解构赋值对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。 1234let &#123; x, y, ...z &#125; &#x3D; &#123; x: 1, y: 2, a: 3, b: 4 &#125;;x &#x2F;&#x2F; 1y &#x2F;&#x2F; 2z &#x2F;&#x2F; &#123; a: 3, b: 4 &#125; 上面代码中，变量z是解构赋值所在的对象。它获取等号右边的所有尚未读取的键（a和b），将它们连同值一起拷贝过来。 由于解构赋值要求等号右边是一个对象，所以如果等号右边是undefined或null，就会报错，因为它们无法转为对象。 解构赋值必须是最后一个参数，否则会报错。 注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。 另外，扩展运算符的解构赋值，不能复制继承自原型对象的属性。 123456let o1 &#x3D; &#123; a: 1 &#125;;let o2 &#x3D; &#123; b: 2 &#125;;o2.__proto__ &#x3D; o1;let &#123; ...o3 &#125; &#x3D; o2;o3 &#x2F;&#x2F; &#123; b: 2 &#125;o3.a &#x2F;&#x2F; undefined 上面代码中，对象o3复制了o2，但是只复制了o2自身的属性，没有复制它的原型对象o1的属性。 扩展运算符 对象的扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。 123let z &#x3D; &#123; a: 3, b: 4 &#125;;let n &#x3D; &#123; ...z &#125;;n &#x2F;&#x2F; &#123; a: 3, b: 4 &#125; 由于数组是特殊的对象，所以对象的扩展运算符也可以用于数组。 123let foo &#x3D; &#123; ...[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] &#125;;foo&#x2F;&#x2F; &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;&#125; 如果扩展运算符后面是一个空对象，则没有任何效果。 如果扩展运算符后面不是对象，则会自动将其转为对象。 如果扩展运算符后面是字符串，它会自动转成一个类似数组的对象，因此返回的不是空对象。 12&#123;...&#39;hello&#39;&#125;&#x2F;&#x2F; &#123;0: &quot;h&quot;, 1: &quot;e&quot;, 2: &quot;l&quot;, 3: &quot;l&quot;, 4: &quot;o&quot;&#125; 对象的扩展运算符等同于使用Object.assign()方法。 123let aClone &#x3D; &#123; ...a &#125;;&#x2F;&#x2F; 等同于let aClone &#x3D; Object.assign(&#123;&#125;, a); 上面的例子只是拷贝了对象实例的属性，如果想完整克隆一个对象，还拷贝对象原型的属性. 扩展运算符可以用于合并两个对象。 123let ab &#x3D; &#123; ...a, ...b &#125;;&#x2F;&#x2F; 等同于let ab &#x3D; Object.assign(&#123;&#125;, a, b); 如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。 链判断运算符Null判断运算符","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"CSS3属性：Flex布局","slug":"12-CSS3属性：Flex布局图文详解","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:55:46.000Z","comments":true,"path":"2020/04/18/12-CSS3属性：Flex布局图文详解/","link":"","permalink":"http://yoursite.com/2020/04/18/12-CSS3%E5%B1%9E%E6%80%A7%EF%BC%9AFlex%E5%B8%83%E5%B1%80%E5%9B%BE%E6%96%87%E8%AF%A6%E8%A7%A3/","excerpt":"flex 布局的优势1、flex 布局的子元素不会脱离文档流，很好地遵从了“流的特性”。 但你如果用 float 来做布局，float 属性的元素会脱离文档流，而且会涉及到各种 BFC、清除浮动的问题。浮动相关的问题，比较麻烦，所以也成了面试必问的经典题目。但有了 flex 布局之后，这些问题都不存在的。 2、flex 是一种现代的布局方式，是 W3C 第一次提供真正用于布局的 CSS 规范。 flex 非常提供了丰富的属性，非常灵活，让布局的实现更佳多样化，且方便易用。 flex 唯一的缺点就在于，它不支持低版本的 IE 浏览器。","text":"flex 布局的优势1、flex 布局的子元素不会脱离文档流，很好地遵从了“流的特性”。 但你如果用 float 来做布局，float 属性的元素会脱离文档流，而且会涉及到各种 BFC、清除浮动的问题。浮动相关的问题，比较麻烦，所以也成了面试必问的经典题目。但有了 flex 布局之后，这些问题都不存在的。 2、flex 是一种现代的布局方式，是 W3C 第一次提供真正用于布局的 CSS 规范。 flex 非常提供了丰富的属性，非常灵活，让布局的实现更佳多样化，且方便易用。 flex 唯一的缺点就在于，它不支持低版本的 IE 浏览器。 flex 的兼容性问题flex 布局不支持 IE9 及以下的版本；IE10及以上也只是部分支持。如果你的页面不需要处理 IE浏览器的兼容性问题，则可以放心大胆地使用 flex 布局。 概念：弹性盒子、子元素在讲 flex 的知识点之前，我们事先约定两个概念： 弹性盒子：指的是使用 display:flex 或 display:inline-flex 声明的父容器。 子元素/弹性元素：指的是父容器里面的子元素们（父容器被声明为 flex 盒子的情况下）。 概念：主轴和侧轴 主轴：flex容器的主轴，默认是水平方向，从左向右。 侧轴：与主轴垂直的轴称作侧轴，默认是垂直方向，从上往下。 主轴和侧轴并不是固定不变的，可以通过 flex-direction 更换方向。 弹性盒子声明定义使用 display:flex 或 display:inline-flex 声明一个父容器为弹性盒子。此时，这个父容器里的子元素们，会遵循弹性布局。 一般是用 display:flex这个属性。display:inline-flex用得较少。 flex-direction 属性flex-direction：用于设置盒子中子元素的排列方向。属性值可以是： 属性值 描述 row 从左到右水平排列子元素（默认值） column 从上到下垂直排列子元素 row-reverse 从右向左排列子元素 column-reverse 从下到上垂直排列子元素 如果我们不给父容器写flex-direction这个属性，那么，子元素默认就是从左到右排列的。 flex-wrap 属性flex-wrap：控制子元素溢出时的换行处理。 justify-content 属性justify-content：控制子元素在主轴上的排列方式。 弹性元素justify-content 属性 justify-content: flex-start; 设置子元素在主轴上的对齐方式。属性值可以是： flex-start 从主轴的起点对齐（默认值） flex-end 从主轴的终点对齐 center 居中对齐 space-around 在父盒子里平分 space-between 两端对齐 平分 align-items 属性align-items：设置子元素在侧轴上的对齐方式。属性值可以是： - flex-start 从侧轴开始的方向对齐 - flex-end 从侧轴结束的方向对齐 - baseline 基线 默认同flex-start - center 中间对齐 - stretch 拉伸 总结 属性值 描述 flex-direction 设置主轴方向，确定弹性子元素排列方式。 flex-wrap 当弹性子元素超出弹性容器范围时是否换行。 flex-flow flex-direction和flex-wrap属性的快捷方式，复合属性。 justify-content 主轴上的对齐方式。 align-items 侧轴上的对齐方式。 align-content 侧轴上有空白时，侧轴的对齐方式。 多列属性 属性值 描述 columns 复合属性，设置宽度和列数 column-width 设置每列的宽度 column-count 设置列数 column-gap 设置列之间的间隙 column-rule 复合属性(column-rule-width,column-rule-style,column-rule-color)，设置列之间的边框样式 column-fill 设置列的高度是否统一 column-span 设置是否横跨所有列 column-width：&lt;length&gt; | auto column-count：&lt;integer&gt; | auto columns：[column-width] || [column-count] column-gap: &lt;integer&gt; | nomal column-fill: auto | balance column-span: none | all flex 属性可以指定1个，2个或3个值。 单值语法: 值必须为以下其中之一: 一个无单位数(): 它会被当作的值。 一个有效的宽度(width)值: 它会被当作 的值。 关键字none，auto或initial. 双值语法: 第一个值必须为一个无单位数，并且它会被当作 的值。 第二个值必须为以下之一： 一个无单位数：它会被当作 的值。 一个有效的宽度值: 它会被当作 的值。 三值语法: 第一个值必须为一个无单位数，并且它会被当作 的值。 第二个值必须为一个无单位数，并且它会被当作 的值。 第三个值必须为一个有效的宽度值， 并且它会被当作 的值。","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"作用域和变量提升","slug":"11-作用域和变量提升","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:53:20.000Z","comments":true,"path":"2020/04/18/11-作用域和变量提升/","link":"","permalink":"http://yoursite.com/2020/04/18/11-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/","excerpt":"作用域（Scope）的概念 概念：通俗来讲，作用域是一个变量或函数的作用范围。作用域在函数定义时，就已经确定了。 目的：为了提高程序的可靠性，同时减少命名冲突。","text":"作用域（Scope）的概念 概念：通俗来讲，作用域是一个变量或函数的作用范围。作用域在函数定义时，就已经确定了。 目的：为了提高程序的可靠性，同时减少命名冲突。 作用域的分类 在 JS 中，一共有两种作用域：（ES6 之前） 全局作用域：作用于整个 script 标签内部，或者作用域一个独立的 JS 文件。 函数作用域（局部作用域）：作用于函数内的代码环境。 作用域的访问关系在内部作用域中可以访问到外部作用域的变量，在外部作用域中无法访问到内部作用域的变量。 代码举例： 12345678var a = 'aaa';function foo() &#123; var b = 'bbb'; console.log(a); // 打印结果：aaa。说明 内层作用域 可以访问 外层作用域 里的变量&#125;foo();console.log(b); // 报错：Uncaught ReferenceError: b is not defined。说明 外层作用域 无法访问 内层作用域 里的变量 变量的作用域根据作用域的不同，变量可以分为两类：全局变量、布局变量。 全局变量： 在全局作用域下声明的变量，叫「全局变量」。在全局作用域的任何一地方，都可以访问这个变量。 在全局作用域下，使用 var 声明的变量是全局变量。 特殊情况：在函数内不使用 var 声明的变量也是全局变量（不建议这么用）。 局部变量： 定义在函数作用域的变量，叫「局部变量」。 在函数内部，使用 var 声明的变量是局部变量。 函数的形参也是属于局部变量。 从执行效率来看全局变量和局部变量： 全局变量：只有浏览器关闭时才会被销毁，比较占内存。 局部变量：当其所在的代码块运行结束后，就会被销毁，比较节约内存空间。 作用域的上下级关系当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用（就近原则）。如果没有则向上一级作用域中寻找，直到找到全局作用域；如果全局作用域中依然没有找到，则会报错 ReferenceError。 在函数中要访问全局变量可以使用window对象。（比如说，全局作用域和函数作用域都定义了变量a，如果想访问全局变量，可以使用window.a） 全局作用域直接编写在script标签中的JS代码，都在全局作用域。 全局作用域在页面打开时创建，在页面关闭时销毁。 在全局作用域中有一个全局对象window，它代表的是一个浏览器的窗口，由浏览器创建，我们可以直接使用。 在全局作用域中： 创建的变量都会作为window对象的属性保存。比如在全局作用域内写 var a = 100，这里的 a 等价于 window.a。 创建的函数都会作为window对象的方法保存。 变量的声明提前（变量提升）使用var关键字声明的变量（ 比如 var a = 1），会在所有的代码执行之前被声明（但是不会赋值），但是如果声明变量时不是用var关键字（比如直接写a = 1），则变量不会被声明提前。 举例1： 12console.log(a);var a = 123; 打印结果：undefined。注意，打印结果并没有报错，而是 undefined，说明变量 a 被提前声明了，只是尚未被赋值。 举例2： 12console.log(a);a = 123; //此时a相当于window.a 程序会报错：Uncaught ReferenceError: a is not defined。 举例3： 12a = 123; //此时a相当于window.aconsole.log(a); 打印结果：123。 举例4： 12345678foo();function foo() &#123; if (false) &#123; var i = 123; &#125; console.log(i);&#125; 打印结果：undefined。注意，打印结果并没有报错，而是 undefined。这个例子，再次说明了：变量 i 在函数执行前，就被提前声明了，只是尚未被赋值。 函数的声明提前函数声明： 使用函数声明的形式创建的函数function foo(){}，会被声明提前。 也就是说，整个函数会在所有的代码执行之前就被创建完成。所以，在代码顺序里，我们可以先调用函数，再定义函数。 代码举例： 12345fn1(); // 虽然 函数 fn1 的定义是在后面，但是因为被提前声明了， 所以此处可以调用函数function fn1() &#123; console.log('我是函数 fn1');&#125; 函数表达式： 使用函数表达式创建的函数var foo = function(){}，不会被声明提前，所以不能在声明前调用。 很好理解，因为此时foo被声明了（这里只是变量声明），且为undefined，并没有把 function(){} 赋值给 foo。 函数作用域提醒1：在函数作用域中，也有声明提前的特性： 函数中，使用var关键字声明的变量，会在函数中所有的代码执行之前被声明。 函数中，没有var声明的变量都是全局变量，而且并不会提前声明。 举例： 123456789var a = 1;function foo() &#123; console.log(a); a = 2; // 此处的a相当于window.a&#125;foo();console.log(a); //打印结果是2 上方代码中，执行foo()后，函数里面的打印结果是1。如果去掉第一行代码，执行foo()后，函数里面的打印结果是Uncaught ReferenceError: a is not defined。 提醒2：定义形参就相当于在函数作用域中声明了变量。 123456function fun6(e) &#123; // 这个函数中，因为有了形参 e，此时就相当于在函数内部的第一行代码里，写了 var e; console.log(e);&#125;fun6(); //打印结果为 undefinedfun6(123);//打印结果为123 JavaScript 没有块级作用域（ES6之前）在其他编程语言中（如 Java、C#等），存在块级作用域，由{}包括起来。比如在 Java 语言中，if 语句里创建的变量，只能在if语句内部使用： 12345if(true)&#123; int num = 123; system.out.print(num); // 123&#125;system.out.print(num); // 报错 但是，在 JS 中没有块级作用域（ES6之前）。举例如下： 123456if(true)&#123;var num = 123; console.log(123); //123&#125;console.log(123); //123（可以正常打印） 作用域链引入： 只要是代码，就至少有一个作用域 写在函数内部的局部作用域 如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域 基于上面几条内容，我们可以得出作用域链的概念。 作用域链：内部函数访问外部函数的变量，采用的是链式查找的方式来决定取哪个值，这种结构称之为作用域链。查找时，采用的是就近原则。 代码举例： 12345678910111213var num = 10;function fn() &#123; // 外部函数 var num = 20; function fun() &#123; // 内部函数 console.log(num); &#125; fun();&#125;fn(); 打印结果：20。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Symbol","slug":"13-Symbol","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:56:34.000Z","comments":true,"path":"2020/04/18/13-Symbol/","link":"","permalink":"http://yoursite.com/2020/04/18/13-Symbol/","excerpt":"前言本文主要内容： 概述 作为属性名的 Symbol 属性名的遍历 Symbol.for()，Symbol.keyFor()","text":"前言本文主要内容： 概述 作为属性名的 Symbol 属性名的遍历 Symbol.for()，Symbol.keyFor() 概述 ES5 的对象属性名都是字符串，这容易造成属性名的冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入Symbol的原因。 ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。 Symbol值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。 1234let s &#x3D; Symbol();typeof s&#x2F;&#x2F; &quot;symbol&quot; 上面代码中，变量s就是一个独一无二的值。typeof运算符的结果，表明变量s是 Symbol 数据类型，而不是字符串之类的其他类型。 注意，Symbol函数前不能使用new命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。 Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。 如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值。 1234567const obj &#x3D; &#123; toString() &#123; return &#39;abc&#39;; &#125;&#125;;const sym &#x3D; Symbol(obj);sym &#x2F;&#x2F; Symbol(abc) 注意，Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。 Symbol 值不能与其他类型的值进行运算，会报错。 123456let sym &#x3D; Symbol(&#39;My symbol&#39;);&quot;your symbol is &quot; + sym&#x2F;&#x2F; TypeError: can&#39;t convert symbol to string&#96;your symbol is $&#123;sym&#125;&#96;&#x2F;&#x2F; TypeError: can&#39;t convert symbol to string 但是，Symbol 值可以显式转为字符串。 1234let sym &#x3D; Symbol(&#39;My symbol&#39;);String(sym) &#x2F;&#x2F; &#39;Symbol(My symbol)&#39;sym.toString() &#x2F;&#x2F; &#39;Symbol(My symbol)&#39; 另外，Symbol 值也可以转为布尔值，但是不能转为数值。 作为属性名的 Symbol由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。 1234567891011121314151617let mySymbol &#x3D; Symbol();&#x2F;&#x2F; 第一种写法let a &#x3D; &#123;&#125;;a[mySymbol] &#x3D; &#39;Hello!&#39;;&#x2F;&#x2F; 第二种写法let a &#x3D; &#123; [mySymbol]: &#39;Hello!&#39;&#125;;&#x2F;&#x2F; 第三种写法let a &#x3D; &#123;&#125;;Object.defineProperty(a, mySymbol, &#123; value: &#39;Hello!&#39; &#125;);&#x2F;&#x2F; 以上写法都得到同样结果a[mySymbol] &#x2F;&#x2F; &quot;Hello!&quot; 上面代码通过方括号结构和Object.defineProperty，将对象的属性名指定为一个 Symbol 值。 注意，Symbol 值作为对象属性名时，不能用点运算符。 同理，在对象的内部，使用Symbol值定义属性时，Symbol 值必须放在方括号之中。 还有一点需要注意，Symbol 值作为属性名时，该属性还是公开属性，不是私有属性。 属性名的遍历Symbol 作为属性名，遍历对象的时候，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。 但是，它也不是私有属性，有一个Object.getOwnPropertySymbols()方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。 1234567891011const obj &#x3D; &#123;&#125;;let a &#x3D; Symbol(&#39;a&#39;);let b &#x3D; Symbol(&#39;b&#39;);obj[a] &#x3D; &#39;Hello&#39;;obj[b] &#x3D; &#39;World&#39;;const objectSymbols &#x3D; Object.getOwnPropertySymbols(obj);objectSymbols&#x2F;&#x2F; [Symbol(a), Symbol(b)] 上面代码是Object.getOwnPropertySymbols()方法的示例，可以获取所有 Symbol 属性名。 Symbol.for()，Symbol.keyFor()有时，我们希望重新使用同一个 Symbol 值，Symbol.for()方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个Symbol值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。 1234let s1 &#x3D; Symbol.for(&#39;foo&#39;);let s2 &#x3D; Symbol.for(&#39;foo&#39;);s1 &#x3D;&#x3D;&#x3D; s2 &#x2F;&#x2F; true 上面代码中，s1和s2都是 Symbol 值，但是它们都是由同样参数的Symbol.for方法生成的，所以实际上是同一个值。 Symbol.keyFor()方法返回一个已登记的 Symbol类型值的key。 12345let s1 &#x3D; Symbol.for(&quot;foo&quot;);Symbol.keyFor(s1) &#x2F;&#x2F; &quot;foo&quot;let s2 &#x3D; Symbol(&quot;foo&quot;);Symbol.keyFor(s2) &#x2F;&#x2F; undefined 上面代码中，变量s2属于未登记的 Symbol 值，所以返回undefined。 注意，Symbol.for()为 Symbol 值登记的名字，是全局环境的，不管有没有在全局环境运行。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"CSS属性详解：web字体","slug":"13-CSS3属性详解：Web字体","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:56:40.000Z","comments":true,"path":"2020/04/18/13-CSS3属性详解：Web字体/","link":"","permalink":"http://yoursite.com/2020/04/18/13-CSS3%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3%EF%BC%9AWeb%E5%AD%97%E4%BD%93/","excerpt":"前言开发人员可以为自已的网页指定特殊的字体（将指定字体提前下载到站点中），无需考虑用户电脑上是否安装了此特殊字体。从此，把特殊字体处理成图片的方式便成为了过去。 支持程度比较好，甚至 IE 低版本的浏览器也能支持。","text":"前言开发人员可以为自已的网页指定特殊的字体（将指定字体提前下载到站点中），无需考虑用户电脑上是否安装了此特殊字体。从此，把特殊字体处理成图片的方式便成为了过去。 支持程度比较好，甚至 IE 低版本的浏览器也能支持。 字体的常见格式 不同浏览器所支持的字体格式是不一样的，我们有必要了解一下字体格式的知识。 TureTpe格式：(.ttf).ttf 字体是Windows和Mac的最常见的字体，是一种RAW格式。 支持这种字体的浏览器有IE9+、Firefox3.5+、Chrome4+、Safari3+、Opera10+、iOS Mobile、Safari4.2+。 OpenType格式：(.otf).otf 字体被认为是一种原始的字体格式，其内置在TureType的基础上。 支持这种字体的浏览器有Firefox3.5+、Chrome4.0+、Safari3.1+、Opera10.0+、iOS Mobile、Safari4.2+。 Web Open Font Format格式：(.woff)woff字体是Web字体中最佳格式，他是一个开放的TrueType/OpenType的压缩版本，同时也支持元数据包的分离。 支持这种字体的浏览器有IE9+、Firefox3.5+、Chrome6+、Safari3.6+、Opera11.1+。 Embedded Open Type格式：(.eot).eot字体是IE专用字体，可以从TrueType创建此格式字体，支持这种字体的浏览器有IE4+。 SVG格式：(.svg).svg字体是基于SVG字体渲染的一种格式。 支持这种字体的浏览器有Chrome4+、Safari3.1+、Opera10.0+、iOS Mobile Safari3.2+。 总结： 了解了上面的知识后，我们就需要为不同的浏览器准备不同格式的字体。通常我们会通过字体生成工具帮我们生成各种格式的字体，因此无需过于在意字体格式之间的区别。 下载字体的网站推荐： http://www.zhaozi.cn/ http://www.youziku.com/ WebFont 的使用步骤打开网站http://iconfont.cn/webfont#!/webfont/index，如下： 上图中，比如我想要「思源黑体-粗」这个字体，那我就点击红框中的「本地下载」。 下载完成后是一个压缩包，压缩包链接：http://download.csdn.net/download/smyhvae/10253561 解压后如下： 上图中， 我们把箭头处的html文件打开，里面告诉了我们 webfont 的使用步骤： （1）第一步：使用font-face声明字体 1234567@font-face &#123;font-family: 'webfont'; src: url('webfont.eot'); /* IE9*/ src: url('webfont.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('webfont.woff') format('woff'), /* chrome、firefox */ url('webfont.ttf') format('truetype'), /* chrome、firefox、opera、Safari, Android, iOS 4.2+*/ url('webfont.svg#webfont') format('svg'); /* iOS 4.1- */&#125; （2）第二步：定义使用webfont的样式 123456.web-font&#123; font-family:\"webfont\" !important; font-size:16px;font-style:normal; -webkit-font-smoothing: antialiased; -webkit-text-stroke-width: 0.2px; -moz-osx-font-smoothing: grayscale;&#125; （3）第三步：为文字加上对应的样式 1&lt;i class=\"web-font\"&gt;这一分钟，你和我在一起，因为你，我会记得那一分钟。从现在开始，我们就是一分钟的朋友。这是事实，你改变不了，因为已经完成了。&lt;/i&gt; 举例： 我们按照上图中的步骤来，引入这个字体。完整版代码如下： 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; p&#123; font-size:30px; &#125; /* 如果要在网页中使用web字体（用户电脑上没有这种字体）*/ /* 第一步：声明字体*/ /* 告诉浏览器 去哪找这个字体*/ @font-face &#123;font-family: 'my-web-font'; src: url('font/webfont.eot'); /* IE9*/ src: url('font/webfont.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('font/webfont.woff') format('woff'), /* chrome、firefox */ url('font/webfont.ttf') format('truetype'), /* chrome、firefox、opera、Safari, Android, iOS 4.2+*/ url('font/webfont.svg#webfont') format('svg'); /* iOS 4.1- */ &#125; /* 第二步：定义一个类名，谁加这类名，就会使用 webfont 字体*/ .webfont&#123; font-family: 'my-web-font'; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 第三步：引用 webfont 字体 --&gt; &lt;p class=\"webfont\"&gt;生命壹号，永不止步&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 代码解释： （1）my-web-font这个名字是随便起的，只要保证第一步和第二步中的名字一样就行。 （2）因为我把字体文件单独放在了font文件夹中，所以在src中引用字体资源时，写的路径是 font/... 字体图标（阿里的 iconfont 网站举例）我们其实可以把图片制作成字体。常见的做法是：把网页中一些小的图标，借助工具生成一个字体包，然后就可以像使用文字一样使用图标了。这样做的优点是： 将所有图标打包成字体库，减少请求； 具有矢量性，可保证清晰度； 使用灵活，便于维护。 也就是说，我们可以把这些图标当作字体来看待，凡是字体拥有的属性（字体大小、颜色等），均适用于图标。 使用步骤如下：（和上一段的使用步骤是一样的） 打开网站http://iconfont.cn/，找到想要的图标，加入购物车。然后下载下来： 压缩包下载之后，解压，打开里面的demo.html，里面告诉了我们怎样引用这些图标。 举例1：（图标字体引用） 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; /*申明字体*/ @font-face &#123;font-family: 'iconfont'; src: url('font/iconfont.eot'); /* IE9*/ src: url('font/iconfont.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('font/iconfont.woff') format('woff'), /* chrome、firefox */ url('font/iconfont.ttf') format('truetype'), /* chrome、firefox、opera、Safari, Android, iOS 4.2+*/ url('font/iconfont.svg#iconfont') format('svg'); /* iOS 4.1- */ &#125; .iconfont&#123; font-family: iconfont; &#125; p&#123; width: 200px; border: 1px solid #000; line-height: 60px; font-size:30px; margin:100px auto; text-align: center; &#125; p span&#123; color:red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 【重要】编码代表图标 --&gt; &lt;p&gt;&lt;span class=\"iconfont\"&gt;&amp;#xe628;&lt;/span&gt;扫码付款&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 举例2：（伪元素的方式使用图标字体） 如果想要在文字的前面加图标字体，我们更习惯采用伪元素的方式进行添加。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; /*申明字体*/ @font-face &#123;font-family: 'iconfont'; src: url('font/iconfont.eot'); /* IE9*/ src: url('font/iconfont.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('font/iconfont.woff') format('woff'), /* chrome、firefox */ url('font/iconfont.ttf') format('truetype'), /* chrome、firefox、opera、Safari, Android, iOS 4.2+*/ url('font/iconfont.svg#iconfont') format('svg'); /* iOS 4.1- */ &#125; p&#123; width: 200px; border: 1px solid #000; line-height: 60px; font-size:30px; margin:100px auto; text-align: center; position: relative; &#125; .icon::before&#123; /*&amp;#xe628;*/ content:\"\\e628\"; /*position: absolute;*/ /*left:10px;*/ /*top:0px;*/ font-family: iconfont; color:red; &#125; span&#123; position: relative; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p class=\"icon\"&gt;扫码付款&lt;/p&gt; &lt;span class=\"icon\" &gt;我是span&lt;/span&gt; &lt;div class=\"icon\"&gt;divvvvvvvvvvv&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 其他相相关网站介绍 Font Awesome 使用介绍：http://fontawesome.dashgame.com/ 定制自已的字体图标库： http://iconfont.cn/ https://icomoon.io/ SVG素材： http://www.iconsvg.com/","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"预编译","slug":"12-预编译","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:55:24.000Z","comments":true,"path":"2020/04/18/12-预编译/","link":"","permalink":"http://yoursite.com/2020/04/18/12-%E9%A2%84%E7%BC%96%E8%AF%91/","excerpt":"JavaScript 运行三部曲 语法分析 预编译 解释执行","text":"JavaScript 运行三部曲 语法分析 预编译 解释执行 预编译前奏 在讲预编译前，我们先来普及下面两个规律。 两个规律规律1：任何变量，如果未经声明就赋值，此变量是属于 window 的属性，而且不会做变量提升。（注意，无论在哪个作用域内赋值） 比如说，如果我们直接在代码里写 console.log(a)，这肯定会报错的，提示找不到 a。但如果我直接写 a = 100，这就不会报错，此时，这个 a 就是 window.a。 规律2：一切声明的全局变量，全是window的属性。（注意，我说的是在全局作用域内声明的全局变量，不是说局部变量） 比如说，当我定义 var a = 200 时，这此时这个 a 就是 window.a。 由此，我们可以看出：window 代表了全局作用域（是说「代表」，没说「等于」）。 举例掌握了上面两句话之后，我们再来看看下面的例子。 1234567891011function foo() &#123; var a = b = 100; // 连续赋值&#125;foo();console.log(window.b); // 在全局范围内访问 bconsole.log(b); // 在全局范围内访问 b，但是前面没有加 window 这个关键字console.log(window.a); // 在全局范围内访问 aconsole.log(a); // 在全局范围内访问 a，但是前面没有加 window 这个关键字 上方代码的打印结果： 1234567100100undefined（会报错，提示 Uncaught ReferenceError: a is not defined） 解释： 当执行了foo()函数之后， var a = b = 100 这行连续赋值的代码等价于 var a = (b = 100)，其执行顺序是： （1）先把 100 赋值给 b； （2）再声明变量 a； （3）再把 b 的值赋值给 a。 我们可以看到，b 是未经声明的变量就被赋值了，此时，根据规律1，这个 b 是属于 window.b；而 a 的作用域仅限于 foo() 函数内部，不属于 window。所以也就有了这样的打印结果。 预编译函数预编译的步骤 函数预编译，发生在函数执行的前一刻。 （1）创建AO对象。AO即 Activation Object 活跃对象，其实就是「执行期上下文」。 （2）找形参和变量声明，将形参名和变量作为 AO 的属性名，值为undefined。 （3）将实参值和形参统一，实参的值赋给形参。 （4）查找函数声明，函数名作为 AO 对象的属性名，值为整个函数体。 这个地方比较难理解。但只有了解了函数的预编译，才能理解明白函数的执行顺序。 代码举例： 12345678910111213141516171819function fn(a) &#123; console.log(a); var a = 666; console.log(a); function a() &#123;&#125; console.log(a); var b = function() &#123;&#125;; console.log(b); function c() &#123;&#125;&#125;fn(1); 打印结果： 1234ƒ a() &#123;&#125;666666ƒ () &#123;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"对象的新增方法","slug":"12-对象的新增方法","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:55:38.000Z","comments":true,"path":"2020/04/18/12-对象的新增方法/","link":"","permalink":"http://yoursite.com/2020/04/18/12-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95/","excerpt":"前言本文主要内容： Object.is() Object.assign() __proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf() Object.keys()，Object.values()，Object.entries()","text":"前言本文主要内容： Object.is() Object.assign() __proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf() Object.keys()，Object.values()，Object.entries() Object.is() Object.is用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。 1234Object.is(&#39;foo&#39;, &#39;foo&#39;)&#x2F;&#x2F; trueObject.is(&#123;&#125;, &#123;&#125;)&#x2F;&#x2F; false 不同之处只有两个：一是+0不等于-0，二是NaN等于自身。 12345+0 &#x3D;&#x3D;&#x3D; -0 &#x2F;&#x2F;trueNaN &#x3D;&#x3D;&#x3D; NaN &#x2F;&#x2F; falseObject.is(+0, -0) &#x2F;&#x2F; falseObject.is(NaN, NaN) &#x2F;&#x2F; true Object.assign()基本用法Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。 1234567const target &#x3D; &#123; a: 1 &#125;;const source1 &#x3D; &#123; b: 2 &#125;;const source2 &#x3D; &#123; c: 3 &#125;;Object.assign(target, source1, source2);target &#x2F;&#x2F; &#123;a:1, b:2, c:3&#125; Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。 注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。 如果只有一个参数，Object.assign会直接返回该参数。 如果该参数不是对象，则会先转成对象，然后返回。 由于undefined和null无法转成对象，所以如果它们作为参数，就会报错。 其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。 123456const v1 &#x3D; &#39;abc&#39;;const v2 &#x3D; true;const v3 &#x3D; 10;const obj &#x3D; Object.assign(&#123;&#125;, v1, v2, v3);console.log(obj); &#x2F;&#x2F; &#123; &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; &#125; Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。 属性名为 Symbol 值的属性，也会被Object.assign拷贝。 注意点 （1）浅拷贝 Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。 （2）同名属性的替换 对于这种嵌套的对象，一旦遇到同名属性，Object.assign的处理方法是替换，而不是添加。 （3）数组的处理 Object.assign可以用来处理数组，但是会把数组视为对象。 12Object.assign([1, 2, 3], [4, 5])&#x2F;&#x2F; [4, 5, 3] 上面代码中，Object.assign把数组视为属性名为 0、1、2 的对象，因此源数组的 0 号属性4覆盖了目标数组的 0 号属性1。 （4）取值函数的处理 Object.assign只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。 __proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()proto属性__proto__属性（前后各两个下划线），用来读取或设置当前对象的原型对象（prototype）。目前，所有浏览器（包括 IE11）都部署了这个属性。 对象具有属性__proto__，可称为隐式原型，一个对象的隐式原型指向构造该对象的构造函数的原型. 对象有__proto__属性，函数有prototype属性； 对象由函数生成; 生成对象时，对象的__proto__属性指向函数的prototype属性。 123456789&#x2F;&#x2F; es5 的写法const obj &#x3D; &#123; method: function() &#123; ... &#125;&#125;;obj.__proto__ &#x3D; someOtherObj;&#x2F;&#x2F; es6 的写法var obj &#x3D; Object.create(someOtherObj);obj.method &#x3D; function() &#123; ... &#125;; 实现上，__proto__调用的是Object.prototype.__proto__。 如果一个对象本身部署了proto属性，该属性的值就是对象的原型。12Object.getPrototypeOf(&#123; __proto__: null &#125;)&#x2F;&#x2F; null Object.setPrototypeOf()Object.setPrototypeOf方法的作用与__proto__相同，用来设置一个对象的原型对象（prototype），返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。 1234567891011&#x2F;&#x2F; 格式Object.setPrototypeOf(object, prototype)&#x2F;&#x2F; 用法const o &#x3D; Object.setPrototypeOf(&#123;&#125;, null);该方法等同于下面的函数。function setPrototypeOf(obj, proto) &#123; obj.__proto__ &#x3D; proto; return obj;&#125; 123456789101112下面是一个例子。let proto &#x3D; &#123;&#125;;let obj &#x3D; &#123; x: 10 &#125;;Object.setPrototypeOf(obj, proto);proto.y &#x3D; 20;proto.z &#x3D; 40;obj.x &#x2F;&#x2F; 10obj.y &#x2F;&#x2F; 20obj.z &#x2F;&#x2F; 40 上面代码将proto对象设为obj对象的原型，所以从obj对象可以读取proto对象的属性。 如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果。 Object.getPrototypeOf()该方法与Object.setPrototypeOf方法配套，用于读取一个对象的原型对象。 123456789101112131415Object.getPrototypeOf(obj);下面是一个例子。function Rectangle() &#123; &#x2F;&#x2F; ...&#125;const rec &#x3D; new Rectangle();Object.getPrototypeOf(rec) &#x3D;&#x3D;&#x3D; Rectangle.prototype&#x2F;&#x2F; trueObject.setPrototypeOf(rec, Object.prototype);Object.getPrototypeOf(rec) &#x3D;&#x3D;&#x3D; Rectangle.prototype&#x2F;&#x2F; false 如果参数不是对象，会被自动转为对象。 Object.keys()，Object.values()，Object.entries()Object.keys()ES5 引入了Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。 123var obj &#x3D; &#123; foo: &#39;bar&#39;, baz: 42 &#125;;Object.keys(obj)&#x2F;&#x2F; [&quot;foo&quot;, &quot;baz&quot;] ES2017 引入了跟Object.keys配套的Object.values和Object.entries，作为遍历一个对象的补充手段，供for...of循环使用。 Object.values()Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。 123const obj &#x3D; &#123; foo: &#39;bar&#39;, baz: 42 &#125;;Object.values(obj)&#x2F;&#x2F; [&quot;bar&quot;, 42] Object.values只返回对象自身的可遍历属性。 如果Object.values方法的参数是一个字符串，会返回各个字符组成的一个数组。 如果参数不是对象，Object.values会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，Object.values会返回空数组。 Object.entries()Object.entries()方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。 123const obj &#x3D; &#123; foo: &#39;bar&#39;, baz: 42 &#125;;Object.entries(obj)&#x2F;&#x2F; [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ] 如果原对象的属性名是一个 Symbol 值，该属性会被忽略。 Object.entries方法的另一个用处是，将对象转为真正的Map结构。 123const obj &#x3D; &#123; foo: &#39;bar&#39;, baz: 42 &#125;;const map &#x3D; new Map(Object.entries(obj));map &#x2F;&#x2F; Map &#123; foo: &quot;bar&quot;, baz: 42 &#125;","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"Set和Map数据结构","slug":"14-Set和Map数据结构","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:56:24.000Z","comments":true,"path":"2020/04/18/14-Set和Map数据结构/","link":"","permalink":"http://yoursite.com/2020/04/18/14-Set%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"前言本文主要内容： Set WeakSet Map","text":"前言本文主要内容： Set WeakSet Map Set 基本用法ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 Set本身是一个构造函数，用来生成 Set 数据结构。 12345678const s &#x3D; new Set();[2, 3, 5, 4, 5, 2, 2].forEach(x &#x3D;&gt; s.add(x));for (let i of s) &#123; console.log(i);&#125;&#x2F;&#x2F; 2 3 5 4 上面代码通过add()方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。 Set函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。 12345678910111213141516171819&#x2F;&#x2F; 例一const set &#x3D; new Set([1, 2, 3, 4, 4]);[...set]&#x2F;&#x2F; [1, 2, 3, 4]&#x2F;&#x2F; 例二const items &#x3D; new Set([1, 2, 3, 4, 5, 5, 5, 5]);items.size &#x2F;&#x2F; 5&#x2F;&#x2F; 例三const set &#x3D; new Set(document.querySelectorAll(&#39;div&#39;));set.size &#x2F;&#x2F; 56&#x2F;&#x2F; 类似于const set &#x3D; new Set();document .querySelectorAll(&#39;div&#39;) .forEach(div &#x3D;&gt; set.add(div));set.size &#x2F;&#x2F; 56 上面代码也展示了一种去除数组重复成员的方法。 12&#x2F;&#x2F; 去除数组的重复成员[...new Set(array)] 上面的方法也可以用于，去除字符串里面的重复字符。 12[...new Set(&#39;ababbc&#39;)].join(&#39;&#39;)&#x2F;&#x2F; &quot;abc&quot; 向 Set 加入值的时候，不会发生类型转换，所以5和”5”是两个不同的值。 另外，两个对象总是不相等的。 1234567let set &#x3D; new Set();set.add(&#123;&#125;);set.size &#x2F;&#x2F; 1set.add(&#123;&#125;);set.size &#x2F;&#x2F; 2 上面代码表示，由于两个空对象不相等，所以它们被视为两个值。 Set 实例的属性和方法Set 结构的实例有以下属性。 Set.prototype.constructor：构造函数，默认就是Set函数。 Set.prototype.size：返回Set实例的成员总数。 Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。 Set.prototype.add(value)：添加某个值，返回 Set 结构本身。 Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员。 Set.prototype.clear()：清除所有成员，没有返回值。 Array.from方法可以将 Set 结构转为数组。这就提供了去除数组重复成员的另一种方法。12345function dedupe(array) &#123; return Array.from(new Set(array));&#125;dedupe([1, 1, 2, 3]) &#x2F;&#x2F; [1, 2, 3] 遍历操作Set 结构的实例有四个遍历方法，可以用于遍历成员。 Set.prototype.keys()：返回键名的遍历器 Set.prototype.values()：返回键值的遍历器 Set.prototype.entries()：返回键值对的遍历器 Set.prototype.forEach()：使用回调函数遍历每个成员 需要特别指出的是，Set的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。 （1）keys()，values()，entries() keys方法、values方法、entries方法返回的都是遍历器对象（详见《Iterator 对象》一章）。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。 123456789101112131415let set &#x3D; new Set([&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]);for (let item of set.keys()) &#123; console.log(item);&#125;&#x2F;&#x2F; red&#x2F;&#x2F; green&#x2F;&#x2F; bluefor (let item of set.values()) &#123; console.log(item);&#125;&#x2F;&#x2F; red&#x2F;&#x2F; green&#x2F;&#x2F; blue （2）forEach() Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。 12345let set &#x3D; new Set([1, 4, 9]);set.forEach((value, key) &#x3D;&gt; console.log(key + &#39; : &#39; + value))&#x2F;&#x2F; 1 : 1&#x2F;&#x2F; 4 : 4&#x2F;&#x2F; 9 : 9 上面代码说明，forEach方法的参数就是一个处理函数。该函数的参数与数组的forEach一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。 另外，forEach方法还可以有第二个参数，表示绑定处理函数内部的this对象。 （3）遍历的应用 扩展运算符（…）内部使用for…of循环，所以也可以用于 Set 结构。 1234567let set &#x3D; new Set([1, 2, 3]);set &#x3D; new Set([...set].map(x &#x3D;&gt; x * 2));&#x2F;&#x2F; 返回Set结构：&#123;2, 4, 6&#125;let set &#x3D; new Set([1, 2, 3, 4, 5]);set &#x3D; new Set([...set].filter(x &#x3D;&gt; (x % 2) &#x3D;&#x3D; 0));&#x2F;&#x2F; 返回Set结构：&#123;2, 4&#125; WeakSetWeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。 首先，WeakSet 的成员只能是对象，而不能是其他类型的值. 其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。 Map含义和基本用法JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。 ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。 Map构造函数接受数组作为参数，实际上执行的是下面的算法。12345678910const items &#x3D; [ [&#39;name&#39;, &#39;张三&#39;], [&#39;title&#39;, &#39;Author&#39;]];const map &#x3D; new Map();items.forEach( ([key, value]) &#x3D;&gt; map.set(key, value)); 事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作Map构造函数的参数。这就是说，Set和Map都可以用来生成新的 Map。 12345678910const set &#x3D; new Set([ [&#39;foo&#39;, 1], [&#39;bar&#39;, 2]]);const m1 &#x3D; new Map(set);m1.get(&#39;foo&#39;) &#x2F;&#x2F; 1const m2 &#x3D; new Map([[&#39;baz&#39;, 3]]);const m3 &#x3D; new Map(m2);m3.get(&#39;baz&#39;) &#x2F;&#x2F; 3 如果对同一个键多次赋值，后面的值将覆盖前面的值。 如果读取一个未知的键，则返回undefined。 只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心 1234const map &#x3D; new Map();map.set([&#39;a&#39;], 555);map.get([&#39;a&#39;]) &#x2F;&#x2F; undefined 上面代码的set和get方法，表面是针对同一个键，但实际上这是两个不同的数组实例，内存地址是不一样的，因此get方法无法读取该键，返回undefined。 Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。 如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如0和-0就是一个键，布尔值true和字符串true则是两个不同的键。另外，undefined和null也是两个不同的键。虽然NaN不严格相等于自身，但 Map 将其视为同一个键。 实例的属性和操作方法Map 结构的实例有以下属性和操作方法。 （1）size 属性 size属性返回 Map 结构的成员总数。 （2）Map.prototype.set(key, value) set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。 12345const m &#x3D; new Map();m.set(&#39;edition&#39;, 6) &#x2F;&#x2F; 键是字符串m.set(262, &#39;standard&#39;) &#x2F;&#x2F; 键是数值m.set(undefined, &#39;nah&#39;) &#x2F;&#x2F; 键是 undefined set方法返回的是当前的Map对象，因此可以采用链式写法。 1234let map &#x3D; new Map() .set(1, &#39;a&#39;) .set(2, &#39;b&#39;) .set(3, &#39;c&#39;); （3）Map.prototype.get(key) get方法读取key对应的键值，如果找不到key，返回undefined。 （4）Map.prototype.has(key) has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。 （5）Map.prototype.delete(key) delete方法删除某个键，返回true。如果删除失败，返回false。 （6）Map.prototype.clear() clear方法清除所有成员，没有返回值。 遍历方法Map 结构原生提供三个遍历器生成函数和一个遍历方法。 Map.prototype.keys()：返回键名的遍历器。 Map.prototype.values()：返回键值的遍历器。 Map.prototype.entries()：返回所有成员的遍历器。 Map.prototype.forEach()：遍历 Map 的所有成员。 需要特别注意的是，Map 的遍历顺序就是插入顺序。 与其他数据结构的互相转换 （1）Map 转为数组 前面已经提过，Map 转为数组最方便的方法，就是使用扩展运算符（…）。 12345const myMap &#x3D; new Map() .set(true, 7) .set(&#123;foo: 3&#125;, [&#39;abc&#39;]);[...myMap]&#x2F;&#x2F; [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ &#39;abc&#39; ] ] ] （2）数组 转为 Map 将数组传入 Map 构造函数，就可以转为 Map。 12345678new Map([ [true, 7], [&#123;foo: 3&#125;, [&#39;abc&#39;]]])&#x2F;&#x2F; Map &#123;&#x2F;&#x2F; true &#x3D;&gt; 7,&#x2F;&#x2F; Object &#123;foo: 3&#125; &#x3D;&gt; [&#39;abc&#39;]&#x2F;&#x2F; &#125; （3）Map 转为对象 如果所有 Map 的键都是字符串，它可以无损地转为对象。 12345678910111213function strMapToObj(strMap) &#123; let obj &#x3D; Object.create(null); for (let [k,v] of strMap) &#123; obj[k] &#x3D; v; &#125; return obj;&#125;const myMap &#x3D; new Map() .set(&#39;yes&#39;, true) .set(&#39;no&#39;, false);strMapToObj(myMap)&#x2F;&#x2F; &#123; yes: true, no: false &#125; 如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。 （4）对象转为 Map 对象转为 Map 可以通过Object.entries()。 12let obj &#x3D; &#123;&quot;a&quot;:1, &quot;b&quot;:2&#125;;let map &#x3D; new Map(Object.entries(obj)); （5）Map 转为 JSON Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。 1234567function strMapToJson(strMap) &#123; return JSON.stringify(strMapToObj(strMap));&#125;let myMap &#x3D; new Map().set(&#39;yes&#39;, true).set(&#39;no&#39;, false);strMapToJson(myMap)&#x2F;&#x2F; &#39;&#123;&quot;yes&quot;:true,&quot;no&quot;:false&#125;&#39; 另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。 1234567function mapToArrayJson(map) &#123; return JSON.stringify([...map]);&#125;let myMap &#x3D; new Map().set(true, 7).set(&#123;foo: 3&#125;, [&#39;abc&#39;]);mapToArrayJson(myMap)&#x2F;&#x2F; &#39;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&#39; （6）JSON 转为 Map JSON 转为 Map，正常情况下，所有键名都是字符串。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"浏览器兼容问题","slug":"14-浏览器的兼容性问题","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T03:42:02.000Z","comments":true,"path":"2020/04/18/14-浏览器的兼容性问题/","link":"","permalink":"http://yoursite.com/2020/04/18/14-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98/","excerpt":"","text":"","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"this","slug":"13-this","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T03:56:54.000Z","comments":true,"path":"2020/04/18/13-this/","link":"","permalink":"http://yoursite.com/2020/04/18/13-this/","excerpt":"this解析器在调用函数每次都会向函数内部传递进一个隐含的参数，这个隐含的参数就是this，this指向的是一个对象，这个对象我们称为函数执行的 上下文对象。 根据函数的调用方式的不同，this会指向不同的对象：【重要】 1.以函数的形式调用时，this永远都是window。比如fun();相当于window.fun(); 2.以方法的形式调用时，this是调用方法的那个对象 3.以构造函数的形式调用时，this是新创建的那个对象 4.使用call和apply调用时，this是指定的那个对象 5.在函数中，严格模式下，this 是 undefined。 6.在事件中，this 指的是接收事件的元素。","text":"this解析器在调用函数每次都会向函数内部传递进一个隐含的参数，这个隐含的参数就是this，this指向的是一个对象，这个对象我们称为函数执行的 上下文对象。 根据函数的调用方式的不同，this会指向不同的对象：【重要】 1.以函数的形式调用时，this永远都是window。比如fun();相当于window.fun(); 2.以方法的形式调用时，this是调用方法的那个对象 3.以构造函数的形式调用时，this是新创建的那个对象 4.使用call和apply调用时，this是指定的那个对象 5.在函数中，严格模式下，this 是 undefined。 6.在事件中，this 指的是接收事件的元素。 针对第1条的举例： 12345678910111213141516171819function fun() &#123; console.log(this); console.log(this.name);&#125;var obj1 = &#123; name: \"smyh\", sayName: fun&#125;;var obj2 = &#123; name: \"vae\", sayName: fun&#125;;var name = \"全局的name属性\";//以函数形式调用，this是windowfun(); //可以理解成 window.fun() 打印结果： 12Window全局的name属性 上面的举例可以看出，this指向的是window对象，所以 this.name 指的是全局的name。 第2条的举例： 12345678910111213141516171819function fun() &#123; console.log(this); console.log(this.name);&#125;var obj1 = &#123; name: \"smyh\", sayName: fun&#125;;var obj2 = &#123; name: \"vae\", sayName: fun&#125;;var name = \"全局的name属性\";//以方法的形式调用，this是调用方法的对象obj2.sayName(); 打印结果： 12Objectvae 上面的举例可以看出，this指向的是 对象 obj2 ，所以 this.name 指的是 obj2.name。 箭头函数中this的指向： ES6中的箭头函数并不会使用上面四条标准的绑定规则，而是会继承外层函数调用的this绑定（无论this绑定到什么）。 类数组 arguments在调用函数时，浏览器每次都会传递进两个隐含的参数： 1.函数的上下文对象 this 2.封装实参的对象 arguments arguments对象是所有（非箭头）函数中都可用的局部变量。你可以使用arguments对象在函数中引用函数的参数。此对象包含传递给函数的每个参数，第一个参数在索引0处。 arguments对象不是一个 Array 。它类似于Array，但除了length属性和索引元素之外没有任何Array属性。 您还可以使用Array.from()方法或扩展运算符将参数转换为真实数组. 12var args &#x3D; Array.from(arguments);var args &#x3D; [...arguments]; 例如： 123456function foo() &#123; console.log(arguments); console.log(typeof arguments);&#125;foo(); arguments是一个类数组对象，它可以通过索引来操作数据，也可以获取长度。 arguments代表的是实参。在调用函数时，我们所传递的实参都会在arguments中保存。有个讲究的地方是：arguments只在函数中使用。 1、返回函数实参的个数：arguments.lengtharguments.length可以用来获取实参的长度。 举例： 1234567891011fn(2,4);fn(2,4,6);fn(2,4,6,8);function fn(a,b) &#123; console.log(arguments); console.log(fn.length); //获取形参的个数 console.log(arguments.length); //获取实参的个数 console.log(\"----------------\");&#125; 我们即使不定义形参，也可以通过arguments来使用实参（只不过比较麻烦）：arguments[0] 表示第一个实参、arguments[1] 表示第二个实参… 2、返回正在执行的函数：arguments.calleearguments里边有一个属性叫做callee，这个属性对应一个函数对象，就是当前正在指向的函数对象。 123456function fun() &#123; console.log(arguments.callee == fun); //打印结果为true&#125;fun(\"hello\"); 在使用函数递归调用时，推荐使用arguments.callee代替函数名本身。 3、arguments可以修改元素之所以说arguments是伪数组，是因为：arguments可以修改元素，但不能改变数组的长短。举例： 12345678fn(2,4);fn(2,4,6);fn(2,4,6,8);function fn(a,b) &#123; arguments[0] = 99; //将实参的第一个数改为99 arguments.push(8); //此方法不通过，因为无法增加元素&#125; call bind apply 的区别简单说一下bind、call、apply的区别 三者都是用于改变函数体内this的指向. 但是bind与apply和call的最大的区别是： bind不会立即调用，而是返回一个新函数，称为绑定函数，其内的this指向为创建它时传入bind的第一个参数，而传入bind的第二个及以后的参数作为原函数的参数来调用原函数。 12345678910var obj &#x3D; &#123;&#125;;function test() &#123; console.log(this &#x3D;&#x3D;&#x3D; obj);&#125;test(); &#x2F;&#x2F;falsevar testObj &#x3D; test.bind(obj);testObj(); &#x2F;&#x2F;true apply和call都是为了改变某个函数运行时的上下文而存在的（就是为了改变函数内部this的指向）；apply和call的调用返回函数执行结果； 如果使用apply或call方法，那么this指向他们的第一个参数，apply的第二个参数是一个参数数组，call的第二个及其以后的参数都是数组里面的元素，就是说要全部列举出来； 以下是MDN文档： bind语法： func.bind(thisArg, [arg1[, arg2[, …]]]) thisArg 当绑定函数被调用时，该参数会作为原函数运行时的this指向。当使用new 操作符调用绑定函数时，该参数无效。arg1, arg2, … 当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。 call语法： fun.call(thisArg, arg1, arg2, …) thisArg:：在fun函数运行时指定的this值。需要注意的是，指定的this值并不一定是该函数执行时真正的this值，如果这个函数处于非严格模式下，则指定为null和undefined的this值会自动指向全局对象(浏览器中就是window对象)，同时值为原始值(数字，字符串，布尔值)的this会指向该原始值的自动包装对象。arg1, arg2, … 指定的参数列表。 apply语法： fun.apply(thisArg, [argsArray]) thisArg： 在 fun 函数运行时指定的 this 值。需要注意的是，指定的 this 值并不一定是该函数执行时真正的 this 值，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象。 argsArray: 一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 fun 函数。如果该参数的值为null 或 undefined，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。 区别总结： 当我们使用一个函数需要改变this指向的时候才会用到call,apply,bind 如果你要传递的参数不多，则可以使用fn.call(thisObj, arg1, arg2 …) 如果你要传递的参数很多，则可以用数组将参数整理好调用fn.apply(thisObj, [arg1, arg2 …]) 如果你想生成一个新的函数长期绑定某个函数给某个对象使用，则可以使用const newFn = fn.bind(thisObj);newFn(arg1, arg2...)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"闭包","slug":"14-闭包","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:56:02.000Z","comments":true,"path":"2020/04/18/14-闭包/","link":"","permalink":"http://yoursite.com/2020/04/18/14-%E9%97%AD%E5%8C%85/","excerpt":"闭包 函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起构成闭包（closure）。也就是说，闭包可以让你从内部函数访问外部函数作用域。在 JavaScript 中，每当函数被创建，就会在函数生成时生成闭包。","text":"闭包 函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起构成闭包（closure）。也就是说，闭包可以让你从内部函数访问外部函数作用域。在 JavaScript 中，每当函数被创建，就会在函数生成时生成闭包。 1234567891011function makeAdder(x) &#123; return function(y) &#123; return x + y; &#125;;&#125;var add5 &#x3D; makeAdder(5);var add10 &#x3D; makeAdder(10);console.log(add5(2)); &#x2F;&#x2F; 7console.log(add10(2)); &#x2F;&#x2F; 12 在这个示例中，我们定义了 makeAdder(x) 函数，它接受一个参数 x ，并返回一个新的函数。返回的函数接受一个参数 y，并返回x+y的值。 从本质上讲，makeAdder 是一个函数工厂 — 他创建了将指定的值和它的参数相加求和的函数。在上面的示例中，我们使用函数工厂创建了两个新函数 — 一个将其参数和 5 求和，另一个和 10 求和。 add5 和 add10 都是闭包。它们共享相同的函数定义，但是保存了不同的词法环境。在 add5 的环境中，x 为 5。而在 add10 中，x 则为 10。 必刷题 当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用（就近原则）。如果没有则向上一级作用域中寻找，直到找到全局作用域；如果全局作用域中依然没有找到，则会报错ReferenceError。 接下来，看这道刷题必刷，面试必考的闭包题： 1234567891011var data &#x3D; [];for (var i &#x3D; 0; i &lt; 3; i++) &#123; data[i] &#x3D; function () &#123; console.log(i); &#125;;&#125;data[0]();data[1]();data[2](); 答案是都是 3，让我们分析一下原因： 当执行到 data[0] 函数之前，此时全局上下文的 VO 为： 123456globalContext &#x3D; &#123; VO: &#123; data: [...], i: 3 &#125;&#125; 当执行 data[0] 函数的时候，data[0] 函数的作用域链为： 123data[0]Context &#x3D; &#123; Scope: [AO, globalContext.VO]&#125; data[0]Context 的AO并没有 i 值，所以会从 globalContext.VO 中查找，i为 3，所以打印的结果就是3。 data[1] 和 data[2] 是一样的道理。 改成闭包： data 123456789101112for (var i &#x3D; 0; i &lt; 3; i++) &#123; data[i] &#x3D; (function (i) &#123; return function()&#123; console.log(i); &#125; &#125;)(i);&#125;data[0]();data[1]();data[2](); 答案是都是 3，让我们分析一下原因： 当执行到 data[0] 函数之前，此时全局上下文的 VO 为： 123456globalContext &#x3D; &#123; VO: &#123; data: [...], i: 3 &#125;&#125; 跟没改之前一模一样。 当执行 data[0] 函数的时候，data[0] 函数的作用域链发生了改变： 123data[0]Context &#x3D; &#123; Scope: [AO, 匿名函数Context.AO globalContext.VO]&#125; 匿名函数执行上下文的AO为： 123456789匿名函数Context &#x3D; &#123; AO: &#123; arguments: &#123; 0: 0, length: 1 &#125;, i: 0 &#125;&#125; data[0]Context 的 AO 并没有 i 值，所以会沿着作用域链从匿名函数 Context.AO中查找，这时候就会找 i 为 0，找到了就不会往 globalContext.VO 中查找了，即使 globalContext.VO 也有 i 的值(值为3)，所以打印的结果就是0。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"CSS常见边框举例","slug":"15-CSS3的常见边框举例","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:57:18.000Z","comments":true,"path":"2020/04/18/15-CSS3的常见边框举例/","link":"","permalink":"http://yoursite.com/2020/04/18/15-CSS3%E7%9A%84%E5%B8%B8%E8%A7%81%E8%BE%B9%E6%A1%86%E4%B8%BE%E4%BE%8B/","excerpt":"CSS3 常见边框汇总","text":"CSS3 常见边框汇总 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;CSS3 边框&lt;/title&gt; &lt;style&gt; body, ul, li, dl, dt, dd, h1, h2, h3, h4, h5 &#123; margin: 0; padding: 0; &#125; body &#123; background-color: #F7F7F7; &#125; .wrapper &#123; width: 1000px; margin: 0 auto; padding: 20px; box-sizing: border-box; &#125; header &#123; padding: 20px 0; margin-bottom: 20px; text-align: center; &#125; header h3 &#123; line-height: 1; font-weight: normal; font-size: 28px; &#125; .main &#123; /*overflow: hidden;*/ &#125; .main:after &#123; content: ''; clear: both; display: block; &#125; .main .item &#123; width: 210px; height: 210px; margin: 0 30px 30px 0; display: flex; position: relative; background-color: #FFF; float: left; box-shadow: 2px 2px 5px #CCC; &#125; .main .item:after &#123; content: attr(data-brief); display: block; width: 100%; height: 100%; text-align: center; line-height: 210px; position: absolute; top: 0; left: 0; color: #FFF; font-family: '微软雅黑'; font-size: 18px; background-color: rgba(170, 170, 170, 0); z-index: -1; transition: all 0.3s ease-in; &#125; .main .item:hover:after &#123; background-color: rgba(170, 170, 170, 0.6); z-index: 100; &#125; .main .item:nth-child(4n) &#123; margin-right: 0; &#125; /*.main .item:nth-last-child(-n+5) &#123; margin-bottom: 0; &#125;*/ /* 以上是骨架样式 */ /* 1、2、3、4 顺时针 */ .border-radius &#123; width: 180px; height: 180px; margin: auto; border: 1px solid red; /*border-radius: 50% 30% 20%;*/ &#125; .square &#123; border-radius: 0; &#125; /*拱形*/ .item:nth-child(1) .border-radius &#123; border-radius: 90px; &#125; /*拱形*/ .item:nth-child(2) .border-radius &#123; border-radius: 90px 90px 0 0; &#125; /*半圆*/ .item:nth-child(3) .border-radius &#123; height: 90px; border-radius: 90px 90px 0 0; &#125; /*左上角*/ .item:nth-child(4) .border-radius &#123; /*height: 90px;*/ border-radius: 90px 0 0 0; &#125; /*四分之一圆*/ .item:nth-child(5) .border-radius &#123; width: 90px; height: 90px; border-radius: 90px 0 0 0; &#125; /*横着的椭圆*/ .item:nth-child(6) .border-radius &#123; height: 90px; /*border-radius: 50%;*/ border-radius: 90px 90px 90px 90px / 45px 45px 45px 45px; /*border-radius: 45px / 90px;*/ &#125; /*竖着的椭圆*/ .item:nth-child(7) .border-radius &#123; width: 90px; border-radius: 45px 45px 45px 45px / 90px 90px 90px 90px; &#125; /*半个横着的椭圆*/ .item:nth-child(8) .border-radius &#123; height: 45px; border-radius: 90px 90px 0 0 / 45px 45px 0 0; &#125; /*半个竖着的椭圆*/ .item:nth-child(9) .border-radius &#123; width: 45px; border-radius: 45px 0 0 45px / 90px 0 0 90px; &#125; /*四分之一竖着的椭圆*/ .item:nth-child(10) .border-radius &#123; width: 45px; height: 90px; border-radius: 45px 0 0 0 / 90px 0 0 0; &#125; /*饼环*/ .item:nth-child(11) .border-radius &#123; width: 40px; height: 40px; border: 70px solid red; border-radius: 90px; &#125; /*圆饼*/ .item:nth-child(12) .border-radius &#123; width: 40px; height: 40px; border: 70px solid red; border-radius: 60px; &#125; /*左上角圆饼*/ .item:nth-child(13) .border-radius &#123; width: 60px; height: 60px; border: 60px solid red; border-radius: 90px 0 0 0; &#125; /*对角圆饼*/ .item:nth-child(14) .border-radius &#123; width: 60px; height: 60px; border: 60px solid red; border-radius: 90px 0 90px 0; &#125; /*四边不同色*/ .item:nth-child(15) .border-radius &#123; width: 0px; height: 0px; border-width: 90px; border-style: solid; border-color: red green yellow blue; &#125; /*右透明色*/ .item:nth-child(16) .border-radius &#123; width: 0px; height: 0px; border-width: 90px; border-style: solid; border-color: red green yellow blue; border-right-color: transparent; &#125; /*圆右透明色*/ .item:nth-child(17) .border-radius &#123; width: 0px; height: 0px; border-width: 90px; border-style: solid; border-color: red; border-right-color: transparent; border-radius: 90px; &#125; /*圆右红透明色*/ .item:nth-child(18) .border-radius &#123; width: 0px; height: 0px; border-width: 90px; border-style: solid; border-color: transparent; border-right-color: red; border-radius: 90px; &#125; /*阴阳图前世*/ .item:nth-child(19) .border-radius &#123; width: 180px; height: 0px; border-top-width: 90px; border-bottom-width: 90px; border-style: solid; border-top-color: red; border-bottom-color: green; /*border-right-color: red;*/ border-radius: 90px; &#125; /*阴阳图前世2*/ .item:nth-child(20) .border-radius &#123; width: 180px; height: 90px; border-bottom-width: 90px; border-style: solid; border-bottom-color: green; background-color: red; /*border-right-color: red;*/ border-radius: 90px; &#125; /*阴阳图今生*/ .item:nth-child(21) .border-radius &#123; width: 180px; height: 90px; border-bottom-width: 90px; border-style: solid; border-bottom-color: green; background-color: red; border-radius: 90px; position: relative; &#125; .item:nth-child(21) .border-radius::after, .item:nth-child(21) .border-radius::before &#123; content: ''; position: absolute; top: 50%; width: 20px; height: 20px; /*margin: -10px 0 0 0;*/ border-width: 35px; border-style: solid; border-radius: 45px; &#125; /*左阴阳*/ .item:nth-child(21) .border-radius::after &#123; background-color: red; border-color: green; &#125; /*右阴阳*/ .item:nth-child(21) .border-radius::before &#123; background-color: green; border-color: red; right: 0; &#125; /*右阴阳*/ .item:nth-child(22) .border-radius &#123; width: 180px; height: 90px; border-bottom-width: 90px; border-bottom-color: green; border-bottom-style: solid; background-color: red; border-radius: 90px; position: relative; &#125; .item:nth-child(22) .border-radius::after, .item:nth-child(22) .border-radius::before &#123; content: ''; position: absolute; top: 50%; width: 20px; height: 20px; border-width: 35px; border-style: solid; border-radius: 45px; &#125; .item:nth-child(22) .border-radius::before &#123; border-color: green; background-color: red; &#125; .item:nth-child(22) .border-radius::after &#123; right: 0; border-color: red; background-color: green; &#125; /*消息框*/ .item:nth-child(23) .border-radius &#123; width: 160px; height: 80px; background-color: red; border-radius: 6px; position: relative; &#125; .item:nth-child(23) .border-radius::after &#123; content: ''; width: 0; height: 0; border-width: 10px; border-style: solid; border-color: transparent; border-right-color: red; position: absolute; top: 16px; left: -20px; &#125; /*奇怪的图形*/ .item:nth-child(24) .border-radius &#123; width: 40px; height: 40px; border-width: 45px 0 45px 70px; border-style: solid; border-radius: 0 0 60px 0; border-color: red; &#125; /*奇怪的图形2*/ .item:nth-child(25) .border-radius &#123; width: 100px; height: 40px; border-width: 45px 20px 45px 70px; border-style: solid; border-radius: 60px; border-color: red; &#125; /*QQ对话*/ .item:nth-child(26) .border-radius &#123; width: 160px; height: 80px; background-color: red; border-radius: 6px; position: relative; &#125; .item:nth-child(26) .border-radius::after &#123; content: ''; position: absolute; top: 0; right: -20px; width: 30px; height: 30px; border-width: 0 0 30px 30px; border-style: solid; border-bottom-color: red; border-left-color: transparent; border-radius: 0 0 60px 0; &#125; /*圆角的百分比设置 */ .item:nth-child(27) .border-radius &#123; width: 180px; /*height: 180px;*/ height: 90px; border-radius: 50%; border-radius: 90px/45px; /*百分比是按横竖两个对应的方向的长度进行计算*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"wrapper\"&gt; &lt;header&gt; &lt;h3&gt;CSS3 边框圆角&lt;/h3&gt; &lt;/header&gt; &lt;div class=\"main\"&gt; &lt;div class=\"item\" data-brief=\"整圆\"&gt; &lt;div class=\"border-radius\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\" data-brief=\"拱形\"&gt; &lt;div class=\"border-radius\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\" data-brief=\"半圆\"&gt; &lt;div class=\"border-radius\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\" data-brief=\"左上角\"&gt; &lt;div class=\"border-radius\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\" data-brief=\"四分之一圆\"&gt; &lt;div class=\"border-radius\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\" data-brief=\"横着的椭圆\"&gt; &lt;div class=\"border-radius\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\" data-brief=\"竖着的椭圆\"&gt; &lt;div class=\"border-radius\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\" data-brief=\"半个横着的椭圆\"&gt; &lt;div class=\"border-radius\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\" data-brief=\"半个竖着的椭圆\"&gt; &lt;div class=\"border-radius\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\" data-brief=\"四分之一竖着的椭圆\"&gt; &lt;div class=\"border-radius\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\" data-brief=\"饼环\"&gt; &lt;div class=\"border-radius\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\" data-brief=\"圆饼\"&gt; &lt;div class=\"border-radius\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\" data-brief=\"左上角圆饼\"&gt; &lt;div class=\"border-radius\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\" data-brief=\"对角圆饼\"&gt; &lt;div class=\"border-radius\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\" data-brief=\"四边不同色\"&gt; &lt;div class=\"border-radius\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\" data-brief=\"右透明色\"&gt; &lt;div class=\"border-radius\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\" data-brief=\"圆右透明色\"&gt; &lt;div class=\"border-radius\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\" data-brief=\"圆右红透明色\"&gt; &lt;div class=\"border-radius\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\" data-brief=\"阴阳图前世\"&gt; &lt;div class=\"border-radius\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\" data-brief=\"阴阳图前世2\"&gt; &lt;div class=\"border-radius\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\" data-brief=\"阴阳图今生\"&gt; &lt;div class=\"border-radius\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\" data-brief=\"阴阳图今生2\"&gt; &lt;div class=\"border-radius\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\" data-brief=\"消息框\"&gt; &lt;div class=\"border-radius\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\" data-brief=\"奇怪的图形\"&gt; &lt;div class=\"border-radius\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\" data-brief=\"奇怪的图形2\"&gt; &lt;div class=\"border-radius\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\" data-brief=\"QQ对话\"&gt; &lt;div class=\"border-radius\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\" data-brief=\"圆角百分比\"&gt; &lt;div class=\"border-radius\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 爱心123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .heart &#123; width: 200px; height: 300px; /*border: 1px solid #000;*/ margin: 100px auto; position: relative; &#125; .heart::before, .heart::after &#123; content: \"左一半\"; width: 100%; height: 100%; position: absolute; background-color: red; left: 0; top: 0; border-radius: 100px 100px 0 0; transform: rotate(-45deg); text-align: center; line-height: 100px; color: yellow; font-size: 30px; font-family: \"MIcrosoft Yahei\"; &#125; .heart::after &#123; content: \"右一半\"; left: 71px; transform: rotate(45deg); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"heart\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下：","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"对象的创建&构造函数","slug":"15-对象的创建&构造函数","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:56:50.000Z","comments":true,"path":"2020/04/18/15-对象的创建&构造函数/","link":"","permalink":"http://yoursite.com/2020/04/18/15-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA&%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/","excerpt":"创建自定义对象的几种方法方式一：对象字面量对象的字面量就是一个{}。里面的属性和方法均是键值对： 键：相当于属性名。 值：相当于属性值，可以是任意类型的值（数字类型、字符串类型、布尔类型，函数类型等）。","text":"创建自定义对象的几种方法方式一：对象字面量对象的字面量就是一个{}。里面的属性和方法均是键值对： 键：相当于属性名。 值：相当于属性值，可以是任意类型的值（数字类型、字符串类型、布尔类型，函数类型等）。 例如： 12345678910var o = &#123; name: \"hello\", age: 26, isBoy: true, sayHi: function() &#123; console.log(this.name); &#125; &#125;;console.log(o); 方式二：工厂模式通过该方法可以大批量的创建对象。 123456789101112131415161718192021/* * 使用工厂方法创建对象 * 通过该方法可以大批量的创建对象 */function createPerson(name, age, gender) &#123; //创建一个新的对象 var obj = new Object(); //向对象中添加属性 obj.name = name; obj.age = age; obj.gender = gender; obj.sayName = function() &#123; alert(this.name); &#125;; //将新的对象返回 return obj;&#125;var obj2 = createPerson(\"猪八戒\", 28, \"男\");var obj3 = createPerson(\"白骨精\", 16, \"女\");var obj4 = createPerson(\"蜘蛛精\", 18, \"女\"); 第一次看到这种工厂模式时，你可能会觉得陌生。如果简化一下，可以写成下面这种形式，更容易理解：（也就是，利用new Object创建对象） 1234567var obj = new Obect();obj.name = '猪八戒';obj.age = 28;obj.gender = '男';obj.sayHi = function() &#123; alert('hello world');&#125;; 弊端： 使用工厂方法创建的对象，使用的构造函数都是Object。所以创建的对象都是Object这个类型，就导致我们无法区分出多种不同类型的对象。 方式三：利用构造函数1234567891011121314151617//利用构造函数自定义对象var stu1 = new Student(\"smyh\");console.log(stu1);stu1.sayHi();var stu2 = new Student(\"vae\");console.log(stu2);stu2.sayHi();// 创建一个构造函数function Student(name) &#123; this.name = name; //this指的是当前对象实例【重要】 this.sayHi = function () &#123; console.log(this.name + \"厉害了\"); &#125;&#125; 接下来，我们专门来讲一下构造函数。 构造函数代码引入123456789101112131415161718// 创建一个构造函数，专门用来创建Person对象function Person(name, age, gender) &#123; this.name = name; this.age = age; this.gender = gender; this.sayName = function() &#123; alert(this.name); &#125;;&#125;var per = new Person(\"孙悟空\", 18, \"男\");var per2 = new Person(\"玉兔精\", 16, \"女\");var per3 = new Person(\"奔波霸\", 38, \"男\");// 创建一个构造函数，专门用来创建 Dog 对象function Dog() &#123;&#125;var dog = new Dog(); 构造函数的概念构造函数：是一种特殊的函数，主要用来创建和初始化对象，也就是为对象的成员变量赋初始值。它与 new 一起使用才有意义。 我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个构造函数里面。 构造函数和普通函数的区别构造函数的创建方式和普通函数没有区别，不同的是构造函数习惯上首字母大写。 构造函数和普通函数的区别就是调用方式的不同：普通函数是直接调用，而构造函数需要使用new关键字来调用。 this的指向也有所不同： 1.以函数的形式调用时，this永远都是window。比如fun();相当于window.fun(); 2.以方法的形式调用时，this是调用方法的那个对象 3.以构造函数的形式调用时，this是新创建的实例对象 new 一个构造函数的执行流程new 在执行时，会做下面这四件事： （1）开辟内存空间，在内存中创建一个新的空对象。 （2）将这个空对象的原型，指向构造函数的prototype属性。 （3）让 this 指向这个新的对象。 （4）执行构造函数里面的代码，给这个新对象添加属性和方法。 （5）返回这个新对象（所以构造函数里面不需要return）。 因为this指的是new一个Object之后的对象实例。于是，下面这段代码： 12345// 创建一个函数function createStudent(name) &#123; var student = new Object(); student.name = name; //第一个name指的是student对象定义的变量。第二个name指的是createStudent函数的参数。二者不一样&#125; 可以改进为： 1234// 创建一个函数function Student(name) &#123; this.name = name; //this指的是构造函数中的对象实例,即Student&#125; 类、实例使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类。 通过一个构造函数创建的对象，称为该类的实例。 instanceof使用 instanceof 可以检查一个对象是否为一个类的实例。 语法如下： 1对象 instanceof 构造函数 如果是，则返回true；否则返回false。 代码举例： 123456789101112function Person() &#123;&#125;function Dog() &#123;&#125;var person1 = new Person();var dog1 = new Dog();console.log(person1 instanceof Person); // 打印结果： trueconsole.log(dog1 instanceof Person); // 打印结果：falseconsole.log(dog1 instanceof Object); // 所有的对象都是Object的后代。因此，打印结果为：true 根据上方代码中的最后一行，需要补充一点：所有的对象都是Object的后代，因此 任何对象 instanceof Object 的返回结果都是true。 othersjson的介绍 对象字面量和json比较像，这里我们对json做一个简单介绍。 JSON：JavaScript Object Notation（JavaScript对象表示形式）。 JSON和对象字面量的区别：JSON的属性必须用双引号引号引起来，对象字面量可以省略。 json举例： 12345678&#123; &quot;name&quot; : &quot;zs&quot;, &quot;age&quot; : 18, &quot;sex&quot; : true, &quot;sayHi&quot; : function() &#123; console.log(this.name); &#125; &#125;; 注：json里一般放常量、数组、对象等，但很少放function。 另外，对象和json没有长度，json.length的打印结果是undefined。于是乎，自然也就不能用for循环遍历（因为遍历时需要获取长度length）。 json遍历的方法： json 采用 for...in...进行遍历，和数组的遍历方式不同。如下： 1234567891011121314&lt;script&gt; var myJson = &#123; \"name\": \"smyhvae\", \"aaa\": 111, \"bbb\": 222 &#125;; //json遍历的方法：for...in... for (var key in myJson) &#123; console.log(key); //获取 键 console.log(myJson[key]); //获取 值（第二种属性绑定和获取值的方法） console.log(\"------\"); &#125;&lt;/script&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Proxy","slug":"15-Proxy","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:56:56.000Z","comments":true,"path":"2020/04/18/15-Proxy/","link":"","permalink":"http://yoursite.com/2020/04/18/15-Proxy/","excerpt":"前言本文主要内容： 概述 this 问题","text":"前言本文主要内容： 概述 this 问题 概述 Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。 Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。 12345678910var obj &#x3D; new Proxy(&#123;&#125;, &#123; get: function (target, propKey, receiver) &#123; console.log(&#96;getting $&#123;propKey&#125;!&#96;); return Reflect.get(target, propKey, receiver); &#125;, set: function (target, propKey, value, receiver) &#123; console.log(&#96;setting $&#123;propKey&#125;!&#96;); return Reflect.set(target, propKey, value, receiver); &#125;&#125;); 上面代码对一个空对象架设了一层拦截，重定义了属性的读取（get）和设置（set）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象obj，去读写它的属性，就会得到下面的结果。 123456obj.count &#x3D; 1&#x2F;&#x2F; setting count!++obj.count&#x2F;&#x2F; getting count!&#x2F;&#x2F; setting count!&#x2F;&#x2F; 2 上面代码说明，Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。 ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。1var proxy &#x3D; new Proxy(target, handler); Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。 下面是另一个拦截读取属性行为的例子。 123456789var proxy &#x3D; new Proxy(&#123;&#125;, &#123; get: function(target, propKey) &#123; return 35; &#125;&#125;);proxy.time &#x2F;&#x2F; 35proxy.name &#x2F;&#x2F; 35proxy.title &#x2F;&#x2F; 35 上面代码中，作为构造函数，Proxy接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有Proxy的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个get方法，用来拦截对目标对象属性的访问请求。get方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回35，所以访问任何属性都得到35。 注意，要使得Proxy起作用，必须针对Proxy实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。 如果handler没有设置任何拦截，那就等同于直接通向原对象。 一个技巧是将 Proxy 对象，设置到object.proxy属性，从而可以在object对象上调用。 var object = { proxy: new Proxy(target, handler) }; Proxy 实例也可以作为其他对象的原型对象。 12345678var proxy &#x3D; new Proxy(&#123;&#125;, &#123; get: function(target, propKey) &#123; return 35; &#125;&#125;);let obj &#x3D; Object.create(proxy);obj.time &#x2F;&#x2F; 35 上面代码中，proxy对象是obj对象的原型，obj对象本身并没有time属性，所以根据原型链，会在proxy对象上读取该属性，导致被拦截。 下面是 Proxy 支持的拦截操作一览，一共 13 种。 get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy[‘foo’]。 set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy[‘foo’] = v，返回一个布尔值。 has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。 deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。 ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。 getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。 defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。 preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。 getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。 isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。 setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。 apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。 construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。 this 问题虽然 Proxy可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理。 1234567891011const target &#x3D; &#123; m: function () &#123; console.log(this &#x3D;&#x3D;&#x3D; proxy); &#125;&#125;;const handler &#x3D; &#123;&#125;;const proxy &#x3D; new Proxy(target, handler);target.m() &#x2F;&#x2F; falseproxy.m() &#x2F;&#x2F; true 上面代码中，一旦proxy代理target.m，后者内部的this就是指向proxy，而不是target。 此外，有些原生对象的内部属性，只有通过正确的this才能拿到，所以 Proxy 也无法代理这些原生对象的属性。123456const target &#x3D; new Date();const handler &#x3D; &#123;&#125;;const proxy &#x3D; new Proxy(target, handler);proxy.getDate();&#x2F;&#x2F; TypeError: this is not a Date object. 上面代码中，getDate方法只能在Date对象实例上面拿到，如果this不是Date对象实例就会报错。这时，this绑定原始对象，就可以解决这个问题。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"CSS中的非布局样式","slug":"16-CSS中的非布局样式","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:58:18.000Z","comments":true,"path":"2020/04/18/16-CSS中的非布局样式/","link":"","permalink":"http://yoursite.com/2020/04/18/16-CSS%E4%B8%AD%E7%9A%84%E9%9D%9E%E5%B8%83%E5%B1%80%E6%A0%B7%E5%BC%8F/","excerpt":"本文主要内容CSS中，有很多非布局样式，这些样式（属性）和与布局无关，包括： 字体、字重、颜色、大小、行高 背景、边框 滚动、换行 装饰性属性（粗体、斜体、下划线）等。","text":"本文主要内容CSS中，有很多非布局样式，这些样式（属性）和与布局无关，包括： 字体、字重、颜色、大小、行高 背景、边框 滚动、换行 装饰性属性（粗体、斜体、下划线）等。 边框文字换行 overflow-wrap：通用的属性。用来说明当一个不能被分开的字符串（单词）太长而不能填充其包裹盒时，为防止其溢出，浏览器是否允许这样的单词中断换行。 word-break：指定了怎样在单词内断行。这里涉及到CJK（中文/日文/韩文）的文字换行。 white-space：空白处是否换行。 上面这三个 css 属性进行组合，可以设置各种不同的属性。 当然，如果想让一段很长的文本不换行，可以直接设置white-space: nowrap 这一个属性即可。 CSS Hack CSS Hack 的方式：不合法但可以生效的写法。 可以用来解决一些浏览器的兼容性问题。 缺点：难理解、难维护、易失效（比如浏览器升级后，hack可能会失效）。 替代方案：特性检测。 替代方案：针对性加 class CSS 效果我们可以利用 CSS 实现各种效果，常见的效果属性有： box-shadow：盒子的阴影 text-shadow：文本的阴影 border-radius background clip-path","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"Reflect","slug":"16-Reflect","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:58:10.000Z","comments":true,"path":"2020/04/18/16-Reflect/","link":"","permalink":"http://yoursite.com/2020/04/18/16-Reflect/","excerpt":"前言本文主要内容： 概述 静态方法","text":"前言本文主要内容： 概述 静态方法 概述 Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect对象的设计目的有这样几个。 （1） 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。 （2） 修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。 1234567891011121314&#x2F;&#x2F; 老写法try &#123; Object.defineProperty(target, property, attributes); &#x2F;&#x2F; success&#125; catch (e) &#123; &#x2F;&#x2F; failure&#125;&#x2F;&#x2F; 新写法if (Reflect.defineProperty(target, property, attributes)) &#123; &#x2F;&#x2F; success&#125; else &#123; &#x2F;&#x2F; failure&#125; （3） 让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。 （4）Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。 静态方法Reflect对象一共有 13 个静态方法。 Reflect.apply(target, thisArg, args) Reflect.construct(target, args) Reflect.get(target, name, receiver) Reflect.set(target, name, value, receiver) Reflect.defineProperty(target, name, desc) Reflect.deleteProperty(target, name) Reflect.has(target, name) Reflect.ownKeys(target) Reflect.isExtensible(target) Reflect.preventExtensions(target) Reflect.getOwnPropertyDescriptor(target, name) Reflect.getPrototypeOf(target) Reflect.setPrototypeOf(target, prototype) 上面这些方法的作用，大部分与Object对象的同名方法的作用都是相同的，而且它与Proxy对象的方法是一一对应的。下面是对它们的解释。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"原型对象","slug":"16-原型对象","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:58:04.000Z","comments":true,"path":"2020/04/18/16-原型对象/","link":"","permalink":"http://yoursite.com/2020/04/18/16-%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1/","excerpt":"原型对象原型的引入","text":"原型对象原型的引入 1234567891011121314151617function Person(name, age, gender) &#123; this.name = name; this.age = age; this.gender = gender; //向对象中添加一个方法 this.sayName = function () &#123; console.log(\"我是\" + this.name); &#125;&#125;//创建一个Person的实例var per = new Person(\"孙悟空\", 18, \"男\");var per2 = new Person(\"猪八戒\", 28, \"男\");per.sayName();per2.sayName();console.log(per.sayName == per2.sayName); //打印结果为false 分析如下： 上方代码中，我们的sayName方法是写在构造函数 Person 内部的，然后在两个实例中进行了调用。造成的结果是，构造函数每执行一次，就会给每个实例创建一个新的 sayName 方法。也就是说，每个实例的sayName都是唯一的。因此，最后一行代码的打印结果为false。 按照上面这种写法，假设创建10000个对象实例，就会创建10000个 sayName 方法。这种写法肯定是不合适的。我们为何不让所有的对象共享同一个方法呢？ 还有一种方式是，将sayName方法在全局作用域中定义：（不建议。原因看注释） 12345678910111213141516function Person(name, age, gender) &#123; this.name = name; this.age = age; this.gender = gender; //向对象中添加一个方法 this.sayName = fun;&#125;//将sayName方法在全局作用域中定义/* * 将函数定义在全局作用域，污染了全局作用域的命名空间 * 而且定义在全局作用域中也很不安全 */function fun() &#123; alert(\"Hello大家好，我是:\" + this.name);&#125;; 比较好的方式是，在原型中添加sayName方法： 123Person.prototype.sayName = function()&#123; alert(\"Hello大家好，我是:\"+this.name);&#125;; 这也就引入了我们本文要讲的「原型」。 prototype 属性：继承成员被定义的地方认识1： 我们所创建的每一个函数，解析器都会向函数中添加一个属性 prototype。这个属性对应着一个对象，这个对象就是我们所谓的原型对象。 如果函数作为普通函数调用prototype没有任何作用，当函数以构造函数的形式调用时，它所创建的实例对象中都会有一个隐含的属性，指向该构造函数的原型，我们可以通过__proto__来访问该属性。 代码举例： 123456789// 定义构造函数function Person() &#123;&#125;var per1 = new Person();var per2 = new Person();console.log(Person.prototype); // 打印结果：[object object]console.log(per1.__proto__ == Person.prototype); // 打印结果：true 上方代码的最后一行：打印结果表明，实例.__proto__ 和 构造函数.prototype都指的是原型对象。 认识2： 原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中。 以后我们创建构造函数时，可以将这些对象共有的属性和方法，统一添加到构造函数的原型对象中，这样就不用分别为每一个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法了。 认识3： 使用 in 检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true。 可以使用对象的hasOwnProperty()来检查对象自身中是否含有该属性。 createObject.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。 在 JavaScript 控制台中输入： 1var person2 &#x3D; Object.create(person1); create()实际做的是从指定原型对象创建一个新的对象。这里以 person1为原型对象创建了 person2 对象。在控制台输入： 1person2.__proto__ 结果返回对象person1。 constructor每个实例对象都从原型中继承了一个constructor属性，该属性指向了用于构造此实例对象的构造函数。 例如，在控制台中尝试下面的指令： 12person1.constructorperson2.constructor 都将返回 Person() 构造器，因为该构造器包含这些实例的原始定义。 一个小技巧是，你可以在 constructor 属性的末尾添加一对圆括号（括号中包含所需的参数），从而用这个构造器创建另一个对象实例。毕竟构造器是一个函数，故可以通过圆括号调用；只需在前面添加 new 关键字，便能将此函数作为构造器使用。 在控制台中输入： 1var person3 &#x3D; new person1.constructor(&#39;Karen&#39;, &#39;Stephenson&#39;, 26, &#39;female&#39;, [&#39;playing drums&#39;, &#39;mountain climbing&#39;]); 现在尝试访问新建对象的属性，例如： 123person3.name.firstperson3.ageperson3.bio() 正常工作。通常你不会去用这种方法创建新的实例；但如果你刚好因为某些原因没有原始构造器的引用，那么这种方法就很有用了。 此外，constructor属性还有其他用途。比如，想要获得某个对象实例的构造器的名字，可以这么用： 1instanceName.constructor.name 具体地，像这样： 1person1.constructor.name 原型链原型对象也是对象，所以它也有原型，当我们使用或访问一个对象的属性或方法时： 它会先在对象自身中寻找，如果有则直接使用； 如果没有则会去原型对象中寻找，如果找到则直接使用； 如果没有则去原型的原型中寻找，直到找到Object对象的原型。 Object对象的原型没有原型，如果在Object原型中依然没有找到，则返回 null 对象的 toString() 方法我们先来看下面这段代码： 12345678910function Person(name, age, gender) &#123;this.name = name;this.age = age;this.gender = gender;&#125;var per1 = new Person(\"vae\", 26, \"男\");console.log(\"per1 = \" + per1);console.log(\"per1 = \" + per1.toString()); 打印结果： 12per1 &#x3D; [object Object]per1 &#x3D; [object Object] 上面的代码中，我们尝试打印实例 per1 的内部信息，但是发现，无论是打印 per1 还是打印 per1.toString()，结果都是object，这是为啥呢？分析如下： 当我们直接在页面中打印一个对象时，其实是输出了对象的toString()方法的返回值。 如果我们希望在打印对象时，不输出[object Object]，可以手动为对象添加一个toString()方法。意思是，重写 toString() 方法。 重写 toString() 方法，具体做法如下： 12345678910111213141516171819202122232425262728293031323334353637383940function Person(name, age, gender) &#123;this.name = name;this.age = age;this.gender = gender;&#125;//方式一：重写 Person 原型的toString方法。针对 Person 的所有实例生效Person.prototype.toString = function() &#123; return ( \"Person[name=\" + this.name + \",age=\" + this.age + \",gender=\" + this.gender + \"]\" );&#125;;// 方式二：仅重写实例 per1 的 toString方法。但是这种写法，只对 per1 生效， 对 per2 无效/*per1.toString = function() &#123; return ( \"Person[name=\" + this.name + \",age=\" + this.age + \",gender=\" + this.gender + \"]\" );&#125;;*/var per1 = new Person(\"smyh\", 26, \"男\");var per2 = new Person(\"vae\", 30, \"男\");console.log(\"per1 = \" + per1);console.log(\"per2 = \" + per2.toString()); 打印结果： 12per1 = Person[name=smyh,age=26,gender=男]per2 = Person[name=vae,age=30,gender=男] 代码分析： 上面的代码中，仔细看注释。我们重写了 Person 原型的 toString()，这样的话，可以保证对 Person 的所有实例生效。 从这个例子，我们可以看出 prototype 的作用。 JS的垃圾回收（GC）机制程序运行过程中会产生垃圾，这些垃圾积攒过多以后，会导致程序运行的速度过慢。所以我们需要一个垃圾回收的机制，来处理程序运行过程中产生垃圾。 当一个对象没有任何的变量或属性对它进行引用时，此时我们将永远无法操作该对象，此时这种对象就是一个垃圾，这种对象过多会占用大量的内存空间，导致程序运行变慢，所以这种垃圾必须进行清理。 上面这句话，也可以这样理解：如果堆内存中的对象，没有任何变量指向它时，这个堆内存里的对象就会成为垃圾。 JS拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁。我们不需要也不能进行垃圾回收的操作。我们仅仅需要做的是：如果你不再使用该对象，那么，将改对象的引用设置为 null 即可。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Promise对象","slug":"17-Promise对象","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:57:40.000Z","comments":true,"path":"2020/04/18/17-Promise对象/","link":"","permalink":"http://yoursite.com/2020/04/18/17-Promise%E5%AF%B9%E8%B1%A1/","excerpt":"前言本文主要内容 Promise 的含义 基本用法 Promise.prototype.then() Promise.prototype.catch() Promise.prototype.finally() Promise.all() Promise.race() Promise.allSettled() Promise.any() Promise.resolve() Promise.reject() 应用 Promise.try()","text":"前言本文主要内容 Promise 的含义 基本用法 Promise.prototype.then() Promise.prototype.catch() Promise.prototype.finally() Promise.all() Promise.race() Promise.allSettled() Promise.any() Promise.resolve() Promise.reject() 应用 Promise.try() Promise 的含义 Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 Promise对象有以下两个特点。 （1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 注意，为了行文方便，本章后面的resolved统一只指fulfilled状态，不包含rejected状态。 有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。 Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 基本用法ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。 下面代码创造了一个Promise实例。 123456789const promise &#x3D; new Promise(function(resolve, reject) &#123; &#x2F;&#x2F; ... some code if (&#x2F;* 异步操作成功 *&#x2F;)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。 resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。 12345promise.then(function(value) &#123; &#x2F;&#x2F; success&#125;, function(error) &#123; &#x2F;&#x2F; failure&#125;); then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。 Promise 新建后就会立即执行。 1234567891011121314let promise &#x3D; new Promise(function(resolve, reject) &#123; console.log(&#39;Promise&#39;); resolve();&#125;);promise.then(function() &#123; console.log(&#39;resolved.&#39;);&#125;);console.log(&#39;Hi!&#39;);&#x2F;&#x2F; Promise&#x2F;&#x2F; Hi!&#x2F;&#x2F; resolved 上面代码中，Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。 调用resolve或reject并不会终结 Promise 的参数函数的执行。 12345678new Promise((resolve, reject) &#x3D;&gt; &#123; resolve(1); console.log(2);&#125;).then(r &#x3D;&gt; &#123; console.log(r);&#125;);&#x2F;&#x2F; 2&#x2F;&#x2F; 1 上面代码中，调用resolve(1)以后，后面的console.log(2)还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。 一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。 12345new Promise((resolve, reject) &#x3D;&gt; &#123; return resolve(1); &#x2F;&#x2F; 后面的语句不会执行 console.log(2);&#125;) Promise.prototype.then()Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise prototype上的。它的作用是为Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。 then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。 12345getJSON(&quot;&#x2F;posts.json&quot;).then(function(json) &#123; return json.post;&#125;).then(function(post) &#123; &#x2F;&#x2F; ...&#125;); 上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。 采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。 1234567getJSON(&quot;&#x2F;post&#x2F;1.json&quot;).then(function(post) &#123; return getJSON(post.commentURL);&#125;).then(function (comments) &#123; console.log(&quot;resolved: &quot;, comments);&#125;, function (err)&#123; console.log(&quot;rejected: &quot;, err);&#125;); 上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为resolved，就调用第一个回调函数，如果状态变为rejected，就调用第二个回调函数。 Promise.prototype.catch()Promise.prototype.catch方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。 123456getJSON(&#39;&#x2F;posts.json&#39;).then(function(posts) &#123; &#x2F;&#x2F; ...&#125;).catch(function(error) &#123; &#x2F;&#x2F; 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log(&#39;发生错误！&#39;, error);&#125;); 上面代码中，getJSON方法返回一个 Promise 对象，如果该对象状态变为resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。 1234567const promise &#x3D; new Promise(function(resolve, reject) &#123; throw new Error(&#39;test&#39;);&#125;);promise.catch(function(error) &#123; console.log(error);&#125;);&#x2F;&#x2F; Error: test 上面代码中，promise抛出一个错误，就被catch方法指定的回调函数捕获。 reject方法的作用，等同于抛出错误。 如果 Promise 状态已经变成resolved，再抛出错误是无效的。 12345678const promise &#x3D; new Promise(function(resolve, reject) &#123; resolve(&#39;ok&#39;); throw new Error(&#39;test&#39;);&#125;);promise .then(function(value) &#123; console.log(value) &#125;) .catch(function(error) &#123; console.log(error) &#125;);&#x2F;&#x2F; ok 上面代码中，Promise 在resolve语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。 Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。 一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。 1234567const promise &#x3D; new Promise(function (resolve, reject) &#123; resolve(&#39;ok&#39;); setTimeout(function () &#123; throw new Error(&#39;test&#39;) &#125;, 0)&#125;);promise.then(function (value) &#123; console.log(value) &#125;);&#x2F;&#x2F; ok&#x2F;&#x2F; Uncaught Error: test 上面代码中，Promise 指定在下一轮“事件循环”再抛出错误。到了那个时候，Promise 的运行已经结束了，所以这个错误是在 Promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误。 Promise.prototype.finally()finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。 1234promise.then(result &#x3D;&gt; &#123;···&#125;).catch(error &#x3D;&gt; &#123;···&#125;).finally(() &#x3D;&gt; &#123;···&#125;); 上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。 finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。 Promise.all()Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。 const p = Promise.all([p1, p2, p3]); 上面代码中，Promise.all()方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。另外，Promise.all()方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。 p的状态由p1、p2、p3决定，分成两种情况。 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 下面是一个具体的例子。 12345678910&#x2F;&#x2F; 生成一个Promise对象的数组const promises &#x3D; [2, 3, 5, 7, 11, 13].map(function (id) &#123; return getJSON(&#39;&#x2F;post&#x2F;&#39; + id + &quot;.json&quot;);&#125;);Promise.all(promises).then(function (posts) &#123; &#x2F;&#x2F; ...&#125;).catch(function(reason)&#123; &#x2F;&#x2F; ...&#125;); 上面代码中，promises是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态都变成fulfilled，或者其中有一个变为rejected，才会调用Promise.all方法后面的回调函数。 Promise.race()Promise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。 const p = Promise.race([p1, p2, p3]); 上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。 Promise.race()方法的参数与Promise.all()方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve()方法，将参数转为 Promise 实例，再进一步处理。 下面是一个例子，如果指定时间内没有获得结果，就将Promise的状态变为reject，否则变为resolve。 12345678910const p &#x3D; Promise.race([ fetch(&#39;&#x2F;resource-that-may-take-a-while&#39;), new Promise(function (resolve, reject) &#123; setTimeout(() &#x3D;&gt; reject(new Error(&#39;request timeout&#39;)), 5000) &#125;)]);p.then(console.log).catch(console.error); 上面代码中，如果 5 秒之内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数。 Promise.allSettled()Promise.allSettled()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束。该方法由 ES2020 引入。 12345678const promises &#x3D; [ fetch(&#39;&#x2F;api-1&#39;), fetch(&#39;&#x2F;api-2&#39;), fetch(&#39;&#x2F;api-3&#39;),];await Promise.allSettled(promises);removeLoadingIndicator(); 上面代码对服务器发出三个请求，等到三个请求都结束，不管请求成功还是失败，加载的滚动图标就会消失。 该方法返回的新的 Promise 实例，一旦结束，状态总是fulfilled，不会变成rejected。状态变成fulfilled后，Promise 的监听函数接收到的参数是一个数组，每个成员对应一个传入Promise.allSettled()的 Promise 实例. 123456789101112const resolved &#x3D; Promise.resolve(42);const rejected &#x3D; Promise.reject(-1);const allSettledPromise &#x3D; Promise.allSettled([resolved, rejected]);allSettledPromise.then(function (results) &#123; console.log(results);&#125;);&#x2F;&#x2F; [&#x2F;&#x2F; &#123; status: &#39;fulfilled&#39;, value: 42 &#125;,&#x2F;&#x2F; &#123; status: &#39;rejected&#39;, reason: -1 &#125;&#x2F;&#x2F; ] 上面代码中，Promise.allSettled()的返回值allSettledPromise，状态只可能变成fulfilled。它的监听函数接收到的参数是数组results。该数组的每个成员都是一个对象，对应传入Promise.allSettled()的两个 Promise 实例。每个对象都有status属性，该属性的值只可能是字符串fulfilled或字符串rejected。fulfilled时，对象有value属性，rejected时有reason属性，对应两种状态的返回值。 Promise.any()Promise.any()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。该方法目前是一个第三阶段的提案 。 Promise.any()跟Promise.race()方法很像，只有一点不同，就是不会因为某个 Promise变成rejected状态而结束。 Promise.resolve()有时需要将现有对象转为 Promise 对象，Promise.resolve()方法就起到这个作用。 const jsPromise = Promise.resolve($.ajax(&#39;/whatever.json&#39;)); 上面代码将 jQuery 生成的deferred对象，转为一个新的 Promise 对象。 Promise.resolve方法的参数分成四种情况。 （1）参数是一个 Promise 实例 如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。 （2）参数是一个thenable对象 thenable对象指的是具有then方法的对象，比如下面这个对象。 12345let thenable &#x3D; &#123; then: function(resolve, reject) &#123; resolve(42); &#125;&#125;; Promise.resolve方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then方法。 （3）参数不是具有then方法的对象，或根本就不是对象 如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的 Promise 对象，状态为resolved。 123456const p &#x3D; Promise.resolve(&#39;Hello&#39;);p.then(function (s)&#123; console.log(s)&#125;);&#x2F;&#x2F; Hello 上面代码生成一个新的 Promise 对象的实例p。由于字符串Hello不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是resolved，所以回调函数会立即执行。Promise.resolve方法的参数，会同时传给回调函数。 （4）不带有任何参数 Promise.resolve()方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。 所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用Promise.resolve()方法。 需要注意的是，立即resolve()的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。 12345678910111213setTimeout(function () &#123; console.log(&#39;three&#39;);&#125;, 0);Promise.resolve().then(function () &#123; console.log(&#39;two&#39;);&#125;);console.log(&#39;one&#39;);&#x2F;&#x2F; one&#x2F;&#x2F; two&#x2F;&#x2F; three 上面代码中，setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise.resolve()在本轮“事件循环”结束时执行，console.log(&#39;one&#39;)则是立即执行，因此最先输出。 Promise.reject()Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。 12345678const p &#x3D; Promise.reject(&#39;出错了&#39;);&#x2F;&#x2F; 等同于const p &#x3D; new Promise((resolve, reject) &#x3D;&gt; reject(&#39;出错了&#39;))p.then(null, function (s) &#123; console.log(s)&#125;);&#x2F;&#x2F; 出错了 上面代码生成一个 Promise 对象的实例p，状态为rejected，回调函数会立即执行。 注意，Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。这一点与Promise.resolve方法不一致。 1234567891011const thenable &#x3D; &#123; then(resolve, reject) &#123; reject(&#39;出错了&#39;); &#125;&#125;;Promise.reject(thenable).catch(e &#x3D;&gt; &#123; console.log(e &#x3D;&#x3D;&#x3D; thenable)&#125;)&#x2F;&#x2F; true 上面代码中，Promise.reject方法的参数是一个thenable对象，执行以后，后面catch方法的参数不是reject抛出的“出错了”这个字符串，而是thenable对象。 应用加载图片我们可以将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化。 12345678const preloadImage &#x3D; function (path) &#123; return new Promise(function (resolve, reject) &#123; const image &#x3D; new Image(); image.onload &#x3D; resolve; image.onerror &#x3D; reject; image.src &#x3D; path; &#125;);&#125;; Generator 函数与 Promise 的结合使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个Promise对象。 1234567891011121314151617181920212223242526272829303132function getFoo () &#123; return new Promise(function (resolve, reject)&#123; resolve(&#39;foo&#39;); &#125;);&#125;const g &#x3D; function* () &#123; try &#123; const foo &#x3D; yield getFoo(); console.log(foo); &#125; catch (e) &#123; console.log(e); &#125;&#125;;function run (generator) &#123; const it &#x3D; generator(); function go(result) &#123; if (result.done) return result.value; return result.value.then(function (value) &#123; return go(it.next(value)); &#125;, function (error) &#123; return go(it.throw(error)); &#125;); &#125; go(it.next());&#125;run(g); 上面代码的 Generator 函数g之中，有一个异步操作getFoo，它返回的就是一个Promise对象。函数run用来处理这个Promise对象，并调用下一个next方法。 Promise.try()实际开发中，经常遇到一种情况：不知道或者不想区分，函数f是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管f是否包含异步操作，都用then方法指定下一步流程，用catch方法处理f抛出的错误。一般就会采用下面的写法。 12上面的写法有一个缺点，就是如果f是同步函数，那么它会在**本轮事件循环的末尾执行**。 const f = () =&gt; console.log(‘now’);Promise.resolve().then(f);console.log(‘next’);// next// now 1234上面代码中，函数f是同步的，但是用 Promise 包装了以后，就变成异步执行了。那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？回答是可以的，并且还有两种写法。第一种写法是用async函数来写。 const f = () =&gt; console.log(‘now’);(async () =&gt; f())();console.log(‘next’);// now// next 1上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的async函数，因此如果f是同步的，就会得到同步的结果；如果f是异步的，就可以用then指定下一步，就像下面的写法。 (async () =&gt; f())().then(…) 12需要注意的是，async () &#x3D;&gt; f()会吃掉f()抛出的错误。所以，如果想捕获错误，要使用promise.catch方法。 (async () =&gt; f())().then(…).catch(…) 12第二种写法是使用new Promise()。 const f = () =&gt; console.log(‘now’);( () =&gt; new Promise( resolve =&gt; resolve(f()) ))();console.log(‘next’);// now// next 1234上面代码也是使用立即执行的匿名函数，执行new Promise()。这种情况下，同步函数也是同步执行的。鉴于这是一个很常见的需求，所以现在有一个提案，提供&#96;Promise.try&#96;方法替代上面的写法。 const f = () =&gt; console.log(‘now’);Promise.try(f);console.log(‘next’);// now// next 1234事实上，&#96;Promise.try&#96;存在已久，Promise 库Bluebird、Q和when，早就提供了这个方法。由于&#96;Promise.try&#96;为所有操作提供了统一的处理机制，所以如果想用then方法管理流程，最好都用&#96;Promise.try&#96;包装一下。这样有许多好处，其中一点就是可以更好地管理异常。 function getUsername(userId) { return database.users.get({id: userId}) .then(function(user) { return user.name; });} 12上面代码中，&#96;database.users.get()&#96;返回一个 &#96;Promise&#96; 对象，如果抛出异步错误，可以用&#96;catch&#96;方法捕获，就像下面这样写。 database.users.get({id: userId}).then(…).catch(…) 12但是&#96;database.users.get()&#96;可能还会抛出同步错误（比如数据库连接错误，具体要看实现方法），这时你就不得不用&#96;try...catch&#96;去捕获。 try { database.users.get({id: userId}) .then(…) .catch(…)} catch (e) { // …} 1上面这样的写法就很笨拙了，这时就可以统一用promise.catch()捕获所有同步和异步的错误。 Promise.try(() =&gt; database.users.get({id: userId})) .then(…) .catch(…) ```事实上，Promise.try就是模拟try代码块，就像promise.catch模拟的是catch代码块。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"CSS布局","slug":"17-CSS布局","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:57:50.000Z","comments":true,"path":"2020/04/18/17-CSS布局/","link":"","permalink":"http://yoursite.com/2020/04/18/17-CSS%E5%B8%83%E5%B1%80/","excerpt":"常见的布局属性（1）display 确定元素的显示类型： block：块级元素。 inline：行内元素。 inline-block：对外的表现是行内元素（不会独占一行），对内的表现是块级元素（可以设置宽高）。","text":"常见的布局属性（1）display 确定元素的显示类型： block：块级元素。 inline：行内元素。 inline-block：对外的表现是行内元素（不会独占一行），对内的表现是块级元素（可以设置宽高）。 （2）positon 确定元素的位置： static：默认属性值。 relative：相对定位。相对于元素本身进行偏移，不会改变它所占据的空间。 absolute：绝对定位。相对于父元素中最近的 relative/absolute 进行偏移，会脱离文档流。音标：[ˈæbsəluːt]。 fixed：固定定位。相对于可视区域固定，会脱离文档流。 relative、absolute、fixed这三个属性，可以结合 z-index 来设置层级。 响应式布局前端开发中，静态网页通常需要适应不同分辨率的设备，常用的自适应解决方案包括媒体查询、百分比、rem和vw/vh等。本文从px单位出发，分析px在移动端布局中的不足，接着介绍几种不同的自适应解决方案。 px和视口 媒体查询 百分比 自适应场景下的rem解决方案 通过vw/vh来实现自适应 px和视口在静态网页中，我们经常用像素（px）作为单位，来描述一个元素的宽高以及定位信息。在pc端，通常认为css中,1px所表示的真实长度是固定的。 那么，px真的是一个设备无关，跟长度单位米和分米一样是固定大小的吗？并不是。 那么css中的1px的真实长度到底由什么决定呢？为了理清楚这个概念我们首先介绍像素和视口的概念 像素像素是网页布局的基础，一个像素表示了计算机屏幕所能显示的最小区域，像素分为两种类型：css像素和物理像素。 我们在js或者css代码中使用的px单位就是指的是css像素，物理像素也称设备像素，只与设备或者说硬件有关，同样尺寸的屏幕，设备的密度越高，物理像素也就越多。下表表示css像素和物理像素的具体区别： css像素 为web开发者提供，在css中使用的一个抽象单位 物理像素 只与设备的硬件密度有关，任何设备的物理像素都是固定的 视口广义的视口，是指浏览器显示内容的屏幕区域，狭义的视口包括了布局视口、视觉视口和理想视口。 (1) 布局视口（layout viewport） 布局视口定义了pc网页在移动端的默认布局行为，因为通常pc的分辨率较大，布局视口默认为980px。也就是说在不设置网页的viewport的情况下，pc端的网页默认会以布局视口为基准，在移动端进行展示。因此我们可以明显看出来，默认为布局视口时，根植于pc端的网页在移动端展示很模糊。 (2) 视觉视口（visual viewport） 视觉视口表示浏览器内看到的网站的显示区域，用户可以通过缩放来查看网页的显示内容，从而改变视觉视口。视觉视口的定义，就像拿着一个放大镜分别从不同距离观察同一个物体，视觉视口仅仅类似于放大镜中显示的内容，因此视觉视口不会影响布局视口的宽度和高度。 (3) 理想视口（ideal viewport） 理想视口或者应该全称为“理想的布局视口”，在移动设备中就是指设备的分辨率。换句话说，理想视口或者说分辨率就是给定设备物理像素的情况下，最佳的“布局视口”。 上述视口中，最重要的是要明确理想视口的概念，在移动端中，理想视口或者说分辨率跟物理像素之间有什么关系呢？ 为了理清分辨率和物理像素之间的联系，我们介绍一个用DPR（Device pixel ratio）设备像素比来表示，则可以写成： 11 DPR &#x3D; 物理像素／分辨率 在不缩放的情况下，一个css像素就对应一个dpr，也就是说，在不缩放: 11 CSS像素 &#x3D; 物理像素／分辨率 此外，在移动端的布局中，我们可以通过viewport元标签来控制布局，比如一般情况下，我们可以通过下述标签使得移动端在理想视口下布局： 1&lt;meta id&#x3D;&quot;viewport&quot; name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width; initial-scale&#x3D;1.0; maximum-scale&#x3D;1; user-scalable&#x3D;no;&quot;&gt; 上述meta标签的每一个属性的详细介绍如下： 属性名 取值 描述 width 正整数 定义布局视口的宽度，单位为像素 height 正整数 定义布局视口的高度，单位为像素，很少使用 initial-scale [0,10] 初始缩放比例，1表示不缩放 minimum-scale [0,10] 最小缩放比例 maximum-scale [0,10] 最大缩放比例 user-scalable yes／no 是否允许手动缩放页面，默认值为yes 其中我们来看width属性，在移动端布局时，在meta标签中我们会将width设置称为device-width，device-width一般是表示分辨率的宽，通过width=device-width的设置我们就将布局视口设置成了理想的视口。 px与自适应当通过viewport元标签，设置布局视口为理想视口时，1个css像素可以表示成： 11 CSS像素 &#x3D; 物理像素／分辨率 我们知道，在pc端的布局视口通常情况下为980px，移动端以iphone6为例，分辨率为375 * 667，也就是说布局视口在理想的情况下为375px。比如现在我们有一个750px * 1134px的视觉稿，那么在pc端，一个css像素可以如下计算： 1PC端： 1 CSS像素 &#x3D; 物理像素／分辨率 &#x3D; 750 ／ 980 &#x3D;0.76 px 而在iphone6下： 1iphone6：1 CSS像素 &#x3D; 物理像素 ／分辨率 &#x3D; 750 ／ 375 &#x3D; 2 px 也就是说在PC端，一个CSS像素可以用0.76个物理像素来表示，而iphone6中 一个CSS像素表示了2个物理像素。此外不同的移动设备分辨率不同，也就是1个CSS像素可以表示的物理像素是不同的，因此如果在css中仅仅通过px作为长度和宽度的单位，造成的结果就是无法通过一套样式，实现各端的自适应。 媒体查询在前面我们说到，不同端的设备下，在css文件中，1px所表示的物理像素的大小是不同的，因此通过一套样式，是无法实现各端的自适应。由此我们联想： 如果一套样式不行，那么能否给每一种设备各一套不同的样式来实现自适应的效果？ 答案是肯定的。 使用@media媒体查询可以针对不同的媒体类型定义不同的样式，特别是响应式页面，可以针对不同屏幕的大小，编写多套样式，从而达到自适应的效果。举例来说： 1234567891011121314151617181920212223@media screen and (max-width: 960px)&#123; body&#123; background-color:#FF6699 &#125;&#125;@media screen and (max-width: 768px)&#123; body&#123; background-color:#00FF66; &#125;&#125;@media screen and (max-width: 550px)&#123; body&#123; background-color:#6633FF; &#125;&#125;@media screen and (max-width: 320px)&#123; body&#123; background-color:#FFFF00; &#125;&#125; 上述的代码通过媒体查询定义了几套样式，通过max-width设置样式生效时的最大分辨率，上述的代码分别对分辨率在0～320px，320px～550px，550px～768px以及768px～960px的屏幕设置了不同的背景颜色。 通过媒体查询，可以通过给不同分辨率的设备编写不同的样式来实现响应式的布局，比如我们为不同分辨率的屏幕，设置不同的背景图片。比如给小屏幕手机设置@2x图，为大屏幕手机设置@3x图，通过媒体查询就能很方便的实现。 但是媒体查询的缺点也很明显，如果在浏览器大小改变时，需要改变的样式太多，那么多套样式代码会很繁琐。 总结 逻辑操作符：not、and和only等 and操作符用来把多个媒体属性组合成一条媒体查询，对成链式的特征进行请求，只有当每个属性都为真时，结果才为真。 not操作符用来对一条媒体查询的结果进行取反。 only操作符仅在媒体查询匹配成功的情况下被用于应用一个样式，这对于防止让选中的样式在老式浏览器中被应用到。 若使用了not或only操作符，必须明确指定一个媒体类型。 你也可以将多个媒体查询以逗号分隔放在一起；只要其中任何一个为真，整个媒体语句就返回真。相当于or操作符。 媒体类型 百分比除了用px结合媒体查询实现响应式布局外，我们也可以通过百分比单位 “ % “ 来实现响应式的效果。 比如当浏览器的宽度或者高度发生变化时，通过百分比单位，通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。 为了了解百分比布局，首先要了解的问题是： css中的子元素中的百分比（%）到底是谁的百分比？ 直观的理解，我们可能会认为子元素的百分比完全相对于直接父元素，height百分比相对于height，width百分比相对于width。当然这种理解是正确的，但是根据css的盒式模型，除了height、width属性外，还具有padding、border、margin等等属性。那么这些属性设置成百分比，是根据父元素的那些属性呢？此外还有border-radius和translate等属性中的百分比，又是相对于什么呢？下面来具体分析。 百分比的具体分析 （1）子元素height和width的百分比 子元素的height或width中使用百分比，是相对于子元素的直接父元素，width相对于父元素的width，height相对于父元素的height。 比如： 123&lt;div class&#x3D;&quot;parent&quot;&gt; &lt;div class&#x3D;&quot;child&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt; 如果设置： 12345678.father&#123;width:200px;height:100px;&#125;.child&#123;width:50%;height:50%;&#125; 展示的效果为： (2)top和bottom 、left和right 子元素的top和bottom如果设置百分比，则相对于直接非static定位(默认定位)的父元素的高度，同样 子元素的left和right如果设置百分比，则相对于直接非static定位(默认定位的)父元素的宽度。 展示的效果为： (3) padding 子元素的padding如果设置百分比，不论是垂直方向或者是水平方向，都相对于直接父亲元素的width，而与父元素的height无关。 举例来说： 12345678910111213.parent&#123; width:200px; height:100px; background:green;&#125;.child&#123; width:0px; height:0px; background:blue; color:white; padding-top:50%; padding-left:50%;&#125; 展示的效果为： 子元素的初始宽高为0，通过padding可以将父元素撑大，上图的蓝色部分是一个正方形，且边长为100px,说明padding不论宽高，如果设置成百分比都相对于父元素的width。 （4）margin 跟padding一样，margin也是如此，子元素的margin如果设置成百分比，不论是垂直方向还是水平方向，都相对于直接父元素的width。这里就不具体举例。 （5）border-radius border-radius不一样，如果设置border-radius为百分比，则是相对于自身的宽度，举例来说： 12345678910 &lt;div class&#x3D;&quot;trangle&quot;&gt;&lt;&#x2F;div&gt;设置border-radius为百分比：.trangle&#123; width:100px; height:100px; border-radius:50%; background:blue; margin-top:10px;&#125; 百分比单位布局应用 百分比单位在布局上应用还是很广泛的，这里介绍一种应用。 比如我们要实现一个固定长宽比的长方形，比如要实现一个长宽比为4:3的长方形,我们可以根据padding属性来实现，因为padding不管是垂直方向还是水平方向，百分比单位都相对于父元素的宽度，因此我们可以设置padding-top为百分比来实现，长宽自适应的长方形： 1&lt;div class&#x3D;&quot;trangle&quot;&gt;&lt;&#x2F;div&gt; 设置样式让其自适应： 12345.trangle&#123; height:0; width:100%; padding-top:75%;&#125; 通过设置padding-top：75%，相对比宽度的75%，因此这样就设置了一个长宽高恒定比例的长方形，具体效果展示如下： 百分比单位缺点 从上述对于百分比单位的介绍我们很容易看出如果全部使用百分比单位来实现响应式的布局，有明显的以下两个缺点： （1）计算困难，如果我们要定义一个元素的宽度和高度，按照设计稿，必须换算成百分比单位。（2）从小节1可以看出，各个属性中如果使用百分比，相对父元素的属性并不是唯一的。比如width和height相对于父元素的width和height，而margin、padding不管垂直还是水平方向都相对比父元素的宽度、border-radius则是相对于元素自身等等，造成我们使用百分比单位容易使布局问题变得复杂。 自适应场景下的rem解决方案 rem单位 首先来看，什么是rem单位。rem是一个灵活的、可扩展的单位，由浏览器转化像素并显示。与em单位不同，rem单位无论嵌套层级如何，都只相对于浏览器的根元素（HTML元素）的font-size。默认情况下，html元素的font-size为16px，所以： 11 rem &#x3D; 16px 为了计算方便，通常可以将html的font-size设置成： 1html&#123; font-size: 62.5% &#125; 这种情况下： 11 rem &#x3D; 10px 通过rem来实现响应式布局 rem单位都是相对于根元素html的font-size来决定大小的,根元素的font-size相当于提供了一个基准，当页面的size发生变化时，只需要改变font-size的值，那么以rem为固定单位的元素的大小也会发生响应的变化。 因此，如果通过rem来实现响应式的布局，只需要根据视图容器的大小，动态的改变font-size即可。 12345678function refreshRem() &#123; var docEl &#x3D; doc.documentElement; var width &#x3D; docEl.getBoundingClientRect().width; var rem &#x3D; width &#x2F; 10; docEl.style.fontSize &#x3D; rem + &#39;px&#39;; flexible.rem &#x3D; win.rem &#x3D; rem;&#125;win.addEventListener(&#39;resize&#39;, refreshRem); 上述代码中将视图容器分为10份，font-size用十分之一的宽度来表示，最后在header标签中执行这段代码，就可以动态定义font-size的大小，从而1rem在不同的视觉容器中表示不同的大小，用rem固定单位可以实现不同容器内布局的自适应。 rem2px和px2rem 如果在响应式布局中使用rem单位，那么存在一个单位换算的问题，rem2px表示从rem换算成px，这个就不说了，只要rem乘以相应的font-size中的大小，就能换算成px。更多的应用是px2rem，表示的是从px转化为rem。 比如给定的视觉稿为750px（物理像素），如果我们要将所有的布局单位都用rem来表示，一种比较笨的办法就是对所有的height和width等元素，乘以相应的比例，现将视觉稿换算成rem单位，然后一个个的用rem来表示。 另一种比较方便的解决方法就是，在css中我们还是用px来表示元素的大小，最后编写完css代码之后，将css文件中的所有px单位，转化成rem单位。 px2rem的原理也很简单，重点在于预处理以px为单位的css文件，处理后将所有的px变成rem单位。可以通过两种方式来实现： 1） webpack loader的形式： 1npm install px2rem-loader 在webpack的配置文件中： 1234567891011121314151617181920module.exports &#x3D; &#123; &#x2F;&#x2F; ... module: &#123; rules: [&#123; test: &#x2F;\\.css$&#x2F;, use: [&#123; loader: &#39;style-loader&#39; &#125;, &#123; loader: &#39;css-loader&#39; &#125;, &#123; loader: &#39;px2rem-loader&#39;, &#x2F;&#x2F; options here options: &#123; remUni: 75, remPrecision: 8 &#125; &#125;] &#125;] &#125;&#125; 2）webpack中使用postcss plugin 1npm install postcss-loader 在webpack的plugin中: 123456789101112131415var px2rem &#x3D; require(&#39;postcss-px2rem&#39;);module.exports &#x3D; &#123; module: &#123; loaders: [ &#123; test: &#x2F;\\.css$&#x2F;, loader: &quot;style-loader!css-loader!postcss-loader&quot; &#125; ] &#125;, postcss: function() &#123; return [px2rem(&#123;remUnit: 75&#125;)]; &#125;&#125; rem 布局的缺点 通过rem单位，可以实现响应式的布局，特别是引入相应的postcss相关插件，免去了设计稿中的px到rem的计算。 rem单位在国外的一些网站也有使用，这里所说的rem来实现布局的缺点，或者说是小缺陷是： 在响应式布局中，必须通过js来动态控制根元素font-size的大小。 也就是说css样式和js代码有一定的耦合性。且必须将改变font-size的代码放在css样式之前。 通过vw/vh来实现自适应 什么是vw/vh ? css3中引入了一个新的单位vw/vh，与视图窗口有关，vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度，除了vw和vh外，还有vmin和vmax两个相关的单位。 各个单位具体的含义如下： 单位 含义 vw 相对于视窗的宽度，视窗宽度是100vw vh 相对于视窗的高度，视窗高度是100vh vmin vw和vh中的较小值 vmax vw和vh中的较大值 这里我们发现视窗宽高都是100vw／100vh，那么vw或者vh，下简称vw，很类似百分比单位。 vw和%的区别为： 单位 含义 % 大部分相对于祖先元素，也有相对于自身的情况比如（border-radius、translate等) vw/vh 相对于视窗的尺寸 从对比中我们可以发现，vw单位与百分比类似，但却有区别，前面我们介绍了百分比单位的换算困难，这里的vw更像”理想的百分比单位”。 任意层级元素，在使用vw单位的情况下，1vw都等于视图宽度的百分之一。 vw单位换算 同样的，如果要将px换算成vw单位，很简单，只要确定视图的窗口大小（布局视口），如果我们将布局视口设置成分辨率大小，比如对于iphone6/7 375*667的分辨率， 那么px可以通过如下方式换算成vw： 11px &#x3D; （1&#x2F;375）*100 vw 通过指定视窗的宽度和高度，以及换算精度，就能将px转化成vw。 vw/vh单位的兼容性 可以在https://caniuse.com/ 查看各个版本的浏览器对vw单位的支持性。 我们发现，绝大多数的浏览器支持vw单位，但是ie9-11不支持vmin和vmax，考虑到vmin和vmax单位不常用，vw单位在绝大部分高版本浏览器内的支持性很好，但是opera浏览器整体不支持vw单位，如果需要兼容opera浏览器的布局，不推荐使用vw。 三栏式布局 涉及浮动和清除浮动，主要讲解“圣杯”和“双飞翼”两种解决方法。这两种方法实现的都是三栏布局，两边的盒子宽度固定，中间盒子自适应，它们实现的效果是一样的，差别在于其实现的思想。 圣杯布局 圣杯：父盒子包含三个子盒子（左，中，右） 上部和下部各自占领屏幕所有宽度。 上下部之间的部分是一个三栏布局。 三栏布局两侧宽度不变，中间部分自动填充整个区域。 中间部分的高度是三栏中最高的区域的高度。 本文会用三种方法来实现圣杯布局，分别是浮动，flexbox以及css grid。 浮动实现 12345678910111213141516171819202122232425262728293031323334353637383940&lt;div class&#x3D;&quot;header&quot;&gt;这里是头部&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;container&quot;&gt; &lt;div class&#x3D;&quot;middle&quot;&gt;中间部分&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;left&quot;&gt;左边&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;right&quot;&gt;右边&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;footer&quot;&gt;这里是底部&lt;&#x2F;div&gt;.header,.footer&#123; height:40px; width:100%; background:red;&#125;.footer&#123; clear:both;&#125;.container&#123; padding-left:200px; padding-right:300px;&#125;.container div&#123; postion:relative; float:left;&#125;.middle&#123; width:100%; background:yellow;&#125;.left&#123; width:200px; background:pink; margin-left:-100%; right:200px;&#125;.right&#123; width:300px; background:aqua; margin-right:-300px;&#125; 总结 中间盒子的宽度设置为 width: 100%; 独占一行； 使用负边距(均是 margin-left)把左右两边的盒子都拉上去和中间盒子同一行； flexbox弹性盒子实现 弹性盒子用来实现圣杯布局特别简单。只需要把中间的部分用flex布局即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;html&gt;&lt;head&gt; &lt;style&gt; div&#123; outline: 2px solid; margin: 5px; &#125; &#x2F;* 以下为整个页面的布局 *&#x2F; .main&#123; display:flex; flex-direction: column; height:100%; &#125; .top, .footer&#123; height: 50px; &#125; &#x2F;* 以下为中间的body布局 *&#x2F; .body&#123; flex:1; display: flex; &#125; .body-main&#123; flex: 1; background-color: yellow; &#125; .body-left, .body-right&#123; width: 100px; &#125; &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;div class&#x3D;&quot;main&quot;&gt; &lt;div class&#x3D;&quot;top&quot;&gt;标题栏&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;body&quot;&gt; &lt;div class&#x3D;&quot;body-left&quot;&gt;左边导航栏&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;body-main&quot;&gt;主内容，自动伸缩&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;body-right&quot;&gt;右边提示栏&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;footer&quot;&gt;页脚栏，使用flex布局&lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 双飞翼布局 双飞翼：父盒子包含三个子盒子（左，中，右），中间的子盒子里再加一个子盒子。","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"原型链","slug":"17-原型链","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:58:42.000Z","comments":true,"path":"2020/04/18/17-原型链/","link":"","permalink":"http://yoursite.com/2020/04/18/17-%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"常见概念 构造函数 构造函数-扩展 原型规则和示例 原型链 instanceof","text":"常见概念 构造函数 构造函数-扩展 原型规则和示例 原型链 instanceof 构造函数 任何一个函数都可以被new，new了之后，就成了构造方法。 如下： 123456789function Foo(name, age) &#123; this.name = name; this.age = age; //retrun this; //默认有这一行。new一个构造函数，返回一个对象&#125;var fn1 = new Foo('smyhvae', 26);var fn2 = new Foo('vae',30); //new 多个实例对象 与普通函数相比，构造函数有以下明显特点： 用new关键字调用。 不需要用return显式返回值的，默认会返回this，也就是新的实例对象。 建议函数名的首字母大写，与普通函数区分开。 当new之后，this会先变成一个空对象，然后通过this.name = name来赋值。 原型链 prototype和__proto__和constructor 当谈到继承时，JavaScript 只有一种结构：对象。每个实例对象object都有一个私有属性（称之为 __proto__）指向它的构造函数的原型对象（prototype ）。 该原型对象也有一个自己的原型对象( __proto__) ，层层向上直到一个对象的原型对象为null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。 constructor，每个原型都有一个 constructor 属性指向关联的构造函数。实例的构造函数属性（constructor）指向构造函数 12345678function doSomething()&#123;&#125;console.log( doSomething.prototype );&#x2F;&#x2F; 和声明函数的方式无关，&#x2F;&#x2F; JavaScript 中的函数永远有一个默认原型属性。var doSomething &#x3D; function()&#123;&#125;;console.log( doSomething.prototype ); 在控制台显示的JavaScript代码块中，我们可以看到doSomething函数的一个默认属性prototype。而这段代码运行之后，控制台应该显示类似如下的结果： 123456789101112&#123; constructor: ƒ doSomething(), __proto__: &#123; constructor: ƒ Object(), hasOwnProperty: ƒ hasOwnProperty(), isPrototypeOf: ƒ isPrototypeOf(), propertyIsEnumerable: ƒ propertyIsEnumerable(), toLocaleString: ƒ toLocaleString(), toString: ƒ toString(), valueOf: ƒ valueOf() &#125;&#125; 原型链： 12345678910111213function Person() &#123;&#125;Person.prototype.name &#x3D; &#39;Kevin&#39;;var person &#x3D; new Person();person.name &#x3D; &#39;Daisy&#39;;console.log(person.name) &#x2F;&#x2F; Daisydelete person.name;console.log(person.name) &#x2F;&#x2F; Kevin","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Iterator和for...of 循环","slug":"18-Iterator和for...of循环","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:58:24.000Z","comments":true,"path":"2020/04/18/18-Iterator和for...of循环/","link":"","permalink":"http://yoursite.com/2020/04/18/18-Iterator%E5%92%8Cfor...of%E5%BE%AA%E7%8E%AF/","excerpt":"前言本文主要内容： Iterator（遍历器）的概念 默认 Iterator 接口 调用 Iterator 接口的场合 字符串的 Iterator 接口 Iterator 接口与 Generator 函数 遍历器对象的 return()，throw() for…of 循环","text":"前言本文主要内容： Iterator（遍历器）的概念 默认 Iterator 接口 调用 Iterator 接口的场合 字符串的 Iterator 接口 Iterator 接口与 Generator 函数 遍历器对象的 return()，throw() for…of 循环 Iterator（遍历器）的概念 JavaScript 原有的表示“集合”的数据结构，主要是数组（Array）和对象（Object），ES6 又添加了Map和Set。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是Map，Map的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。 遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。 Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令for…of循环，Iterator 接口主要供for…of消费。 Iterator 的遍历过程是这样的。 （1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。 （2）第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。 （3）第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。 （4）不断调用指针对象的next方法，直到它指向数据结构的结束位置。 每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。 默认 Iterator 接口Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即for…of循环（详见下文）。当使用for...of循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。 一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）。 ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。至于属性名Symbol.iterator，它是一个表达式，返回Symbol对象的iterator属性，这是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内（参见《Symbol》一章）。 ES6 的有些数据结构原生具备 Iterator 接口（比如数组），即不用任何处理，就可以被for...of循环遍历。原因在于，这些数据结构原生部署了Symbol.iterator属性（详见下文），另外一些数据结构没有（比如对象）。凡是部署了Symbol.iterator属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。 原生具备 Iterator 接口的数据结构如下。 Array Map Set String TypedArray 函数的 arguments 对象 NodeList 对象 为对象添加 Iterator 接口的例子。 12345678910111213141516171819let obj &#x3D; &#123; data: [ &#39;hello&#39;, &#39;world&#39; ], [Symbol.iterator]() &#123; const self &#x3D; this; let index &#x3D; 0; return &#123; next() &#123; if (index &lt; self.data.length) &#123; return &#123; value: self.data[index++], done: false &#125;; &#125; else &#123; return &#123; value: undefined, done: true &#125;; &#125; &#125; &#125;; &#125;&#125;; 对于类似数组的对象（存在数值键名和length属性），部署 Iterator 接口，有一个简便方法，就是Symbol.iterator方法直接引用数组的 Iterator 接口。 12345NodeList.prototype[Symbol.iterator] &#x3D; Array.prototype[Symbol.iterator];&#x2F;&#x2F; 或者NodeList.prototype[Symbol.iterator] &#x3D; [][Symbol.iterator];[...document.querySelectorAll(&#39;div&#39;)] &#x2F;&#x2F; 可以执行了 调用 Iterator 接口的场合有一些场合会默认调用 Iterator 接口（即Symbol.iterator方法），除了下文会介绍的for...of循环，还有几个别的场合。 （1）解构赋值 对数组和 Set 结构进行解构赋值时，会默认调用Symbol.iterator方法。 1234567let set &#x3D; new Set().add(&#39;a&#39;).add(&#39;b&#39;).add(&#39;c&#39;);let [x,y] &#x3D; set;&#x2F;&#x2F; x&#x3D;&#39;a&#39;; y&#x3D;&#39;b&#39;let [first, ...rest] &#x3D; set;&#x2F;&#x2F; first&#x3D;&#39;a&#39;; rest&#x3D;[&#39;b&#39;,&#39;c&#39;]; （2）扩展运算符 扩展运算符（…）也会调用默认的 Iterator 接口。 12345678&#x2F;&#x2F; 例一var str &#x3D; &#39;hello&#39;;[...str] &#x2F;&#x2F; [&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;]&#x2F;&#x2F; 例二let arr &#x3D; [&#39;b&#39;, &#39;c&#39;];[&#39;a&#39;, ...arr, &#39;d&#39;]&#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] 上面代码的扩展运算符内部就调用 Iterator 接口。 实际上，这提供了一种简便机制，可以将任何部署了 Iterator 接口的数据结构，转为数组。也就是说，只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组。 let arr = [...iterable]; （3）yield* yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。 1234567891011121314let generator &#x3D; function* () &#123; yield 1; yield* [2,3,4]; yield 5;&#125;;var iterator &#x3D; generator();iterator.next() &#x2F;&#x2F; &#123; value: 1, done: false &#125;iterator.next() &#x2F;&#x2F; &#123; value: 2, done: false &#125;iterator.next() &#x2F;&#x2F; &#123; value: 3, done: false &#125;iterator.next() &#x2F;&#x2F; &#123; value: 4, done: false &#125;iterator.next() &#x2F;&#x2F; &#123; value: 5, done: false &#125;iterator.next() &#x2F;&#x2F; &#123; value: undefined, done: true &#125; （4）其他场合 由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。 12345for...ofArray.from()Map(), Set(), WeakMap(), WeakSet()（比如new Map([[&#39;a&#39;,1],[&#39;b&#39;,2]])）Promise.all()Promise.race() 字符串的 Iterator 接口字符串是一个类似数组的对象，也原生具有 Iterator 接口。 123456789var someString &#x3D; &quot;hi&quot;;typeof someString[Symbol.iterator]&#x2F;&#x2F; &quot;function&quot;var iterator &#x3D; someString[Symbol.iterator]();iterator.next() &#x2F;&#x2F; &#123; value: &quot;h&quot;, done: false &#125;iterator.next() &#x2F;&#x2F; &#123; value: &quot;i&quot;, done: false &#125;iterator.next() &#x2F;&#x2F; &#123; value: undefined, done: true &#125; 上面代码中，调用Symbol.iterator方法返回一个遍历器对象，在这个遍历器上可以调用 next 方法，实现对于字符串的遍历。 可以覆盖原生的Symbol.iterator方法，达到修改遍历器行为的目的。 1234567891011121314151617181920var str &#x3D; new String(&quot;hi&quot;);[...str] &#x2F;&#x2F; [&quot;h&quot;, &quot;i&quot;]str[Symbol.iterator] &#x3D; function() &#123; return &#123; next: function() &#123; if (this._first) &#123; this._first &#x3D; false; return &#123; value: &quot;bye&quot;, done: false &#125;; &#125; else &#123; return &#123; done: true &#125;; &#125; &#125;, _first: true &#125;;&#125;;[...str] &#x2F;&#x2F; [&quot;bye&quot;]str &#x2F;&#x2F; &quot;hi&quot; 上面代码中，字符串 str 的Symbol.iterator方法被修改了，所以扩展运算符（…）返回的值变成了bye，而字符串本身还是hi。 遍历器对象的 return()，throw()遍历器对象除了具有next方法，还可以具有return方法和throw方法。如果你自己写遍历器对象生成函数，那么next方法是必须部署的，return方法和throw方法是否部署是可选的。 return方法的使用场合是，如果for...of循环提前退出（通常是因为出错，或者有break语句），就会调用return方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署return方法。 123456789101112131415function readLinesSync(file) &#123; return &#123; [Symbol.iterator]() &#123; return &#123; next() &#123; return &#123; done: false &#125;; &#125;, return() &#123; file.close(); return &#123; done: true &#125;; &#125; &#125;; &#125;, &#125;;&#125; 上面代码中，函数readLinesSync接受一个文件对象作为参数，返回一个遍历器对象，其中除了next方法，还部署了return方法。下面的两种情况，都会触发执行return方法。 1234567891011&#x2F;&#x2F; 情况一for (let line of readLinesSync(fileName)) &#123; console.log(line); break;&#125;&#x2F;&#x2F; 情况二for (let line of readLinesSync(fileName)) &#123; console.log(line); throw new Error();&#125; 上面代码中，情况一输出文件的第一行以后，就会执行return方法，关闭这个文件；情况二会在执行return方法关闭文件之后，再抛出错误。 注意，return方法必须返回一个对象，这是 Generator规格决定的。 throw方法主要是配合 Generator 函数使用，一般的遍历器对象用不到这个方法。请参阅《Generator 函数》一章。 for…of 循环ES6 借鉴 C++、Java、C# 和 Python 语言，引入了for...of循环，作为遍历所有数据结构的统一的方法。 一个数据结构只要部署了Symbol.iterator属性，就被视为具有 iterator接口，就可以用for...of循环遍历它的成员。也就是说，for...of循环内部调用的是数据结构的Symbol.iterator方法。 for...of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。 数组原生具备iterator接口（即默认部署了Symbol.iterator属性），for…of循环本质上就是调用这个接口产生的遍历器，可以用下面的代码证明。 123456789101112const arr &#x3D; [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;];for(let v of arr) &#123; console.log(v); &#x2F;&#x2F; red green blue&#125;const obj &#x3D; &#123;&#125;;obj[Symbol.iterator] &#x3D; arr[Symbol.iterator].bind(arr);for(let v of obj) &#123; console.log(v); &#x2F;&#x2F; red green blue&#125; 上面代码中，空对象obj部署了数组arr的Symbol.iterator属性，结果obj的for...of循环，产生了与arr完全一样的结果。 for...of循环可以代替数组实例的forEach方法。 123456const arr &#x3D; [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;];arr.forEach(function (element, index) &#123; console.log(element); &#x2F;&#x2F; red green blue console.log(index); &#x2F;&#x2F; 0 1 2&#125;); JavaScript 原有的for...in循环，只能获得对象的键名，不能直接获取键值。ES6 提供for...of循环，允许遍历获得键值。 123456789var arr &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;];for (let a in arr) &#123; console.log(a); &#x2F;&#x2F; 0 1 2 3&#125;for (let a of arr) &#123; console.log(a); &#x2F;&#x2F; a b c d&#125; 上面代码表明，for...in循环读取键名，for...of循环读取键值。如果要通过for...of循环，获取数组的索引，可以借助数组实例的entries方法和keys方法（参见《数组的扩展》一章）。 for...of循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟for...in循环也不一样。 12345678910let arr &#x3D; [3, 5, 7];arr.foo &#x3D; &#39;hello&#39;;for (let i in arr) &#123; console.log(i); &#x2F;&#x2F; &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;&#125;for (let i of arr) &#123; console.log(i); &#x2F;&#x2F; &quot;3&quot;, &quot;5&quot;, &quot;7&quot;&#125; 上面代码中，for…of循环不会返回数组arr的foo属性。 Set 和 Map 结构Set 和 Map 结构也原生具有 Iterator 接口，可以直接使用for...of循环。 计算生成的数据结构有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6 的数组、Set、Map 都部署了以下三个方法，调用后都返回遍历器对象。 entries() 返回一个遍历器对象，用来遍历[键名, 键值]组成的数组。对于数组，键名就是索引值；对于 Set，键名与键值相同。Map 结构的 Iterator 接口，默认就是调用entries方法。 keys() 返回一个遍历器对象，用来遍历所有的键名。 values() 返回一个遍历器对象，用来遍历所有的键值。 这三个方法调用后生成的遍历器对象，所遍历的都是计算生成的数据结构。 1234567let arr &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];for (let pair of arr.entries()) &#123; console.log(pair);&#125;&#x2F;&#x2F; [0, &#39;a&#39;]&#x2F;&#x2F; [1, &#39;b&#39;]&#x2F;&#x2F; [2, &#39;c&#39;]","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"display详解","slug":"18-display详解","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-20T01:33:26.000Z","comments":true,"path":"2020/04/18/18-display详解/","link":"","permalink":"http://yoursite.com/2020/04/18/18-display%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"opacity visibility display 隐藏的区别 opacity=0，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定一些事件，如click事件，那么点击该区域，也能触发点击事件的。 visibility=hidden，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件，设置为gone时，不保留控件空间。 display=none，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删除掉一样。","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"数组简介","slug":"18-数组简介","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:58:30.000Z","comments":true,"path":"2020/04/18/18-数组简介/","link":"","permalink":"http://yoursite.com/2020/04/18/18-%E6%95%B0%E7%BB%84%E7%AE%80%E4%BB%8B/","excerpt":"数组简介数组（Array）是属于内置对象，我们可以在MDN网站上查询各种方法。","text":"数组简介数组（Array）是属于内置对象，我们可以在MDN网站上查询各种方法。 数组和普通对象的功能类似，也是用来存储一些值的。不同的是： 普通对象是使用字符串作为属性名的，而数组是使用数字来作为索引来操作元素。索引：从0开始的整数就是索引。 数组的存储性能比普通对象要好。在实际开发中我们经常使用数组来存储一些数据，使用频率非常高。 数组中的元素可以是任意的数据类型，也可以是对象，也可以是函数，也可以是数组。数组的元素中，如果存放的是数组，我们就称这种数组为二维数组。 接下来，我们讲一讲数组的基本操作。 创建数组对象方式一：使用数组字面量创建数组举例： 123var arr1 = []; // 创建一个空的数组var arr2 = [1,2,3]; // 创建带初始值的数组 方式一最简单，也用得最多。 方式二：使用构造函数创建数组语法： 1var arr &#x3D; new Array(参数); 如果参数为空，则表示创建一个空数组；如果参数是一个数值时，表示数组的长度；参数位置是多个数值时，表示数组中的元素。 来举个例子： 1234567891011121314// 方式一var arr1 = [11, 12, 13];// 方式二var arr2 = new Array(); // 参数为空var arr3 = new Array(4); // 参数为一个数值var arr4 = new Array(15, 16, 17); // 参数为多个数值console.log(typeof arr1); // 打印结果：objectconsole.log(\"arr1 = \" + JSON.stringify(arr1));console.log(\"arr2 = \" + JSON.stringify(arr2));console.log(\"arr3 = \" + JSON.stringify(arr3));console.log(\"arr4 = \" + JSON.stringify(arr4)); 打印结果： 123456objectarr1 = [11,12,13]arr2 = []arr3 = [null,null,null,null]arr4 = [15,16,17] 从上方打印结果的第一行里，可以看出，数组的类型其实也是属于对象。 数组中的元素的类型数组中可以存放任意类型的数据，例如字符串、数字、布尔值、对象等。 比如： 1var arr = ['qianguyihao', 28, true, &#123;name: 'qianguyihao'&#125;]; 数组的基本操作数组的索引索引 (下标) ：用来访问数组元素的序号，代表的是数组中的元素在数组中的位置（下标从 0 开始算起）。 数组可以通过索引来访问、设置、修改对应的数组元素。我们继续看看。 向数组中添加元素语法： 1数组[索引] = 值 代码举例： 12345678910var arr = [];// 向数组中添加元素arr[0] = 10;arr[1] = 20;arr[2] = 30;arr[3] = 40;arr[5] = 50;console.log(JSON.stringify(arr)); 打印结果： 1[10,20,30,40,null,50] 获取数组中的元素语法： 1数组[索引] 如果读取不存在的索引（比如元素没那么多），系统不会报错，而是返回undefined。 代码举例： 1234var arr = [21, 22, 23];console.log(arr[0]); // 打印结果：21console.log(arr[5]); // 打印结果：undefined 获取数组的长度可以使用length属性来获取数组的长度(即“元素的个数”)。 数组的长度是元素个数，不要跟索引号混淆。 语法： 1数组的长度 = 数组名.length； 代码举例： 123var arr = [21, 22, 23];console.log(arr.length); // 打印结果：3 补充： 对于连续的数组，使用length可以获取到数组的长度（元素的个数）；对于非连续的数组，使用length会获取到数组的最大的索引+1。因此，尽量不要创建非连续的数组。 修改数组的长度（修改length） 如果修改的length大于原长度，则多出部分会空出来，置为 null。 如果修改的length小于原长度，则多出的元素会被删除，数组将从后面删除元素。 （特例：伪数组arguments的长度可以修改，但是不能修改里面的元素，后面单独讲。） 代码举例： 12345678910var arr1 = [11, 12, 13];var arr2 = [21, 22, 23];// 修改数组 arr1 的 lengtharr1.length = 1;console.log(JSON.stringify(arr1));// 修改数组 arr2 的 lengtharr2.length = 5;console.log(JSON.stringify(arr2)); 打印结果： 123[11][21,22,23,null,null] 遍历数组遍历: 就是把数组中的每个元素从头到尾都访问一次。 最简单的做法是通过 for 循环，遍历数组中的每一项。举例： 12345var arr = [10, 20, 30, 40, 50];for (var i = 0; i &lt; arr.length; i++) &#123; console.log(arr[i]); // 打印出数组中的每一项&#125; 下一篇文章，会学习数组的各种方法，到时候，会有更多的做法去遍历数组。 案例例1：翻转数组代码实现： 123456var arr = [10, 20, 30, 40, 50]; // 原始数组var newArr = []; // 翻转后的数组for (var i = 0; i &lt; arr.length; i++) &#123; newArr[i] = arr[arr.length - i - 1];&#125;console.log(JSON.stringify(newArr)); 打印结果： 1[50,40,30,20,10] 例2：冒泡排序代码实现： 1234567891011var arr = [20, 10, 50, 30, 40];for (var i = 0; i &lt; arr.length - 1; i++) &#123; for (var j = 0; j &lt; arr.length - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; var temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125;&#125;console.log(JSON.stringify(arr)); 打印结果： 1[10,20,30,40,50]","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Generator函数","slug":"19-Generator函数的语法","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T10:03:46.000Z","comments":true,"path":"2020/04/18/19-Generator函数的语法/","link":"","permalink":"http://yoursite.com/2020/04/18/19-Generator%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%B3%95/","excerpt":"前言 简介 next 方法的参数 for…of 循环 Generator.prototype.throw() Generator.prototype.return() next()、throw()、return() 的共同点 yield* 表达式 作为对象属性的 Generator 函数 Generator 函数的this 含义 应用","text":"前言 简介 next 方法的参数 for…of 循环 Generator.prototype.throw() Generator.prototype.return() next()、throw()、return() 的共同点 yield* 表达式 作为对象属性的 Generator 函数 Generator 函数的this 含义 应用 简介基本概念Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。 Generator函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。 执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。 形式上，Generator 函数是一个普通函数，但是有两个特征。 一是，function关键字与函数名之间有一个星号； 二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。 12345678function* helloWorldGenerator() &#123; yield &#39;hello&#39;; yield &#39;world&#39;; return &#39;ending&#39;;&#125;var hw &#x3D; helloWorldGenerator(); 上面代码定义了一个 Generator 函数helloWorldGenerator，它内部有两个yield表达式（hello和world），即该函数有三个状态：hello，world 和 return 语句（结束执行）。 然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。 下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。 1234567891011hw.next()&#x2F;&#x2F; &#123; value: &#39;hello&#39;, done: false &#125;hw.next()&#x2F;&#x2F; &#123; value: &#39;world&#39;, done: false &#125;hw.next()&#x2F;&#x2F; &#123; value: &#39;ending&#39;, done: true &#125;hw.next()&#x2F;&#x2F; &#123; value: undefined, done: true &#125; 上面代码一共调用了四次next方法。 第一次调用，Generator 函数开始执行，直到遇到第一个yield表达式为止。next方法返回一个对象，它的value属性就是当前yield表达式的值hello，done属性的值false，表示遍历还没有结束。 第二次调用，Generator 函数从上次yield表达式停下的地方，一直执行到下一个yield表达式。next方法返回的对象的value属性就是当前yield表达式的值world，done属性的值false，表示遍历还没有结束。 第三次调用，Generator 函数从上次yield表达式停下的地方，一直执行到return语句（如果没有return语句，就执行到函数结束）。next方法返回的对象的value属性，就是紧跟在return语句后面的表达式的值（如果没有return语句，则value属性的值为undefined），done属性的值true，表示遍历已经结束。 第四次调用，此时 Generator 函数已经运行完毕，next方法返回对象的value属性为undefined，done属性为true。以后再调用next方法，返回的都是这个值。 总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。 ES6 没有规定，function关键字与函数名之间的星号，写在哪个位置。这导致下面的写法都能通过。 1234function * foo(x, y) &#123; ··· &#125;function *foo(x, y) &#123; ··· &#125;function* foo(x, y) &#123; ··· &#125;function*foo(x, y) &#123; ··· &#125; 由于 Generator 函数仍然是普通函数，所以一般的写法是上面的第三种，即星号紧跟在function关键字后面。 yield 表达式由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。 遍历器对象的next方法的运行逻辑如下。 遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。 下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。 如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。 如果该函数没有return语句，则返回的对象的value属性值为undefined。 需要注意的是，yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。 123function* gen() &#123; yield 123 + 456;&#125; 上面代码中，yield后面的表达式123 + 456，不会立即求值，只会在next方法将指针移到这一句时，才会求值。 yield表达式与return语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）return语句，但是可以执行多次（或者说多个）yield表达式。正常函数只能返回一个值，因为只能执行一次return；Generator 函数可以返回一系列的值，因为可以有任意多个yield。从另一个角度看，也可以说 Generator 生成了一系列的值，这也就是它的名称的来历（英语中，generator 这个词是“生成器”的意思）。 Generator 函数可以不用yield表达式，这时就变成了一个单纯的暂缓执行函数。 123456789function* f() &#123; console.log(&#39;执行了！&#39;)&#125;var generator &#x3D; f();setTimeout(function () &#123; generator.next()&#125;, 2000); 上面代码中，函数f如果是普通函数，在为变量generator赋值时就会执行。但是，函数f是一个 Generator 函数，就变成只有调用next方法时，函数f才会执行。 另外需要注意，yield表达式只能用在 Generator 函数里面，用在其他地方都会报错。 1234(function ()&#123; yield 1;&#125;)()&#x2F;&#x2F; SyntaxError: Unexpected number 上面代码在一个普通函数中使用yield表达式，结果产生一个句法错误。 下面是另外一个例子。 123456789101112131415var arr &#x3D; [1, [[2, 3], 4], [5, 6]];var flat &#x3D; function* (a) &#123; a.forEach(function (item) &#123; if (typeof item !&#x3D;&#x3D; &#39;number&#39;) &#123; yield* flat(item); &#125; else &#123; yield item; &#125; &#125;);&#125;;for (var f of flat(arr))&#123; console.log(f);&#125; 上面代码也会产生句法错误，因为forEach方法的参数是一个普通函数，但是在里面使用了yield表达式（这个函数里面还使用了yield*表达式，详细介绍见后文）。一种修改方法是改用for循环。 123456789101112131415161718var arr &#x3D; [1, [[2, 3], 4], [5, 6]];var flat &#x3D; function* (a) &#123; var length &#x3D; a.length; for (var i &#x3D; 0; i &lt; length; i++) &#123; var item &#x3D; a[i]; if (typeof item !&#x3D;&#x3D; &#39;number&#39;) &#123; yield* flat(item); &#125; else &#123; yield item; &#125; &#125;&#125;;for (var f of flat(arr)) &#123; console.log(f);&#125;&#x2F;&#x2F; 1, 2, 3, 4, 5, 6 另外，yield表达式如果用在另一个表达式之中，必须放在圆括号里面。 1234567function* demo() &#123; console.log(&#39;Hello&#39; + yield); &#x2F;&#x2F; SyntaxError console.log(&#39;Hello&#39; + yield 123); &#x2F;&#x2F; SyntaxError console.log(&#39;Hello&#39; + (yield)); &#x2F;&#x2F; OK console.log(&#39;Hello&#39; + (yield 123)); &#x2F;&#x2F; OK&#125; yield表达式用作函数参数或放在赋值表达式的右边，可以不加括号。 1234function* demo() &#123; foo(yield &#39;a&#39;, yield &#39;b&#39;); &#x2F;&#x2F; OK let input &#x3D; yield; &#x2F;&#x2F; OK&#125; 与 Iterator 接口的关系上一章说过，任意一个对象的Symbol.iterator方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。 由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口。 12345678var myIterable &#x3D; &#123;&#125;;myIterable[Symbol.iterator] &#x3D; function* () &#123; yield 1; yield 2; yield 3;&#125;;[...myIterable] &#x2F;&#x2F; [1, 2, 3] 上面代码中，Generator 函数赋值给Symbol.iterator属性，从而使得myIterable对象具有了 Iterator 接口，可以被...运算符遍历了。 Generator 函数执行后，返回一个遍历器对象。该对象本身也具有Symbol.iterator属性，执行后返回自身。 12345678function* gen()&#123; &#x2F;&#x2F; some code&#125;var g &#x3D; gen();g[Symbol.iterator]() &#x3D;&#x3D;&#x3D; g&#x2F;&#x2F; true 上面代码中，gen是一个 Generator 函数，调用它会生成一个遍历器对象g。它的Symbol.iterator属性，也是一个遍历器对象生成函数，执行后返回它自己。 next 方法的参数yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。 123456789101112function* f() &#123; for(var i &#x3D; 0; true; i++) &#123; var reset &#x3D; yield i; if(reset) &#123; i &#x3D; -1; &#125; &#125;&#125;var g &#x3D; f();g.next() &#x2F;&#x2F; &#123; value: 0, done: false &#125;g.next() &#x2F;&#x2F; &#123; value: 1, done: false &#125;g.next(true) &#x2F;&#x2F; &#123; value: 0, done: false &#125; 上面代码先定义了一个可以无限运行的 Generator 函数f，如果next方法没有参数，每次运行到yield表达式，变量reset的值总是undefined。当next方法带一个参数true时，变量reset就被重置为这个参数（即true），因此i会等于-1，下一轮循环就会从-1开始递增。 这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过next方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。 再看一个例子。 123456789101112131415function* foo(x) &#123; var y &#x3D; 2 * (yield (x + 1)); var z &#x3D; yield (y &#x2F; 3); return (x + y + z);&#125;var a &#x3D; foo(5);a.next() &#x2F;&#x2F; Object&#123;value:6, done:false&#125;a.next() &#x2F;&#x2F; Object&#123;value:NaN, done:false&#125;a.next() &#x2F;&#x2F; Object&#123;value:NaN, done:true&#125;var b &#x3D; foo(5);b.next() &#x2F;&#x2F; &#123; value:6, done:false &#125;b.next(12) &#x2F;&#x2F; &#123; value:8, done:false &#125;b.next(13) &#x2F;&#x2F; &#123; value:42, done:true &#125; 上面代码中，第二次运行next方法的时候不带参数，导致 y 的值等于2 * undefined（即NaN），除以 3 以后还是NaN，因此返回对象的value属性也等于NaN。第三次运行Next方法的时候不带参数，所以z等于undefined，返回对象的value属性等于5 + NaN + undefined，即NaN。 如果向next方法提供参数，返回结果就完全不一样了。上面代码第一次调用b的next方法时，返回x+1的值6；第二次调用next方法，将上一次yield表达式的值设为12，因此y等于24，返回y / 3的值8；第三次调用next方法，将上一次yield表达式的值设为13，因此z等于13，这时x等于5，y等于24，所以return语句的值等于42。 注意，由于next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的。V8 引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。从语义上讲，第一个next方法用来启动遍历器对象，所以不用带有参数。 再看一个通过next方法的参数，向 Generator 函数内部输入值的例子。 1234567891011121314function* dataConsumer() &#123; console.log(&#39;Started&#39;); console.log(&#96;1. $&#123;yield&#125;&#96;); console.log(&#96;2. $&#123;yield&#125;&#96;); return &#39;result&#39;;&#125;let genObj &#x3D; dataConsumer();genObj.next();&#x2F;&#x2F; StartedgenObj.next(&#39;a&#39;)&#x2F;&#x2F; 1. agenObj.next(&#39;b&#39;)&#x2F;&#x2F; 2. b 上面代码是一个很直观的例子，每次通过next方法向 Generator 函数输入值，然后打印出来。 如果想要第一次调用next方法时，就能够输入值，可以在 Generator 函数外面再包一层。 123456789101112131415function wrapper(generatorFunction) &#123; return function (...args) &#123; let generatorObject &#x3D; generatorFunction(...args); generatorObject.next(); return generatorObject; &#125;;&#125;const wrapped &#x3D; wrapper(function* () &#123; console.log(&#96;First input: $&#123;yield&#125;&#96;); return &#39;DONE&#39;;&#125;);wrapped().next(&#39;hello!&#39;)&#x2F;&#x2F; First input: hello! 上面代码中，Generator 函数如果不用wrapper先包一层，是无法第一次调用next方法，就输入参数的。 for…of 循环for...of循环可以自动遍历 Generator 函数运行时生成的Iterator对象，且此时不再需要调用next方法。 12345678910111213function* foo() &#123; yield 1; yield 2; yield 3; yield 4; yield 5; return 6;&#125;for (let v of foo()) &#123; console.log(v);&#125;&#x2F;&#x2F; 1 2 3 4 5 上面代码使用for...of循环，依次显示 5 个yield表达式的值。这里需要注意，一旦next方法的返回对象的done属性为true，for...of循环就会中止，且不包含该返回对象，所以上面代码的return语句返回的6，不包括在for...of循环之中。 下面是一个利用 Generator 函数和for…of循环，实现斐波那契数列的例子。 123456789101112function* fibonacci() &#123; let [prev, curr] &#x3D; [0, 1]; for (;;) &#123; yield curr; [prev, curr] &#x3D; [curr, prev + curr]; &#125;&#125;for (let n of fibonacci()) &#123; if (n &gt; 1000) break; console.log(n);&#125; 从上面代码可见，使用for...of语句时不需要使用next方法。 利用for...of循环，可以写出遍历任意对象（object）的方法。原生的 JavaScript 对象没有遍历接口，无法使用for...of循环，通过 Generator 函数为它加上这个接口，就可以用了。 123456789101112131415function* objectEntries(obj) &#123; let propKeys &#x3D; Reflect.ownKeys(obj); for (let propKey of propKeys) &#123; yield [propKey, obj[propKey]]; &#125;&#125;let jane &#x3D; &#123; first: &#39;Jane&#39;, last: &#39;Doe&#39; &#125;;for (let [key, value] of objectEntries(jane)) &#123; console.log(&#96;$&#123;key&#125;: $&#123;value&#125;&#96;);&#125;&#x2F;&#x2F; first: Jane&#x2F;&#x2F; last: Doe 上面代码中，对象jane原生不具备 Iterator 接口，无法用for...of遍历。这时，我们通过 Generator 函数objectEntries为它加上遍历器接口，就可以用for...of遍历了。加上遍历器接口的另一种写法是，将 Generator 函数加到对象的Symbol.iterator属性上面。 1234567891011121314151617function* objectEntries() &#123; let propKeys &#x3D; Object.keys(this); for (let propKey of propKeys) &#123; yield [propKey, this[propKey]]; &#125;&#125;let jane &#x3D; &#123; first: &#39;Jane&#39;, last: &#39;Doe&#39; &#125;;jane[Symbol.iterator] &#x3D; objectEntries;for (let [key, value] of jane) &#123; console.log(&#96;$&#123;key&#125;: $&#123;value&#125;&#96;);&#125;&#x2F;&#x2F; first: Jane&#x2F;&#x2F; last: Doe 除了for...of循环以外，扩展运算符（...）、解构赋值和Array.from方法内部调用的，都是遍历器接口。这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。 123456789101112131415161718192021222324function* numbers () &#123; yield 1 yield 2 return 3 yield 4&#125;&#x2F;&#x2F; 扩展运算符[...numbers()] &#x2F;&#x2F; [1, 2]&#x2F;&#x2F; Array.from 方法Array.from(numbers()) &#x2F;&#x2F; [1, 2]&#x2F;&#x2F; 解构赋值let [x, y] &#x3D; numbers();x &#x2F;&#x2F; 1y &#x2F;&#x2F; 2&#x2F;&#x2F; for...of 循环for (let n of numbers()) &#123; console.log(n)&#125;&#x2F;&#x2F; 1&#x2F;&#x2F; 2 Generator.prototype.throw()Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。 12345678910111213141516171819var g &#x3D; function* () &#123; try &#123; yield; &#125; catch (e) &#123; console.log(&#39;内部捕获&#39;, e); &#125;&#125;;var i &#x3D; g();i.next();try &#123; i.throw(&#39;a&#39;); i.throw(&#39;b&#39;);&#125; catch (e) &#123; console.log(&#39;外部捕获&#39;, e);&#125;&#x2F;&#x2F; 内部捕获 a&#x2F;&#x2F; 外部捕获 b 上面代码中，遍历器对象i连续抛出两个错误。第一个错误被 Generator 函数体内的catch语句捕获。i第二次抛出错误，由于 Generator 函数内部的catch语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，被函数体外的catch语句捕获。 throw方法可以接受一个参数，该参数会被catch语句接收，建议抛出Error对象的实例。 12345678910111213var g &#x3D; function* () &#123; try &#123; yield; &#125; catch (e) &#123; console.log(e); &#125;&#125;;var i &#x3D; g();i.next();i.throw(new Error(&#39;出错了！&#39;));&#x2F;&#x2F; Error: 出错了！(…) 注意，不要混淆遍历器对象的throw方法和全局的throw命令。上面代码的错误，是用遍历器对象的throw方法抛出的，而不是用throw命令抛出的。后者只能被函数体外的catch语句捕获。 123456789101112131415161718192021var g &#x3D; function* () &#123; while (true) &#123; try &#123; yield; &#125; catch (e) &#123; if (e !&#x3D; &#39;a&#39;) throw e; console.log(&#39;内部捕获&#39;, e); &#125; &#125;&#125;;var i &#x3D; g();i.next();try &#123; throw new Error(&#39;a&#39;); throw new Error(&#39;b&#39;);&#125; catch (e) &#123; console.log(&#39;外部捕获&#39;, e);&#125;&#x2F;&#x2F; 外部捕获 [Error: a] 上面代码之所以只捕获了a，是因为函数体外的catch语句块，捕获了抛出的a错误以后，就不会再继续try代码块里面剩余的语句了。 如果 Generator 函数内部没有部署try...catch代码块，那么throw方法抛出的错误，将被外部try...catch代码块捕获。 1234567891011121314151617var g &#x3D; function* () &#123; while (true) &#123; yield; console.log(&#39;内部捕获&#39;, e); &#125;&#125;;var i &#x3D; g();i.next();try &#123; i.throw(&#39;a&#39;); i.throw(&#39;b&#39;);&#125; catch (e) &#123; console.log(&#39;外部捕获&#39;, e);&#125;&#x2F;&#x2F; 外部捕获 a 上面代码中，Generator 函数g内部没有部署try...catch代码块，所以抛出的错误直接被外部catch代码块捕获。 如果 Generator 函数内部和外部，都没有部署try...catch代码块，那么程序将报错，直接中断执行。 12345678910var gen &#x3D; function* gen()&#123; yield console.log(&#39;hello&#39;); yield console.log(&#39;world&#39;);&#125;var g &#x3D; gen();g.next();g.throw();&#x2F;&#x2F; hello&#x2F;&#x2F; Uncaught undefined 上面代码中，g.throw抛出错误以后，没有任何try...catch代码块可以捕获这个错误，导致程序报错，中断执行。 throw方法抛出的错误要被内部捕获，前提是必须至少执行过一次next方法。 1234567891011function* gen() &#123; try &#123; yield 1; &#125; catch (e) &#123; console.log(&#39;内部捕获&#39;); &#125;&#125;var g &#x3D; gen();g.throw(1);&#x2F;&#x2F; Uncaught 1 上面代码中，g.throw(1)执行时，next方法一次都没有执行过。这时，抛出的错误不会被内部捕获，而是直接在外部抛出，导致程序出错。这种行为其实很好理解，因为第一次执行next方法，等同于启动执行 Generator 函数的内部代码，否则 Generator 函数还没有开始执行，这时throw方法抛错只可能抛出在函数外部。 throw方法被捕获以后，会附带执行下一条yield表达式。也就是说，会附带执行一次next方法。 1234567891011121314var gen &#x3D; function* gen()&#123; try &#123; yield console.log(&#39;a&#39;); &#125; catch (e) &#123; &#x2F;&#x2F; ... &#125; yield console.log(&#39;b&#39;); yield console.log(&#39;c&#39;);&#125;var g &#x3D; gen();g.next() &#x2F;&#x2F; ag.throw() &#x2F;&#x2F; bg.next() &#x2F;&#x2F; c 上面代码中，g.throw方法被捕获以后，自动执行了一次next方法，所以会打印b。另外，也可以看到，只要 Generator 函数内部部署了try…catch代码块，那么遍历器的throw方法抛出的错误，不影响下一次遍历。 另外，throw命令与g.throw方法是无关的，两者互不影响。 123456789101112131415var gen &#x3D; function* gen()&#123; yield console.log(&#39;hello&#39;); yield console.log(&#39;world&#39;);&#125;var g &#x3D; gen();g.next();try &#123; throw new Error();&#125; catch (e) &#123; g.next();&#125;&#x2F;&#x2F; hello&#x2F;&#x2F; world 上面代码中，throw命令抛出的错误不会影响到遍历器的状态，所以两次执行next方法，都进行了正确的操作。 这种函数体内捕获错误的机制，大大方便了对错误的处理。多个yield表达式，可以只用一个try...catch代码块来捕获错误。如果使用回调函数的写法，想要捕获多个错误，就不得不为每个函数内部写一个错误处理语句，现在只在 Generator 函数内部写一次catch语句就可以了。 Generator 函数体外抛出的错误，可以在函数体内捕获；反过来，Generator 函数体内抛出的错误，也可以被函数体外的catch捕获。 123456789101112131415function* foo() &#123; var x &#x3D; yield 3; var y &#x3D; x.toUpperCase(); yield y;&#125;var it &#x3D; foo();it.next(); &#x2F;&#x2F; &#123; value:3, done:false &#125;try &#123; it.next(42);&#125; catch (err) &#123; console.log(err);&#125; 上面代码中，第二个next方法向函数体内传入一个参数 42，数值是没有toUpperCase方法的，所以会抛出一个 TypeError 错误，被函数体外的catch捕获。 一旦 Generator 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用next方法，将返回一个value属性等于undefined、done属性等于true的对象，即 JavaScript 引擎认为这个 Generator 已经运行结束了。 123456789101112131415161718192021222324252627282930313233343536373839function* g() &#123; yield 1; console.log(&#39;throwing an exception&#39;); throw new Error(&#39;generator broke!&#39;); yield 2; yield 3;&#125;function log(generator) &#123; var v; console.log(&#39;starting generator&#39;); try &#123; v &#x3D; generator.next(); console.log(&#39;第一次运行next方法&#39;, v); &#125; catch (err) &#123; console.log(&#39;捕捉错误&#39;, v); &#125; try &#123; v &#x3D; generator.next(); console.log(&#39;第二次运行next方法&#39;, v); &#125; catch (err) &#123; console.log(&#39;捕捉错误&#39;, v); &#125; try &#123; v &#x3D; generator.next(); console.log(&#39;第三次运行next方法&#39;, v); &#125; catch (err) &#123; console.log(&#39;捕捉错误&#39;, v); &#125; console.log(&#39;caller done&#39;);&#125;log(g());&#x2F;&#x2F; starting generator&#x2F;&#x2F; 第一次运行next方法 &#123; value: 1, done: false &#125;&#x2F;&#x2F; throwing an exception&#x2F;&#x2F; 捕捉错误 &#123; value: 1, done: false &#125;&#x2F;&#x2F; 第三次运行next方法 &#123; value: undefined, done: true &#125;&#x2F;&#x2F; caller done 上面代码一共三次运行next方法，第二次运行的时候会抛出错误，然后第三次运行的时候，Generator 函数就已经结束了，不再执行下去了。 Generator.prototype.return()Generator 函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历 Generator 函数。 1234567891011function* gen() &#123; yield 1; yield 2; yield 3;&#125;var g &#x3D; gen();g.next() &#x2F;&#x2F; &#123; value: 1, done: false &#125;g.return(&#39;foo&#39;) &#x2F;&#x2F; &#123; value: &quot;foo&quot;, done: true &#125;g.next() &#x2F;&#x2F; &#123; value: undefined, done: true &#125; 上面代码中，遍历器对象g调用return方法后，返回值的value属性就是return方法的参数foo。并且，Generator 函数的遍历就终止了，返回值的done属性为true，以后再调用next方法，done属性总是返回true。 如果return方法调用时，不提供参数，则返回值的value属性为undefined。 12345678910function* gen() &#123; yield 1; yield 2; yield 3;&#125;var g &#x3D; gen();g.next() &#x2F;&#x2F; &#123; value: 1, done: false &#125;g.return() &#x2F;&#x2F; &#123; value: undefined, done: true &#125; 如果 Generator 函数内部有try...finally代码块，且正在执行try代码块，那么return方法会导致立刻进入finally代码块，执行完以后，整个函数才会结束。 1234567891011121314151617function* numbers () &#123; yield 1; try &#123; yield 2; yield 3; &#125; finally &#123; yield 4; yield 5; &#125; yield 6;&#125;var g &#x3D; numbers();g.next() &#x2F;&#x2F; &#123; value: 1, done: false &#125;g.next() &#x2F;&#x2F; &#123; value: 2, done: false &#125;g.return(7) &#x2F;&#x2F; &#123; value: 4, done: false &#125;g.next() &#x2F;&#x2F; &#123; value: 5, done: false &#125;g.next() &#x2F;&#x2F; &#123; value: 7, done: true &#125; 上面代码中，调用return()方法后，就开始执行finally代码块，不执行try里面剩下的代码了，然后等到finally代码块执行完，再返回return()方法指定的返回值。 next()、throw()、return() 的共同点next()、throw()、return()这三个方法本质上是同一件事，可以放在一起理解。它们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换yield表达式。 next()是将yield表达式替换成一个值。 1234567891011const g &#x3D; function* (x, y) &#123; let result &#x3D; yield x + y; return result;&#125;;const gen &#x3D; g(1, 2);gen.next(); &#x2F;&#x2F; Object &#123;value: 3, done: false&#125;gen.next(1); &#x2F;&#x2F; Object &#123;value: 1, done: true&#125;&#x2F;&#x2F; 相当于将 let result &#x3D; yield x + y&#x2F;&#x2F; 替换成 let result &#x3D; 1; 上面代码中，第二个next(1)方法就相当于将yield表达式替换成一个值1。如果next方法没有参数，就相当于替换成undefined。 throw()是将yield表达式替换成一个throw语句。 123gen.throw(new Error(&#39;出错了&#39;)); &#x2F;&#x2F; Uncaught Error: 出错了&#x2F;&#x2F; 相当于将 let result &#x3D; yield x + y&#x2F;&#x2F; 替换成 let result &#x3D; throw(new Error(&#39;出错了&#39;)); return()是将yield表达式替换成一个return语句。 123gen.return(2); &#x2F;&#x2F; Object &#123;value: 2, done: true&#125;&#x2F;&#x2F; 相当于将 let result &#x3D; yield x + y&#x2F;&#x2F; 替换成 let result &#x3D; return 2; yield* 表达式如果在 Generator 函数内部，调用另一个 Generator 函数。需要在前者的函数体内部，自己手动完成遍历。 123456789101112131415161718192021function* foo() &#123; yield &#39;a&#39;; yield &#39;b&#39;;&#125;function* bar() &#123; yield &#39;x&#39;; &#x2F;&#x2F; 手动遍历 foo() for (let i of foo()) &#123; console.log(i); &#125; yield &#39;y&#39;;&#125;for (let v of bar())&#123; console.log(v);&#125;&#x2F;&#x2F; x&#x2F;&#x2F; a&#x2F;&#x2F; b&#x2F;&#x2F; y 上面代码中，foo和bar都是 Generator 函数，在bar里面调用foo，就需要手动遍历foo。如果有多个 Generator 函数嵌套，写起来就非常麻烦。 ES6 提供了yield*表达式，作为解决办法，用来在一个 Generator 函数里面执行另一个 Generator 函数。 123456789101112131415161718192021222324252627282930function* bar() &#123; yield &#39;x&#39;; yield* foo(); yield &#39;y&#39;;&#125;&#x2F;&#x2F; 等同于function* bar() &#123; yield &#39;x&#39;; yield &#39;a&#39;; yield &#39;b&#39;; yield &#39;y&#39;;&#125;&#x2F;&#x2F; 等同于function* bar() &#123; yield &#39;x&#39;; for (let v of foo()) &#123; yield v; &#125; yield &#39;y&#39;;&#125;for (let v of bar())&#123; console.log(v);&#125;&#x2F;&#x2F; &quot;x&quot;&#x2F;&#x2F; &quot;a&quot;&#x2F;&#x2F; &quot;b&quot;&#x2F;&#x2F; &quot;y&quot; 再来看一个对比的例子。 12345678910111213141516171819202122232425function* inner() &#123; yield &#39;hello!&#39;;&#125;function* outer1() &#123; yield &#39;open&#39;; yield inner(); yield &#39;close&#39;;&#125;var gen &#x3D; outer1()gen.next().value &#x2F;&#x2F; &quot;open&quot;gen.next().value &#x2F;&#x2F; 返回一个遍历器对象gen.next().value &#x2F;&#x2F; &quot;close&quot;function* outer2() &#123; yield &#39;open&#39; yield* inner() yield &#39;close&#39;&#125;var gen &#x3D; outer2()gen.next().value &#x2F;&#x2F; &quot;open&quot;gen.next().value &#x2F;&#x2F; &quot;hello!&quot;gen.next().value &#x2F;&#x2F; &quot;close&quot; 上面例子中，outer2使用了yield*，outer1没使用。结果就是，outer1返回一个遍历器对象，outer2返回该遍历器对象的内部值。 从语法角度看，如果yield表达式后面跟的是一个遍历器对象，需要在yield表达式后面加上星号，表明它返回的是一个遍历器对象。这被称为yield*表达式。 123456789101112131415161718let delegatedIterator &#x3D; (function* () &#123; yield &#39;Hello!&#39;; yield &#39;Bye!&#39;;&#125;());let delegatingIterator &#x3D; (function* () &#123; yield &#39;Greetings!&#39;; yield* delegatedIterator; yield &#39;Ok, bye.&#39;;&#125;());for(let value of delegatingIterator) &#123; console.log(value);&#125;&#x2F;&#x2F; &quot;Greetings!&#x2F;&#x2F; &quot;Hello!&quot;&#x2F;&#x2F; &quot;Bye!&quot;&#x2F;&#x2F; &quot;Ok, bye.&quot; 上面代码中，delegatingIterator是代理者，delegatedIterator是被代理者。由于yield* delegatedIterator语句得到的值，是一个遍历器，所以要用星号表示。运行结果就是使用一个遍历器，遍历了多个 Generator 函数，有递归的效果。 yield*后面的 Generator 函数（没有return语句时），等同于在 Generator 函数内部，部署一个for...of循环。 123456789101112131415function* concat(iter1, iter2) &#123; yield* iter1; yield* iter2;&#125;&#x2F;&#x2F; 等同于function* concat(iter1, iter2) &#123; for (var value of iter1) &#123; yield value; &#125; for (var value of iter2) &#123; yield value; &#125;&#125; 上面代码说明，yield*后面的 Generator 函数（没有return语句时），不过是for...of的一种简写形式，完全可以用后者替代前者。反之，在有return语句时，则需要用var value = yield* iterator的形式获取return语句的值。 如果yield*后面跟着一个数组，由于数组原生支持遍历器，因此就会遍历数组成员。 12345function* gen()&#123; yield* [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];&#125;gen().next() &#x2F;&#x2F; &#123; value:&quot;a&quot;, done:false &#125; 上面代码中，yield命令后面如果不加星号，返回的是整个数组，加了星号就表示返回的是数组的遍历器对象。 实际上，任何数据结构只要有 Iterator 接口，就可以被yield*遍历。 1234567let read &#x3D; (function* () &#123; yield &#39;hello&#39;; yield* &#39;hello&#39;;&#125;)();read.next().value &#x2F;&#x2F; &quot;hello&quot;read.next().value &#x2F;&#x2F; &quot;h&quot; 上面代码中，yield表达式返回整个字符串，yield*语句返回单个字符。因为字符串具有 Iterator 接口，所以被yield*遍历。 如果被代理的 Generator 函数有return语句，那么就可以向代理它的 Generator 函数返回数据。 1234567891011121314151617181920212223242526function* foo() &#123; yield 2; yield 3; return &quot;foo&quot;;&#125;function* bar() &#123; yield 1; var v &#x3D; yield* foo(); console.log(&quot;v: &quot; + v); yield 4;&#125;var it &#x3D; bar();it.next()&#x2F;&#x2F; &#123;value: 1, done: false&#125;it.next()&#x2F;&#x2F; &#123;value: 2, done: false&#125;it.next()&#x2F;&#x2F; &#123;value: 3, done: false&#125;it.next();&#x2F;&#x2F; &quot;v: foo&quot;&#x2F;&#x2F; &#123;value: 4, done: false&#125;it.next()&#x2F;&#x2F; &#123;value: undefined, done: true&#125; 上面代码在第四次调用next方法的时候，屏幕上会有输出，这是因为函数foo的return语句，向函数bar提供了返回值。 再看一个例子。 12345678910111213function* genFuncWithReturn() &#123; yield &#39;a&#39;; yield &#39;b&#39;; return &#39;The result&#39;;&#125;function* logReturned(genObj) &#123; let result &#x3D; yield* genObj; console.log(result);&#125;[...logReturned(genFuncWithReturn())]&#x2F;&#x2F; The result&#x2F;&#x2F; 值为 [ &#39;a&#39;, &#39;b&#39; ] 上面代码中，存在两次遍历。第一次是扩展运算符遍历函数logReturned返回的遍历器对象，第二次是yield*语句遍历函数genFuncWithReturn返回的遍历器对象。这两次遍历的效果是叠加的，最终表现为扩展运算符遍历函数genFuncWithReturn返回的遍历器对象。所以，最后的数据表达式得到的值等于[ &#39;a&#39;, &#39;b&#39; ]。但是，函数genFuncWithReturn的return语句的返回值The result，会返回给函数logReturned内部的result变量，因此会有终端输出。 yield*命令可以很方便地取出嵌套数组的所有成员。 1234567891011121314151617181920function* iterTree(tree) &#123; if (Array.isArray(tree)) &#123; for(let i&#x3D;0; i &lt; tree.length; i++) &#123; yield* iterTree(tree[i]); &#125; &#125; else &#123; yield tree; &#125;&#125;const tree &#x3D; [ &#39;a&#39;, [&#39;b&#39;, &#39;c&#39;], [&#39;d&#39;, &#39;e&#39;] ];for(let x of iterTree(tree)) &#123; console.log(x);&#125;&#x2F;&#x2F; a&#x2F;&#x2F; b&#x2F;&#x2F; c&#x2F;&#x2F; d&#x2F;&#x2F; e 由于扩展运算符…默认调用 Iterator 接口，所以上面这个函数也可以用于嵌套数组的平铺。 1[...iterTree(tree)] &#x2F;&#x2F; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;] 下面是一个稍微复杂的例子，使用yield*语句遍历完全二叉树。 1234567891011121314151617181920212223242526272829303132333435&#x2F;&#x2F; 下面是二叉树的构造函数，&#x2F;&#x2F; 三个参数分别是左树、当前节点和右树function Tree(left, label, right) &#123; this.left &#x3D; left; this.label &#x3D; label; this.right &#x3D; right;&#125;&#x2F;&#x2F; 下面是中序（inorder）遍历函数。&#x2F;&#x2F; 由于返回的是一个遍历器，所以要用generator函数。&#x2F;&#x2F; 函数体内采用递归算法，所以左树和右树要用yield*遍历function* inorder(t) &#123; if (t) &#123; yield* inorder(t.left); yield t.label; yield* inorder(t.right); &#125;&#125;&#x2F;&#x2F; 下面生成二叉树function make(array) &#123; &#x2F;&#x2F; 判断是否为叶节点 if (array.length &#x3D;&#x3D; 1) return new Tree(null, array[0], null); return new Tree(make(array[0]), array[1], make(array[2]));&#125;let tree &#x3D; make([[[&#39;a&#39;], &#39;b&#39;, [&#39;c&#39;]], &#39;d&#39;, [[&#39;e&#39;], &#39;f&#39;, [&#39;g&#39;]]]);&#x2F;&#x2F; 遍历二叉树var result &#x3D; [];for (let node of inorder(tree)) &#123; result.push(node);&#125;result&#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;] 作为对象属性的 Generator 函数如果一个对象的属性是 Generator 函数，可以简写成下面的形式。 12345let obj &#x3D; &#123; * myGeneratorMethod() &#123; ··· &#125;&#125;; 上面代码中，myGeneratorMethod属性前面有一个星号，表示这个属性是一个 Generator 函数。 它的完整形式如下，与上面的写法是等价的。 12345let obj &#x3D; &#123; myGeneratorMethod: function* () &#123; &#x2F;&#x2F; ··· &#125;&#125;; Generator 函数的thisGenerator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的prototype对象上的方法。 12345678910function* g() &#123;&#125;g.prototype.hello &#x3D; function () &#123; return &#39;hi!&#39;;&#125;;let obj &#x3D; g();obj instanceof g &#x2F;&#x2F; trueobj.hello() &#x2F;&#x2F; &#39;hi!&#39; 上面代码表明，Generator 函数g返回的遍历器obj，是g的实例，而且继承了g.prototype。但是，如果把g当作普通的构造函数，并不会生效，因为g返回的总是遍历器对象，而不是this对象。 1234567function* g() &#123; this.a &#x3D; 11;&#125;let obj &#x3D; g();obj.next();obj.a &#x2F;&#x2F; undefined 上面代码中，Generator 函数g在this对象上面添加了一个属性a，但是obj对象拿不到这个属性。 Generator 函数也不能跟new命令一起用，会报错。 1234567function* F() &#123; yield this.x &#x3D; 2; yield this.y &#x3D; 3;&#125;new F()&#x2F;&#x2F; TypeError: F is not a constructor 上面代码中，new命令跟构造函数F一起使用，结果报错，因为F不是构造函数。 那么，有没有办法让 Generator 函数返回一个正常的对象实例，既可以用next方法，又可以获得正常的this？下面是一个变通方法。首先，生成一个空对象，使用call方法绑定 Generator 函数内部的this。这样，构造函数调用以后，这个空对象就是 Generator 函数的实例对象了。 123456789101112131415function* F() &#123; this.a &#x3D; 1; yield this.b &#x3D; 2; yield this.c &#x3D; 3;&#125;var obj &#x3D; &#123;&#125;;var f &#x3D; F.call(obj);f.next(); &#x2F;&#x2F; Object &#123;value: 2, done: false&#125;f.next(); &#x2F;&#x2F; Object &#123;value: 3, done: false&#125;f.next(); &#x2F;&#x2F; Object &#123;value: undefined, done: true&#125;obj.a &#x2F;&#x2F; 1obj.b &#x2F;&#x2F; 2obj.c &#x2F;&#x2F; 3 上面代码中，首先是F内部的this对象绑定obj对象，然后调用它，返回一个 Iterator对象。这个对象执行三次next方法（因为F内部有两个yield表达式），完成 F 内部所有代码的运行。这时，所有内部属性都绑定在obj对象上了，因此obj对象也就成了F的实例。 上面代码中，执行的是遍历器对象f，但是生成的对象实例是obj，有没有办法将这两个对象统一呢？ 一个办法就是将obj换成F.prototype。 1234567891011121314function* F() &#123; this.a &#x3D; 1; yield this.b &#x3D; 2; yield this.c &#x3D; 3;&#125;var f &#x3D; F.call(F.prototype);f.next(); &#x2F;&#x2F; Object &#123;value: 2, done: false&#125;f.next(); &#x2F;&#x2F; Object &#123;value: 3, done: false&#125;f.next(); &#x2F;&#x2F; Object &#123;value: undefined, done: true&#125;f.a &#x2F;&#x2F; 1f.b &#x2F;&#x2F; 2f.c &#x2F;&#x2F; 3 再将F改成构造函数，就可以对它执行new命令了。 12345678910111213141516171819function* gen() &#123; this.a &#x3D; 1; yield this.b &#x3D; 2; yield this.c &#x3D; 3;&#125;function F() &#123; return gen.call(gen.prototype);&#125;var f &#x3D; new F();f.next(); &#x2F;&#x2F; Object &#123;value: 2, done: false&#125;f.next(); &#x2F;&#x2F; Object &#123;value: 3, done: false&#125;f.next(); &#x2F;&#x2F; Object &#123;value: undefined, done: true&#125;f.a &#x2F;&#x2F; 1f.b &#x2F;&#x2F; 2f.c &#x2F;&#x2F; 3 含义Generator 与状态机Generator 是实现状态机的最佳结构。比如，下面的clock函数就是一个状态机。 123456789101112131415161718var ticking &#x3D; true;var clock &#x3D; function() &#123; if (ticking) console.log(&#39;Tick!&#39;); else console.log(&#39;Tock!&#39;); ticking &#x3D; !ticking;&#125;上面代码的clock函数一共有两种状态（Tick和Tock），每运行一次，就改变一次状态。这个函数如果用 Generator 实现，就是下面这样。var clock &#x3D; function* () &#123; while (true) &#123; console.log(&#39;Tick!&#39;); yield; console.log(&#39;Tock!&#39;); yield; &#125;&#125;; 上面的 Generator 实现与 ES5 实现对比，可以看到少了用来保存状态的外部变量ticking，这样就更简洁，更安全（状态不会被非法篡改）、更符合函数式编程的思想，在写法上也更优雅。Generator 之所以可以不用外部变量保存状态，是因为它本身就包含了一个状态信息，即目前是否处于暂停态。 Generator 与协程协程（coroutine）是一种程序运行的方式，可以理解成“协作的线程”或“协作的函数”。协程既可以用单线程实现，也可以用多线程实现。前者是一种特殊的子例程，后者是一种特殊的线程。 （1）协程与子例程的差异 传统的“子例程”（subroutine）采用堆栈式“后进先出”的执行方式，只有当调用的子函数完全执行完毕，才会结束执行父函数。协程与其不同，多个线程（单线程情况下，即多个函数）可以并行执行，但是只有一个线程（或函数）处于正在运行的状态，其他线程（或函数）都处于暂停态（suspended），线程（或函数）之间可以交换执行权。也就是说，一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。 从实现上看，在内存中，子例程只使用一个栈（stack），而协程是同时存在多个栈，但只有一个栈是在运行状态，也就是说，协程是以多占用内存为代价，实现多任务的并行。 （2）协程与普通线程的差异 不难看出，协程适合用于多任务运行的环境。在这个意义上，它与普通的线程很相似，都有自己的执行上下文、可以分享全局变量。它们的不同之处在于，同一时间可以有多个线程处于运行状态，但是运行的协程只能有一个，其他协程都处于暂停状态。此外，普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。 由于 JavaScript 是单线程语言，只能保持一个调用栈。引入协程以后，每个任务可以保持自己的调用栈。这样做的最大好处，就是抛出错误的时候，可以找到原始的调用栈。不至于像异步操作的回调函数那样，一旦出错，原始的调用栈早就结束。 Generator 函数是 ES6 对协程的实现，但属于不完全实现。Generator 函数被称为“半协程”（semi-coroutine），意思是只有 Generator 函数的调用者，才能将程序的执行权还给 Generator 函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。 如果将 Generator 函数当作协程，完全可以将多个需要互相协作的任务写成 Generator 函数，它们之间使用yield表达式交换控制权。 Generator 与上下文JavaScript 代码运行时，会产生一个全局的上下文环境（context，又称运行环境），包含了当前所有的变量和对象。然后，执行函数（或块级代码）的时候，又会在当前上下文环境的上层，产生一个函数运行的上下文，变成当前（active）的上下文，由此形成一个上下文环境的堆栈（context stack）。 这个堆栈是后进先出的数据结构，最后产生的上下文环境首先执行完成，退出堆栈，然后再执行完成它下层的上下文，直至所有代码执行完成，堆栈清空。 Generator 函数不是这样，它执行产生的上下文环境，一旦遇到yield命令，就会暂时退出堆栈，但是并不消失，里面的所有变量和对象会冻结在当前状态。等到对它执行next命令时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行。 1234567891011function* gen() &#123; yield 1; return 2;&#125;let g &#x3D; gen();console.log( g.next().value, g.next().value,); 上面代码中，第一次执行g.next()时，Generator 函数gen的上下文会加入堆栈，即开始运行gen内部的代码。等遇到yield 1时，gen上下文退出堆栈，内部状态冻结。第二次执行g.next()时，gen上下文重新加入堆栈，变成当前的上下文，重新恢复执行。 应用Generator 可以暂停函数执行，返回任意表达式的值。这种特点使得 Generator 有多种应用场景。 （1）异步操作的同步化表达 Generator 函数的暂停执行的效果，意味着可以把异步操作写在yield表达式里面，等到调用next方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在yield表达式下面，反正要等到调用next方法时再执行。所以，Generator 函数的一个重要实际意义就是用来处理异步操作，改写回调函数。 1234567891011function* loadUI() &#123; showLoadingScreen(); yield loadUIDataAsynchronously(); hideLoadingScreen();&#125;var loader &#x3D; loadUI();&#x2F;&#x2F; 加载UIloader.next()&#x2F;&#x2F; 卸载UIloader.next() 上面代码中，第一次调用loadUI函数时，该函数不会执行，仅返回一个遍历器。下一次对该遍历器调用next方法，则会显示Loading界面（showLoadingScreen），并且异步加载数据（loadUIDataAsynchronously）。等到数据加载完成，再一次使用next方法，则会隐藏Loading界面。可以看到，这种写法的好处是所有Loading界面的逻辑，都被封装在一个函数，按部就班非常清晰。 Ajax 是典型的异步操作，通过 Generator 函数部署 Ajax 操作，可以用同步的方式表达。 1234567891011121314function* main() &#123; var result &#x3D; yield request(&quot;http:&#x2F;&#x2F;some.url&quot;); var resp &#x3D; JSON.parse(result); console.log(resp.value);&#125;function request(url) &#123; makeAjaxCall(url, function(response)&#123; it.next(response); &#125;);&#125;var it &#x3D; main();it.next(); 上面代码的main函数，就是通过 Ajax 操作获取数据。可以看到，除了多了一个yield，它几乎与同步操作的写法完全一样。注意，makeAjaxCall函数中的next方法，必须加上response参数，因为yield表达式，本身是没有值的，总是等于undefined。 下面是另一个例子，通过 Generator 函数逐行读取文本文件。 12345678910function* numbers() &#123; let file &#x3D; new FileReader(&quot;numbers.txt&quot;); try &#123; while(!file.eof) &#123; yield parseInt(file.readLine(), 10); &#125; &#125; finally &#123; file.close(); &#125;&#125; 上面代码打开文本文件，使用yield表达式可以手动逐行读取文件。 （2）控制流管理 如果有一个多步操作非常耗时，采用回调函数，可能会写成下面这样。 123456789step1(function (value1) &#123; step2(value1, function(value2) &#123; step3(value2, function(value3) &#123; step4(value3, function(value4) &#123; &#x2F;&#x2F; Do something with value4 &#125;); &#125;); &#125;);&#125;); 采用 Promise 改写上面的代码。 12345678910Promise.resolve(step1) .then(step2) .then(step3) .then(step4) .then(function (value4) &#123; &#x2F;&#x2F; Do something with value4 &#125;, function (error) &#123; &#x2F;&#x2F; Handle any error from step1 through step4 &#125;) .done(); 上面代码已经把回调函数，改成了直线执行的形式，但是加入了大量 Promise 的语法。Generator 函数可以进一步改善代码运行流程。 1234567891011function* longRunningTask(value1) &#123; try &#123; var value2 &#x3D; yield step1(value1); var value3 &#x3D; yield step2(value2); var value4 &#x3D; yield step3(value3); var value5 &#x3D; yield step4(value4); &#x2F;&#x2F; Do something with value4 &#125; catch (e) &#123; &#x2F;&#x2F; Handle any error from step1 through step4 &#125;&#125; 然后，使用一个函数，按次序自动执行所有步骤。 12345678910scheduler(longRunningTask(initialValue));function scheduler(task) &#123; var taskObj &#x3D; task.next(task.value); &#x2F;&#x2F; 如果Generator函数未结束，就继续调用 if (!taskObj.done) &#123; task.value &#x3D; taskObj.value scheduler(task); &#125;&#125; 注意，上面这种做法，只适合同步操作，即所有的task都必须是同步的，不能有异步操作。因为这里的代码一得到返回值，就继续往下执行，没有判断异步操作何时完成。如果要控制异步的操作流程，详见后面的《异步操作》一章。 下面，利用for...of循环会自动依次执行yield命令的特性，提供一种更一般的控制流管理的方法。 12345678let steps &#x3D; [step1Func, step2Func, step3Func];function* iterateSteps(steps)&#123; for (var i&#x3D;0; i&lt; steps.length; i++)&#123; var step &#x3D; steps[i]; yield step(); &#125;&#125; 上面代码中，数组steps封装了一个任务的多个步骤，Generator 函数iterateSteps则是依次为这些步骤加上yield命令。 将任务分解成步骤之后，还可以将项目分解成多个依次执行的任务。 12345678let jobs &#x3D; [job1, job2, job3];function* iterateJobs(jobs)&#123; for (var i&#x3D;0; i&lt; jobs.length; i++)&#123; var job &#x3D; jobs[i]; yield* iterateSteps(job.steps); &#125;&#125; 上面代码中，数组jobs封装了一个项目的多个任务，Generator 函数iterateJobs则是依次为这些任务加上yield*命令。 最后，就可以用for...of循环一次性依次执行所有任务的所有步骤。 123for (var step of iterateJobs(jobs))&#123; console.log(step.id);&#125; 再次提醒，上面的做法只能用于所有步骤都是同步操作的情况，不能有异步操作的步骤。如果想要依次执行异步的步骤，必须使用后面的《异步操作》一章介绍的方法。 for...of的本质是一个while循环，所以上面的代码实质上执行的是下面的逻辑。 12345678var it &#x3D; iterateJobs(jobs);var res &#x3D; it.next();while (!res.done)&#123; var result &#x3D; res.value; &#x2F;&#x2F; ... res &#x3D; it.next();&#125; （3）部署 Iterator 接口 利用 Generator 函数，可以在任意对象上部署 Iterator 接口。 12345678910111213141516function* iterEntries(obj) &#123; let keys &#x3D; Object.keys(obj); for (let i&#x3D;0; i &lt; keys.length; i++) &#123; let key &#x3D; keys[i]; yield [key, obj[key]]; &#125;&#125;let myObj &#x3D; &#123; foo: 3, bar: 7 &#125;;for (let [key, value] of iterEntries(myObj)) &#123; console.log(key, value);&#125;&#x2F;&#x2F; foo 3&#x2F;&#x2F; bar 7 上述代码中，myObj是一个普通对象，通过iterEntries函数，就有了 Iterator 接口。也就是说，可以在任意对象上部署next方法。 下面是一个对数组部署 Iterator 接口的例子，尽管数组原生具有这个接口。 12345678910111213function* makeSimpleGenerator(array)&#123; var nextIndex &#x3D; 0; while(nextIndex &lt; array.length)&#123; yield array[nextIndex++]; &#125;&#125;var gen &#x3D; makeSimpleGenerator([&#39;yo&#39;, &#39;ya&#39;]);gen.next().value &#x2F;&#x2F; &#39;yo&#39;gen.next().value &#x2F;&#x2F; &#39;ya&#39;gen.next().done &#x2F;&#x2F; true （4）作为数据结构 Generator 可以看作是数据结构，更确切地说，可以看作是一个数组结构，因为 Generator 函数可以返回一系列的值，这意味着它可以对任意表达式，提供类似数组的接口。 12345function* doStuff() &#123; yield fs.readFile.bind(null, &#39;hello.txt&#39;); yield fs.readFile.bind(null, &#39;world.txt&#39;); yield fs.readFile.bind(null, &#39;and-such.txt&#39;);&#125; 上面代码就是依次返回三个函数，但是由于使用了 Generator 函数，导致可以像处理数组那样，处理这三个返回的函数。 123for (task of doStuff()) &#123; &#x2F;&#x2F; task是一个函数，可以像回调函数那样使用它&#125; 实际上，如果用 ES5 表达，完全可以用数组模拟 Generator 的这种用法。 1234567function doStuff() &#123; return [ fs.readFile.bind(null, &#39;hello.txt&#39;), fs.readFile.bind(null, &#39;world.txt&#39;), fs.readFile.bind(null, &#39;and-such.txt&#39;) ];&#125; 上面的函数，可以用一模一样的for...of循环处理！两相一比较，就不难看出 Generator 使得数据或者操作，具备了类似数组的接口。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"数组的常见方法&数组的遍历","slug":"19-数组的常见方法&数组的遍历","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T10:03:38.000Z","comments":true,"path":"2020/04/18/19-数组的常见方法&数组的遍历/","link":"","permalink":"http://yoursite.com/2020/04/18/19-%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95&%E6%95%B0%E7%BB%84%E7%9A%84%E9%81%8D%E5%8E%86/","excerpt":"前言数组的四个基本方法如下：（数组元素的添加和删除） 方法 描述 备注 push() 向数组的最后面插入一个或多个元素，返回结果为该数组新的长度 会改变原数组 pop() 删除数组中的最后一个元素，返回结果为被删除的元素 会改变原数组 unshift() 在数组最前面插入一个或多个元素，返回结果为该数组新的长度 会改变原数组 shift() 删除数组中的第一个元素，返回结果为被删除的元素 会改变原数组","text":"前言数组的四个基本方法如下：（数组元素的添加和删除） 方法 描述 备注 push() 向数组的最后面插入一个或多个元素，返回结果为该数组新的长度 会改变原数组 pop() 删除数组中的最后一个元素，返回结果为被删除的元素 会改变原数组 unshift() 在数组最前面插入一个或多个元素，返回结果为该数组新的长度 会改变原数组 shift() 删除数组中的第一个元素，返回结果为被删除的元素 会改变原数组 数组的常见方法如下： 方法 描述 备注 slice() 从数组中提取指定的一个或多个元素，返回结果为新的数组 不会改变原数组 splice() 从数组中删除指定的一个或多个元素，返回结果为新的数组 会改变原数组 concat() 连接两个或多个数组，返回结果为新的数组 不会改变原数组 join() 将数组转换为字符串，返回结果为转换后的字符串 不会改变原数组 reverse() 反转数组，返回结果为反转后的数组 会改变原数组 sort() 对数组的元素,默认按照Unicode编码，从小到大进行排序 会改变原数组 遍历数组的方法如下： 方法 描述 备注 for循环 这个大家都懂 forEach() 和 for循环类似，但需要兼容IE8以上 forEach() 没有返回值。也就是说，它的返回值是 undefined map() 对原数组中的每一项进行加工，将组成新的数组 不会改变原数组 filter() 对数组中每一项运行回调函数，该函数返回结果是true的项，将组成新的数组，返回结果为新的数组。可以起到过滤的作用 不会改变原数组 every() 如果有一项返回false，则停止遍历，此方法返回 false 一假即假。要求每一项都返回true，最终的结果才返回true some() 只要有一项返回true，则停止遍历，此方法返回true 一真即真。要求每一项都返回false，最终的结果才返回false reduce 为数组中的每一个元素，依次执行回调函数 数组的其他方法如下： 方法 描述 备注 indexOf(value) 从前往后索引，获取 value 在数组中的第一个下标 lastIndexOf(value) 从后往前索引，获取 value 在数组中的最后一个下标 find(function()) 找出第一个满足「指定条件返回true」的元素。 findIndex(function()) 找出第一个满足「指定条件返回true」的元素的index Array.from(arrayLike) 将伪数组转化为真数组 Array.of(value1, value2, value3) 将一系列值转换成数组。 数组的四个基本方法（数组元素的添加和删除）push()push()：向数组的最后面插入一个或多个元素，返回结果为该数组新的长度。 语法： 1数组的新长度 = 数组.push(元素); 代码举例： 12345678var arr = [\"王一\", \"王二\", \"王三\"];var result1 = arr.push(\"王四\"); // 末尾插入一个元素var result2 = arr.push(\"王五\", \"王六\"); // 末尾插入多个元素console.log(result1); // 打印结果：4console.log(result2); // 打印结果：6console.log(JSON.stringify(arr)); // 打印结果：[\"王一\",\"王二\",\"王三\",\"王四\",\"王五\",\"王六\"] pop()pop()：删除数组中的最后一个元素，返回结果为被删除的元素。 语法： 1被删除的元素 = 数组.pop(); 代码举例： 123456var arr = [\"王一\", \"王二\", \"王三\"];var result1 = arr.pop();console.log(result1); // 打印结果：王三console.log(JSON.stringify(arr)); // 打印结果：[\"王一\",\"王二\"] unshift()unshift()：在数组最前面插入一个或多个元素，返回结果为该数组新的长度。插入元素后，其他元素的索引会依次调整。 语法： 1数组的新长度 = 数组.unshift(元素); 代码举例： 12345678var arr = [\"王一\", \"王二\", \"王三\"];var result1 = arr.unshift(\"王四\"); // 最前面插入一个元素var result2 = arr.unshift(\"王五\", \"王六\"); // 最前面插入多个元素console.log(result1); // 打印结果：4console.log(result2); // 打印结果：6console.log(JSON.stringify(arr)); // 打印结果：[\"王五\",\"王六\",\"王四\",\"王一\",\"王二\",\"王三\"] shift()shift()：删除数组中的第一个元素，返回结果为被删除的元素。 语法： 1被删除的元素 = 数组.shift(); 代码举例： 123456var arr = [\"王一\", \"王二\", \"王三\"];var result1 = arr.shift();console.log(result1); // 打印结果：王一console.log(JSON.stringify(arr)); // 打印结果：[\"王二\",\"王三\"] 数组的常见方法slice()slice()：从数组中提取指定的一个或者多个元素，返回结果为新的数组（不会改变原来的数组）。 备注：该方法不会改变原数组，而是将截取到的元素封装到一个新数组中返回。 语法： 1新数组 = 原数组.slice(开始位置的索引, 结束位置的索引); //注意：包含开始索引，不包含结束索引 举例： 123456789101112var arr = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"];var result1 = arr.slice(2); //从第二个值开始提取var result2 = arr.slice(-2); //提取最后两个元素var result3 = arr.slice(2, 4); //提取从第二个到第四个之间的值（不包括第四个值）var result4 = arr.slice(4, 2); //空console.log(\"arr:\" + JSON.stringify(arr));console.log(\"result1:\" + JSON.stringify(result1));console.log(\"result2:\" + JSON.stringify(result2));console.log(\"result3:\" + JSON.stringify(result3));console.log(\"result4:\" + JSON.stringify(result4)); 打印结果： 12345arr:[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"]result1:[\"c\",\"d\",\"e\",\"f\"]result2:[\"e\",\"f\"]result3:[\"c\",\"d\"]result4:[] 补充： 很多前端开发人员会用 slice()将伪数组，转化为真数组。写法如下： 123array = Array.prototye.slice.call(arrayLike)或者array = [].slice.call(arrayLike) ES6 看不下去这种蹩脚的转化方法，于是出了一个新的 API：（专门用来将伪数组转化成真数组） 1array = Array.from(arrayLike) splice()splice()：从数组中删除指定的一个或多个元素，返回结果为新的数组（会改变原来的数组）。 备注：该方法会改变原数组，会将指定元素从原数组中删除；被删除的元素会封装到一个新的数组中返回。 语法： 1新数组 = 原数组.splice(起始索引index, 需要删除的个数, 第三个参数, 第四个参数...); 上方语法中，第三个及之后的参数，表示：向原数组中添加新的元素，这些元素将会自动插入到开始位置索引的前面。 举例1： 12345var arr1 = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"];var result1 = arr1.splice(1); //从第index为1的位置开始，删除元素console.log(\"arr1：\" + JSON.stringify(arr1));console.log(\"result1：\" + JSON.stringify(result1)); 打印结果： 12arr1：[&quot;a&quot;]result1：[&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;] 举例2： 12345var arr2 = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"];var result2 = arr2.splice(-2); //删除最后两个元素console.log(\"arr2：\" + JSON.stringify(arr2));console.log(\"result2：\" + JSON.stringify(result2)); 打印结果： 12arr2：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]result2：[&quot;e&quot;,&quot;f&quot;] 举例3： 12345var arr3 = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"];var result3 = arr3.splice(1, 3); //从第index为1的位置开始删除元素,一共删除三个元素console.log(\"arr3：\" + JSON.stringify(arr3));console.log(\"result3：\" + JSON.stringify(result3)); 打印结果： 12arr3：[&quot;a&quot;,&quot;e&quot;,&quot;f&quot;]result3：[&quot;b&quot;,&quot;c&quot;,&quot;d&quot;] 举例4：（我们来看看第三个参数的用法） 1234567var arr4 = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"];//从第index为1的位置开始删除元素,一共删除三个元素。并且在 index=1 的前面追加两个元素var result4 = arr4.splice(1, 3, \"千古壹号\", \"vae\");console.log(\"arr4：\" + JSON.stringify(arr4));console.log(\"result4：\" + JSON.stringify(result4)); 打印结果： 12arr4：[\"a\",\"千古壹号\",\"vae\",\"e\",\"f\"]result4：[\"b\",\"c\",\"d\"] concat()concat()：连接两个或多个数组，返回结果为新的数组。（不会改变原数组） 语法： 1新数组 = 数组1.concat(数组2, 数组3 ...); 举例： 1234567891011121314var arr1 = [1, 2, 3];var arr2 = [\"a\", \"b\", \"c\"];var arr3 = [\"千古壹号\", \"vae\"];var result1 = arr1.concat(arr2);var result2 = arr2.concat(arr1, arr3);console.log(\"arr1 =\" + JSON.stringify(arr1));console.log(\"arr2 =\" + JSON.stringify(arr2));console.log(\"arr3 =\" + JSON.stringify(arr3));console.log(\"result1 =\" + JSON.stringify(result1));console.log(\"result2 =\" + JSON.stringify(result2)); 打印结果： 123456arr1 =[1,2,3]arr2 =[\"a\",\"b\",\"c\"]arr3 =[\"千古壹号\",\"vae\"]result1 =[1,2,3,\"a\",\"b\",\"c\"]result2 =[\"a\",\"b\",\"c\",1,2,3,\"千古壹号\",\"vae\"] 从打印结果中可以看到，原数组并没有被修改。 join()join()：将数组转换为字符串，返回结果为转换后的字符串（不会改变原来的数组）。 补充：join()方法可以指定一个字符串作为参数，这个字符串将会成为数组中元素的连接符；如果不指定连接符，则默认使用 , 作为连接符，此时和 toString()的效果是一致的。 语法： 1新的字符串 = 原数组.join(参数); // 参数选填 代码举例： 123456789101112var arr = [\"a\", \"b\", \"c\"];var result1 = arr.join(); // 这里没有指定连接符，所以默认使用 , 作为连接符var result2 = arr.join(\"-\"); // 使用指定的字符串作为连接符console.log(typeof arr); // 打印结果：objectconsole.log(typeof result1); // 打印结果：stringconsole.log(\"arr =\" + JSON.stringify(arr));console.log(\"result1 =\" + JSON.stringify(result1));console.log(\"result2 =\" + JSON.stringify(result2)); 上方代码中，最后三行的打印结果是： 123arr =[\"a\",\"b\",\"c\"]result1 =a,b,cresult2 =a-b-c reverse()reverse()：反转数组，返回结果为反转后的数组（会改变原来的数组）。 语法： 1反转后的数组 &#x3D; 数组.reverse(); 举例： 123456var arr = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"];var result = arr.reverse(); // 将数组 arr 进行反转console.log(\"arr =\" + JSON.stringify(arr));console.log(\"result =\" + JSON.stringify(result)); 打印结果： 12arr =[\"f\",\"e\",\"d\",\"c\",\"b\",\"a\"]result =[\"f\",\"e\",\"d\",\"c\",\"b\",\"a\"] 从打印结果可以看出，原来的数组已经被改变了。 sort()方法 sort()方法要好好理解。所以，我们单独用一大段来讲。 sort()：对数组的元素进行从小到大来排序（会改变原来的数组）。 sort()方法举例：无参时如果在使用 sort() 方法时不带参，则默认按照Unicode编码，从小到大进行排序。 举例1：（当数组中的元素为字符串时） 123456var arr1 = [\"e\", \"b\", \"d\", \"a\", \"f\", \"c\"];var result = arr1.sort(); // 将数组 arr1 进行排序console.log(\"arr1 =\" + JSON.stringify(arr1));console.log(\"result =\" + JSON.stringify(result)); 打印结果： 12arr1 =[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"]result =[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"] 从上方的打印结果中，我们可以看到，sort方法会改变原数组，而且方法的返回值也是同样的结果。 举例2：（当数组中的元素为数字时） 123456var arr2 = [5, 2, 11, 3, 4, 1];var result = arr2.sort(); // 将数组 arr2 进行排序console.log(\"arr2 =\" + JSON.stringify(arr2));console.log(\"result =\" + JSON.stringify(result)); 打印结果： 12arr2 =[1,11,2,3,4,5]result =[1,11,2,3,4,5] 上方的打印结果中，你会发现，使用 sort() 排序后，数字11竟然在数字2的前面。这是为啥呢？因为上面讲到了，sort()方法是按照Unicode编码进行排序的。 那如果我想让 arr2 里的数字，完全按照从小到大排序，怎么操作呢？继续往下看。 sort()方法举例：带参时如果在 sort()方法中带参，我们就可以自定义排序规则。具体做法如下： 我们可以在sort()添加一个回调函数，来指定排序规则。回调函数中需要定义两个形参，浏览器将会分别使用数组中的元素作为实参去调用回调函数 浏览器根据回调函数的返回值来决定元素的排序：（重要） 如果返回一个大于0的值，则元素会交换位置 如果返回一个小于0的值，则元素位置不变 如果返回一个0，则认为两个元素相等，则不交换位置 代码举例： 123456789101112131415var arr3 = [5, 2, 11, 3, 4, 1];// 自定义排序规则var result = arr3.sort(function(a, b) &#123;if (a &gt; b) &#123; // 如果 a 大于 b，则交换 a 和 b 的位置 return 1;&#125; else if (a &lt; b) &#123; // 如果 a 小于 b，则位置不变 return -1;&#125; else &#123; // 如果 a 等于 b，则位置不变 return 0;&#125;&#125;);console.log(\"arr3 =\" + JSON.stringify(arr3));console.log(\"result =\" + JSON.stringify(result)); 打印结果： 12arr3 =[1,2,3,4,5,11]result =[1,2,3,4,5,11] 上方代码的写法太啰嗦了，其实也可以简化为如下写法： 代码优化：（冒泡排序） 12345678910var arr3 = [5, 2, 11, 3, 4, 1];// 自定义排序规则var result = arr3.sort(function(a, b) &#123;return a - b; // 升序排列// return b - a; // 降序排列&#125;);console.log(\"arr3 =\" + JSON.stringify(arr3));console.log(\"result =\" + JSON.stringify(result)); 打印结果： 12arr3 =[1,2,3,4,5,11]result =[1,2,3,4,5,11] sort方法举例：将数组从小到大排序将数组从小到大排序，这个例子很常见。 下面这段代码，在实际开发中，经常用到，一定要掌握。完整代码如下： 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; let dataList = [ &#123; title: '品牌鞋子，高品质低价入手', publishTime: 200, &#125;, &#123; title: '不是很贵，但是很暖', publishTime: 100, &#125;, &#123; title: '无法拒绝的美食，跟我一起吃吃', publishTime: 300, &#125;, ]; console.log('qianguyihao 排序前的数组：' + JSON.stringify(dataList)); // 将dataList 数组，按照 publishTime 字段，从小到大排序。（会改变原数组） dataList.sort(function(a, b) &#123; return parseInt(a.publishTime) - parseInt(b.publishTime); &#125;); console.log('qianguyihao 排序后的数组：' + JSON.stringify(dataList)); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 打印结果： 123456789qianguyihao 排序前的数组：[ &#123;&quot;title&quot;:&quot;品牌鞋子，高品质低价入手&quot;,&quot;publishTime&quot;:200&#125;, &#123;&quot;title&quot;:&quot;不是很贵，但是很暖&quot;,&quot;publishTime&quot;:100&#125;, &#123;&quot;title&quot;:&quot;无法拒绝的美食，跟我一起吃吃&quot;,&quot;publishTime&quot;:300&#125;]qianguyihao 排序后的数组：[ &#123;&quot;title&quot;:&quot;不是很贵，但是很暖&quot;,&quot;publishTime&quot;:100&#125;, &#123;&quot;title&quot;:&quot;品牌鞋子，高品质低价入手&quot;,&quot;publishTime&quot;:200&#125;, &#123;&quot;title&quot;:&quot;无法拒绝的美食，跟我一起吃吃&quot;,&quot;publishTime&quot;:300&#125;] 数组的遍历遍历数组即：获取并操作数组中的每一个元素。在我们的实战开发中，使用得非常频繁。 遍历数组的方法包括：every()、filter()、forEach()、map()、some() PS：这几个方法不会修改原数组。 语法格式： 1234数组&#x2F;boolean&#x2F;无 &#x3D; 数组.every&#x2F;filter&#x2F;forEach&#x2F;map&#x2F;some( function(item, index, arr)&#123; 程序和返回值； &#125;) 有了这几种方法，就可以替代一些for循环了。下面依次来介绍。 for循环 遍历举例： 123456var arr = [\"生命壹号\",\"许嵩\",\"永不止步\"];for(var i = 0;i&lt;arr.length;i++)&#123; console.log(arr[i]); // arr[i]代表的是数组中的每一个元素i&#125;console.log(arr); forEach() 遍历 forEach() 这种遍历方法只支持IE8以上的浏览器。IE8及以下的浏览器均不支持该方法。所以如果需要兼容IE8，则不要使用forEach，改为使用for循环来遍历即可。 forEach()方法需要一个函数作为参数。这种函数，是由我们创建但是不由我们调用的，我们称为回调函数。 数组中有几个元素，该回调函数就会执行几次。执行完毕后，浏览器会将遍历到的元素。 回调函数中传递三个参数： 第一个参数，就是当前正在遍历的元素 第二个参数，就是当前正在遍历的元素的索引 第三个参数，就是正在遍历的数组 代码举例： 12345678var arr = [\"王一\", \"王二\", \"王三\"];arr.forEach(function(item, index, obj) &#123;console.log(\"item:\" + item);console.log(\"index:\" + index);console.log(\"obj:\" + obj);console.log(\"----------\");&#125;); 打印结果： 1234567891011121314item:王一index:0obj:王一,王二,王三----------item:王二index:1obj:王一,王二,王三----------item:王三index:2obj:王一,王二,王三---------- 注意，forEach() 的返回值是 undefined。也就是说，它没有返回值。如果你尝试 tempArry = arr.forEach()这种方式来接收，是达不到效果的。 map()方法解释：对数组中每一项运行回调函数，返回该函数的结果，组成的新数组（返回的是加工之后的新数组）。 举例1：（拷贝的过程中改变数组元素的值） 有一个已知的数组arr1，我要求让arr1中的每个元素的值都加10，这里就可以用到 map 方法。代码举例： 1234567var arr1 = [1, 3, 6, 2, 5, 6];var arr2 = arr1.map(function (item, index) &#123; return item + 10; //让arr1中的每个元素加10&#125;)console.log(arr2); 举例2：【重要案例，实际开发中经常用到】 将A数组中某个属性的值，存储到B数组中。代码举例： 1234567891011121314151617const arr1 = [ &#123; name: '千古壹号', age: '28' &#125;, &#123; name: '许嵩', age: '32' &#125;,];// 将数组 arr1 中的 name 属性，存储到 数组 arr2 中const arr2 = arr1.map(item =&gt; item.name);// 将数组 arr1 中的 name、age这两个属性，改一下“键”的名字，存储到 arr3中const arr3 = arr1.map(item =&gt; (&#123; myName: item.name, myAge: item.age,&#125;)); // 将数组 arr1 中的 name 属性，存储到 数组 arr2 中console.log('arr1:' + JSON.stringify(arr1));console.log('arr2:' + JSON.stringify(arr2));console.log('arr3:' + JSON.stringify(arr3)); 打印结果： 12345arr1:[&#123;&quot;name&quot;:&quot;千古壹号&quot;,&quot;age&quot;:&quot;28&quot;&#125;,&#123;&quot;name&quot;:&quot;许嵩&quot;,&quot;age&quot;:&quot;32&quot;&#125;]arr2:[&quot;千古壹号&quot;,&quot;许嵩&quot;]arr3:[&#123;&quot;myName&quot;:&quot;千古壹号&quot;,&quot;myAge&quot;:&quot;28&quot;&#125;,&#123;&quot;myName&quot;:&quot;许嵩&quot;,&quot;myAge&quot;:&quot;32&quot;&#125;] map的应用场景，主要就是以上两种。 filter()解释：对数组中每一项运行回调函数，该函数返回结果是true的项，将组成新的数组（返回值就是这个新的数组）。 举例1：找出数组 arr1 中大于4的元素，返回一个新的数组。代码如下： 123456var arr1 = [1, 3, 6, 2, 5, 6];var arr2 = arr1.filter(function(item, index) &#123; return item &gt; 4; //将arr1中大于4的元素返回，组成新的数组&#125;);console.log(JSON.stringify(arr2)); 打印结果： 1[6,5,6] 上方代码的ES6写法： 12345const arr1 = [1, 3, 6, 2, 5, 6];const arr2 = arr1.filter(item=&gt; item &gt; 4); //将arr1中大于4的元素返回，组成新的数组console.log(JSON.stringify(arr2)); 举例2： 获取数组A中指定类型的对象，放到数组B中。代码举例如下： 123456789const arr1 = [ &#123; name: '许嵩', type: '一线' &#125;, &#123; name: '周杰伦', type: '过气' &#125;, &#123; name: '邓紫棋', type: '一线' &#125;,];const arr2 = arr1.filter(item =&gt; item.type == '一线'); // 筛选出一线歌手console.log(JSON.stringify(arr2)); 打印结果： 1[&#123;\"name\":\"许嵩\",\"type\":\"一线\"&#125;,&#123;\"name\":\"邓紫棋\",\"type\":\"一线\"&#125;] every()方法every()：对数组中每一项运行回调函数，如果都返回true，every就返回true；如果有一项返回false，则停止遍历，此方法返回false。 注意：every()方法的返回值是boolean值，参数是回调函数。 举例： 1234567891011121314151617var arr1 = [\"千古\", \"宿敌\", \"南山忆\", \"素颜\"];var bool1 = arr1.every(function (element, index, array) &#123; if (element.length &gt; 2) &#123; return false; &#125; return true;&#125;);console.log(bool1); //输出结果：false。只要有一个元素的长度是超过两个字符的，就返回falsevar arr2 = [\"千古\", \"宿敌\", \"南山\", \"素颜\"];var bool2 = arr2.every(function (element, index, array) &#123; if (element.length &gt; 2) &#123; return false; &#125; return true;&#125;);console.log(bool2); //输出结果：true。因为每个元素的长度都是两个字符。 some()方法some()：对数组中每一项运行回调函数，只要有一项返回true，则停止遍历，此方法返回true。 注意：some()方法的返回值是boolean值。 reduce()方法 reduce的发音：[rɪ’djuːs]。中文含义是减少。 reduce()：为数组中的每一个元素，依次执行回调函数。 语法： 1234arr.reduce( function(previousValue, item, index, arr) &#123; &#125;, initialValue) 参数解释： previousValue：上一次调用回调函数时的返回值，或者初始值 currentValue：当前正在处理的数组元素 currentIndex：当前正在处理的数组元素下标 array：调用reduce()方法的数组 initialValue：可选的初始值（作为第一次调用回调函数时传给 previousValue 的值） 备注：如果能熟练使用 reduce 的用法，将能替代很多其他的数组方法。 举例1： 计算数组中所有元素项的总和。代码实现： 123456var arr = [2, 0, 1, 9, 6];sumValue = arr.reduce(function (total, item) &#123; // 计算 arr 数组中，所有元素项的综合 return total + item;&#125;, 0);console.log('sumValue:' + sumValue); // 打印结果：18 数组的其他方法indexOf() 和 lastIndexOf()：获取数据的索引语法： 123索引值 = 数组.indexOf(value);索引值 = 数组.lastIndexOf(value); 解释： indexOf(value)：从前往后索引，获取 value 在数组中的第一个下标。 lastIndexOf(value) ：从后往前索引，获取 value 在数组中的最后一个下标。 作用： 利用这个方法，我们可以判断某个值是否在指定的数组中。如果没找到则返回-1。 举例1： 1234var arr = [\"a\",\"b\",\"c\",\"d\",\"e\",\"d\",\"c\"];console.log(arr.indexOf(\"c\")); //从前往后，找第一个\"c\"在哪个位置console.log(arr.lastIndexOf(\"d\")); //从后往前，找第一个\"d\"在哪个位置 举例2：判断某个值是否在数组中 1234567891011var arr = [\"29926392220\", \"29965620629\", \"28003663436\", \" \", \"28818504366\"];var str = [ &#123;name:\"smyh\", id: \"12334\"&#125;, &#123;name:\"vae\", id: \"28818504366\"&#125;];str.filter(item =&gt; &#123; console.log(arr.indexOf(item.id));&#125;) find()语法： 1find(function(item, index, arr)&#123;return true&#125;) 作用：找出第一个满足「指定条件返回true」的元素。 备注：一旦找到符合条件的第一个元素，将不再继续往下遍历。 举例： 1234567let arr = [2, 3, 2, 5, 7, 6];let result = arr.find(function (item, index) &#123; return item &gt; 4; //遍历数组arr，一旦发现有第一个元素大于4，就把这个元素返回&#125;);console.log(result); //打印结果：5 findIndex()语法： 1findIndex(function(item, index, arr)&#123;return true&#125;) 作用：找出第一个满足「指定条件返回true」的元素的index。 举例： 我们直接把上面的代码中的find方法改成findIndex，来看看效果。 1234567let arr = [2, 3, 2, 5, 7, 6];let result = arr.findIndex(function (item, index) &#123; return item &gt; 4; //遍历数组arr，一旦发现有第一个元素大于4，就把这个元素的index返回&#125;);console.log(result); //打印结果：3 Array.from()语法： 1array = Array.from(arrayLike) 作用：将伪数组或可遍历对象转换为真数组。 举例： 12345678910111213&lt;body&gt;&lt;button&gt;按钮1&lt;/button&gt;&lt;button&gt;按钮2&lt;/button&gt;&lt;button&gt;按钮3&lt;/button&gt;&lt;script&gt; let btnArray = document.getElementsByTagName('button'); console.log(btnArray); console.log(btnArray[0]);&lt;/script&gt;&lt;/body&gt; 上面的布局中，有三个button标签，我们通过getElementsByTagName获取到的btnArray实际上是伪数组，并不是真实的数组： 既然btnArray是伪数组，它就不能使用数组的一般方法，否则会报错： 解决办法：采用Array.from方法将btnArray这个伪数组转换为真数组即可： 1Array.from(btnArray); 伪数组与真数组的区别： 伪数组的原型链中没有 Array.prototype，而真数组的原型链中有 Array.prototype。因此伪数组没有 pop、join等属性。 Array.of()语法： 1Array.of(value1, value2, value3) 作用：将一系列值转换成数组。 举例： 12let arr = Array.of(1, 'abc', true);console.log(arr); 其他isArray()：判断是否为数组1布尔值 = Array.isArray(被检测的值) ; 以前，我们会通过 A instanceof B来判断 A 是否属于 B 类型。但是在数组里，这种 instanceof 方法已经用的不多了，因为有下面isArray()方法。 toString()：转换数组1字符串 = 数组.toString(); 解释：把数组转换成字符串，每一项用,分割。 valueOf()：返回数组本身1数组本身 = 数组.valueOf(); 这个方法的意义不大。因为我们指直接写数组对象的名字，就已经是数组本身了。 数组练习splice()练习：数组去重代码实现： 1234567891011121314151617181920212223//创建一个数组var arr = [1, 2, 3, 2, 2, 1, 3, 4, 2, 5];//去除数组中重复的数字//获取数组中的每一个元素for (var i = 0; i &lt; arr.length; i++) &#123; //console.log(arr[i]); /*获取当前元素后的所有元素*/ for (var j = i + 1; j &lt; arr.length; j++) &#123; //console.log(\"----&gt;\"+arr[j]); //判断两个元素的值是否相等 if (arr[i] == arr[j]) &#123; //如果相等则证明出现了重复的元素，则删除j对应的元素 arr.splice(j, 1); //当删除了当前j所在的元素以后，后边的元素会自动补位 //此时将不会在比较这个元素吧，我需要在比较一次j所在位置的元素 //使j自减 j--; &#125; &#125;&#125;console.log(arr); 清空数组清空数组，有以下几种方式： 12345var array = [1,2,3,4,5,6];array.splice(0); //方式1：删除数组中所有项目array.length = 0; //方式2：length属性可以赋值，在其它语言中length是只读array = []; //方式3：推荐 练习1问题：将一个字符串数组输出为|分割的形式，比如“千古|宿敌|素颜”。使用两种方式实现。 答案： 方式1：（不推荐） 12345678var arr = [\"千古\",\"宿敌\",\"素颜\"];var str = arr[0];var separator = \"|\";for(var i = 1;i&lt; arr.length;i++) &#123; str += separator+arr[i]; //从第1个数组元素开始，每个元素前面加上符号\"|\"&#125;console.log(str); 不推荐这种方式，因为：由于字符串的不变性，str拼接过多的话，容易导致内存溢出（很多个str都堆放在栈里）。 方式2：（推荐。通过array数组自带的api来实现） 123var arr = [\"千古\",\"宿敌\",\"素颜\"];console.log(arr.join(\"|\")); 练习2题目：将一个字符串数组的元素的顺序进行反转，使用两种种方式实现。提示：第i个和第length-i-1个进行交换。 答案： 方式1： 1234567function reverse(array) &#123; var newArr = []; for (var i = array.length - 1; i &gt;= 0; i--) &#123; newArr[newArr.length] = array[i]; &#125; return newArr;&#125; 方式2：（算法里比较常见的方式） 12345678function reverse(array)&#123; for(var i=0;i&lt;array.length/2;i++)&#123; var temp = array[i]; array[i] = array[array.length-1-i]; array[array.length-1-i] = temp; &#125; return array;&#125; 方式3：（数组自带的reverse方法） 现在我们学习了数组自带的api，我们就可以直接使用reverse()方法。 练习3问题：针对工资的数组[1500,1200,2000,2100,1800]，把工资超过2000的删除。 答案： 12345678910var arr1 = [1500, 1200, 2000, 2100, 1800];var arr2 = arr1.filter(function (ele, index, array) &#123; if (ele &lt; 2000) &#123; return true; &#125; return false;&#125;)console.log(arr1);console.log(arr2); 练习4问题：找到数组[“c”,”a”,”z”,”a”,”x”,”a”]中每一个元素出现的次数。 分析：这道题建议用json数据来做，因为我们想知道a出现了几次，c出现了几次，x出现了几次。恰好k:v .. k:v这种键值对的形式就比数组方便很多了。 键值对的形式：用key代表数组中的元素，用value代表元素出现的次数。 略难，答案暂略。 练习5：数组去重问题：编写一个方法去掉一个数组中的重复元素。 分析：创建一个新数组，循环遍历，只要新数组中有老数组的值，就不用再添加了。 答案： 1234567891011121314151617181920212223// 编写一个方法 去掉一个数组的重复元素 var arr = [1,2,3,4,5,2,3,4]; console.log(arr); var aaa = fn(arr); console.log(aaa); //思路：创建一个新数组，循环遍历，只要新数组中有老数组的值，就不用再添加了。 function fn(array)&#123; var newArr = []; for(var i=0;i&lt;array.length;i++)&#123; //开闭原则 var bool = true; //每次都要判断新数组中是否有旧数组中的值。 for(var j=0;j&lt;newArr.length;j++)&#123; if(array[i] === newArr[j])&#123; bool = false; &#125; &#125; if(bool)&#123; newArr[newArr.length] = array[i]; &#125; &#125; return newArr; &#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"内置对象Math","slug":"20-内置对象：Math","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T10:00:06.000Z","comments":true,"path":"2020/04/18/20-内置对象：Math/","link":"","permalink":"http://yoursite.com/2020/04/18/20-%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%EF%BC%9AMath/","excerpt":"内置对象简介 JavaScript 中的对象分为3种：自定义对象 、内置对象、 浏览器对象。 前面两种对象：是JS的基础内容，属于 ECMAScript； 第三个浏览器对象：属于JS独有，即 JS 内置的API。","text":"内置对象简介 JavaScript 中的对象分为3种：自定义对象 、内置对象、 浏览器对象。 前面两种对象：是JS的基础内容，属于 ECMAScript； 第三个浏览器对象：属于JS独有，即 JS 内置的API。 内置对象：就是指这个语言自带的一些对象，供开发者使用，这些对象提供了一些常用或者最基本而必要的功能（属性和方法）。 内置对象最大的优点就是帮助我们快速开发。 JavaScript的内置对象： 内置对象 对象说明 Arguments 函数参数集合 Array 数组 Boolean 布尔对象 Math 数学对象 Date 日期时间 Error 异常对象 Function 函数构造器 Number 数值对象 Object 基础对象 RegExp 正则表达式对象 String 字符串对象 内置对象 Math 的常见方法Math 和其他的对象不同，它不是一个构造函数，不需要创建对象。所以我们不需要 通过 new 来调用，而是直接使用里面的属性和方法即可。 Math属于一个工具类，里面封装了数学运算相关的属性和方法。如下： 方法 描述 备注 Math.PI 圆周率 Math对象的属性 Math.abs() 返回绝对值 Math.floor() 向下取整（往小取值） Math.ceil() 向上取整（往大取值） Math.round() 四舍五入取整（正数四舍五入，负数五舍六入） Math.random() 生成0-1之间的随机浮点数 取值范围是 [0，1) Math.max(x, y, z) 返回多个数中的最大值 Math.min(x, y, z) 返回多个数中的最小值 Math.pow(x,y) 返回 x 的 y 次幂 Math.sqrt() 对一个数进行开方运算 举例： 1234567891011var num = -0.6;console.log(Math.abs(num)); //取绝对值console.log(Math.floor(num)); //向下取整，向小取console.log(Math.ceil(num)); //向上取整，向大取console.log(Math.round(num)); //四舍五入取整（正数四舍五入，负数五舍六入）console.log(Math.random()); //生成0-1之间的随机数 运行结果： 1234567890.6-1-0-10.6453756205275165 Math.abs() 方法方法定义：返回绝对值。 注意： 参数中可以接收字符串类型的数字，此时会将字符串做隐式类型转换，然后再调用 Math.abs() 方法。 代码举例： 1234567console.log(Math.abs(2)); // 2console.log(Math.abs(-2)); // 2// 先做隐式类型转换，将 '-2'转换为数字类型 -2，然后再调用 Math.abs()console.log(Math.abs('-2'));console.log(Math.abs('hello')); // NaN Math.random() 方法方法定义：生成 [0, 1) 之间的随机浮点数。 我们来看几个例子。 生成 [0, x) 之间的随机数1Math.round(Math.random()*x) 生成 [x, y) 之间的随机数1Math.round(Math.random()*(y-x)+x) 【重要】生成 [x, y]之间的随机整数也就是说：生成两个整数之间的随机整数，并且要包含这两个整数。 这个功能很常用，我们可以将其封装成一个方法，代码实现如下： 12345678/** 生成两个整数之间的随机整数，并且要包含这两个整数*/function getRandom(min, max) &#123; return Math.floor(Math.random() * (max - min + 1)) + min;&#125;console.log(getRandom(1, 10)); 随机点名根据上面的例子，我们还可以再延伸一下，来看看随机点名的例子。 12345678910/** 生成两个整数之间的随机整数，并且要包含这两个整数*/function getRandom(min, max) &#123; return Math.floor(Math.random() * (max - min + 1)) + min;&#125;const arr = ['许嵩', '邓紫棋', '毛不易', '解忧邵帅'];const index = getRandom(0, arr.length - 1); // 生成随机的indexconsole.log(arr[index]); // 随机点名 乘方如果想计算 a 的 b 次方，可以使用如下函数： 1Math.pow(a, b); 开方如果想计算数值a的开二次方，可以使用如下函数： 1Math.sqrt(a); sqrt即“square 开方”。比如： 1var a &#x3D; Math.sqrt(36); url 编码和解码URI (Uniform ResourceIdentifiers,通用资源标识符)进行编码，以便发送给浏览器。有效的URI中不能包含某些字符，例如空格。而这URI编码方法就可以对URI进行编码，它们用特殊的UTF-8编码替换所有无效的字符，从而让浏览器能够接受和理解。 12encodeURIComponent(); //把字符串作为 URI 组件进行编码decodeURIComponent(); //把字符串作为 URI 组件进行解码 举例： 12345var url = \"http://www.cnblogs.com/smyhvae/\";var str = encodeURIComponent(url);console.log(str); //打印url的编码console.log(decodeURIComponent(str)); //对url进行编码后，再解码，还原为url","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Generator函数的异步应用","slug":"20-Generator函数的异步应用","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T10:03:30.000Z","comments":true,"path":"2020/04/18/20-Generator函数的异步应用/","link":"","permalink":"http://yoursite.com/2020/04/18/20-Generator%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%82%E6%AD%A5%E5%BA%94%E7%94%A8/","excerpt":"前言本文主要内容： 传统方法 基本概念 Generator 函数 Thunk 函数 co 模块 传统方法ES6 诞生以前，异步编程的方法，大概有下面四种。 回调函数 事件监听 发布/订阅 Promise 对象","text":"前言本文主要内容： 传统方法 基本概念 Generator 函数 Thunk 函数 co 模块 传统方法ES6 诞生以前，异步编程的方法，大概有下面四种。 回调函数 事件监听 发布/订阅 Promise 对象 Generator 函数将 JavaScript 异步编程带入了一个全新的阶段。 基本概念异步所谓”异步”，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。 比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。 相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。 回调函数JavaScript 语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。回调函数的英语名字callback，直译过来就是”重新调用”。 读取文件进行处理，是这样写的。 1234fs.readFile(&#39;&#x2F;etc&#x2F;passwd&#39;, &#39;utf-8&#39;, function (err, data) &#123; if (err) throw err; console.log(data);&#125;); 上面代码中，readFile函数的第三个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了/etc/passwd这个文件以后，回调函数才会执行。 一个有趣的问题是，为什么 Node 约定，回调函数的第一个参数，必须是错误对象err（如果没有错误，该参数就是null）？ 原因是执行分成两段，第一段执行完以后，任务所在的上下文环境就已经结束了。在这以后抛出的错误，原来的上下文环境已经无法捕捉，只能当作参数，传入第二段。 Promise回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取A文件之后，再读取B文件，代码如下。 12345fs.readFile(fileA, &#39;utf-8&#39;, function (err, data) &#123; fs.readFile(fileB, &#39;utf-8&#39;, function (err, data) &#123; &#x2F;&#x2F; ... &#125;);&#125;); 不难想象，如果依次读取两个以上的文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。因为多个异步操作形成了强耦合，只要有一个操作需要修改，它的上层回调函数和下层回调函数，可能都要跟着修改。这种情况就称为”回调函数地狱”（callback hell）。 Promise 对象就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。采用 Promise，连续读取多个文件，写法如下。 123456789101112131415var readFile &#x3D; require(&#39;fs-readfile-promise&#39;);readFile(fileA).then(function (data) &#123; console.log(data.toString());&#125;).then(function () &#123; return readFile(fileB);&#125;).then(function (data) &#123; console.log(data.toString());&#125;).catch(function (err) &#123; console.log(err);&#125;); 上面代码中，我使用了fs-readfile-promise模块，它的作用就是返回一个 Promise 版本的readFile函数。Promise 提供then方法加载回调函数，catch方法捕捉执行过程中抛出的错误。 可以看到，Promise 的写法只是回调函数的改进，使用then方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。 Promise 的最大问题是代码冗余，原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆then，原来的语义变得很不清楚。 那么，有没有更好的写法呢？ Generator 函数协程传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做”协程”（coroutine），意思是多个线程互相协作，完成异步任务。 协程有点像函数，又有点像线程。它的运行流程大致如下。 第一步，协程A开始执行。 第二步，协程A执行到一半，进入暂停，执行权转移到协程B。 第三步，（一段时间后）协程B交还执行权。 第四步，协程A恢复执行。 上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行。 举例来说，读取文件的协程写法如下。 12345function* asyncJob() &#123; &#x2F;&#x2F; ...其他代码 var f &#x3D; yield readFile(fileA); &#x2F;&#x2F; ...其他代码&#125; 上面代码的函数asyncJob是一个协程，它的奥妙就在其中的yield命令。它表示执行到此处，执行权将交给其他协程。也就是说，yield命令是异步两个阶段的分界线。 协程遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。 协程的 Generator 函数实现Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。 整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用yield语句注明。Generator 函数的执行方法如下。 12345678function* gen(x) &#123; var y &#x3D; yield x + 2; return y;&#125;var g &#x3D; gen(1);g.next() &#x2F;&#x2F; &#123; value: 3, done: false &#125;g.next() &#x2F;&#x2F; &#123; value: undefined, done: true &#125; 上面代码中，调用 Generator 函数，会返回一个内部指针（即遍历器）g。这是 Generator 函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针g的next方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的yield语句，上例是执行到x + 2为止。 换言之，next方法的作用是分阶段执行Generator函数。每次调用next方法，会返回一个对象，表示当前阶段的信息（value属性和done属性）。value属性是yield语句后面表达式的值，表示当前阶段的值；done属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。 Generator 函数的数据交换和错误处理Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。 next返回值的 value 属性，是 Generator 函数向外输出数据；next方法还可以接受参数，向 Generator 函数体内输入数据。 12345678function* gen(x)&#123; var y &#x3D; yield x + 2; return y;&#125;var g &#x3D; gen(1);g.next() &#x2F;&#x2F; &#123; value: 3, done: false &#125;g.next(2) &#x2F;&#x2F; &#123; value: 2, done: true &#125; 上面代码中，第一个next方法的value属性，返回表达式x + 2的值3。第二个next方法带有参数2，这个参数可以传入 Generator 函数，作为上个阶段异步任务的返回结果，被函数体内的变量y接收。因此，这一步的value属性，返回的就是2（变量y的值）。 Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。 12345678910111213function* gen(x)&#123; try &#123; var y &#x3D; yield x + 2; &#125; catch (e)&#123; console.log(e); &#125; return y;&#125;var g &#x3D; gen(1);g.next();g.throw(&#39;出错了&#39;);&#x2F;&#x2F; 出错了 上面代码的最后一行，Generator 函数体外，使用指针对象的throw方法抛出的错误，可以被函数体内的try...catch代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。 异步任务的封装下面看看如何使用 Generator 函数，执行一个真实的异步任务。 1234567var fetch &#x3D; require(&#39;node-fetch&#39;);function* gen()&#123; var url &#x3D; &#39;https:&#x2F;&#x2F;api.github.com&#x2F;users&#x2F;github&#39;; var result &#x3D; yield fetch(url); console.log(result.bio);&#125; 上面代码中，Generator 函数封装了一个异步操作，该操作先读取一个远程接口，然后从 JSON 格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了yield命令。 执行这段代码的方法如下。 12345678var g &#x3D; gen();var result &#x3D; g.next();result.value.then(function(data)&#123; return data.json();&#125;).then(function(data)&#123; g.next(data);&#125;); 上面代码中，首先执行 Generator 函数，获取遍历器对象，然后使用next方法（第二行），执行异步任务的第一阶段。由于Fetch模块返回的是一个 Promise 对象，因此要用then方法调用下一个next方法。 可以看到，虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。 Thunk 函数Thunk 函数是自动执行 Generator 函数的一种方法。 参数的求值策略Thunk 函数早在上个世纪 60 年代就诞生了。 那时，编程语言刚刚起步，计算机学家还在研究，编译器怎么写比较好。一个争论的焦点是”求值策略”，即函数的参数到底应该何时求值。 1234567var x &#x3D; 1;function f(m) &#123; return m * 2;&#125;f(x + 5) 上面代码先定义函数f，然后向它传入表达式x + 5。请问，这个表达式应该何时求值？ 一种意见是”传值调用“（call by value），即在进入函数体之前，就计算x + 5的值（等于 6），再将这个值传入函数f。C 语言就采用这种策略。 另一种意见是“传名调用”（call by name），即直接将表达式x + 5传入函数体，只在用到它的时候求值。Haskell 语言采用这种策略。 传值调用和传名调用，哪一种比较好？ 回答是各有利弊。传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参数，有可能造成性能损失。 Thunk 函数的含义编译器的“传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 Thunk 函数。 123456789101112131415function f(m) &#123; return m * 2;&#125;f(x + 5);&#x2F;&#x2F; 等同于var thunk &#x3D; function () &#123; return x + 5;&#125;;function f(thunk) &#123; return thunk() * 2;&#125; 上面代码中，函数 f 的参数x + 5被一个函数替换了。凡是用到原参数的地方，对Thunk函数求值即可。 这就是 Thunk 函数的定义，它是“传名调用”的一种实现策略，用来替换某个表达式。 JavaScript 语言的 Thunk 函数JavaScript 语言是传值调用，它的 Thunk 函数含义有所不同。在 JavaScript 语言中，Thunk 函数替换的不是表达式，而是多参数函数，将其替换成一个只接受回调函数作为参数的单参数函数。 123456789101112&#x2F;&#x2F; 正常版本的readFile（多参数版本）fs.readFile(fileName, callback);&#x2F;&#x2F; Thunk版本的readFile（单参数版本）var Thunk &#x3D; function (fileName) &#123; return function (callback) &#123; return fs.readFile(fileName, callback); &#125;;&#125;;var readFileThunk &#x3D; Thunk(fileName);readFileThunk(callback); 上面代码中，fs模块的readFile方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做 Thunk 函数。 任何函数，只要参数有回调函数，就能写成 Thunk 函数的形式。下面是一个简单的 Thunk 函数转换器。12345678910111213141516171819&#x2F;&#x2F; ES5版本var Thunk &#x3D; function(fn)&#123; return function ()&#123; var args &#x3D; Array.prototype.slice.call(arguments); return function (callback)&#123; args.push(callback); return fn.apply(this, args); &#125; &#125;;&#125;;&#x2F;&#x2F; ES6版本const Thunk &#x3D; function(fn) &#123; return function (...args) &#123; return function (callback) &#123; return fn.call(this, ...args, callback); &#125; &#125;;&#125;; 使用上面的转换器，生成fs.readFile的 Thunk 函数。 12var readFileThunk &#x3D; Thunk(fs.readFile);readFileThunk(fileA)(callback); Thunkify 模块生产环境的转换器，建议使用 Thunkify 模块。 首先是安装。 $ npm install thunkify使用方式如下。 1234567var thunkify &#x3D; require(&#39;thunkify&#39;);var fs &#x3D; require(&#39;fs&#39;);var read &#x3D; thunkify(fs.readFile);read(&#39;package.json&#39;)(function(err, str)&#123; &#x2F;&#x2F; ...&#125;); Thunkify 的源码与上一节那个简单的转换器非常像。 1234567891011121314151617181920212223242526function thunkify(fn) &#123; return function() &#123; var args &#x3D; new Array(arguments.length); var ctx &#x3D; this; for (var i &#x3D; 0; i &lt; args.length; ++i) &#123; args[i] &#x3D; arguments[i]; &#125; return function (done) &#123; var called; args.push(function () &#123; if (called) return; called &#x3D; true; done.apply(null, arguments); &#125;); try &#123; fn.apply(ctx, args); &#125; catch (err) &#123; done(err); &#125; &#125; &#125;&#125;; 它的源码主要多了一个检查机制，变量called确保回调函数只运行一次。这样的设计与下文的 Generator 函数相关。请看下面的例子。 12345678910function f(a, b, callback)&#123; var sum &#x3D; a + b; callback(sum); callback(sum);&#125;var ft &#x3D; thunkify(f);var print &#x3D; console.log.bind(console);ft(1, 2)(print);&#x2F;&#x2F; 3 上面代码中，由于thunkify只允许回调函数执行一次，所以只输出一行结果。 Generator 函数的流程管理你可能会问， Thunk 函数有什么用？回答是以前确实没什么用，但是 ES6 有了 Generator 函数，Thunk 函数现在可以用于 Generator 函数的自动流程管理。 Generator 函数可以自动执行。 1234567891011function* gen() &#123; &#x2F;&#x2F; ...&#125;var g &#x3D; gen();var res &#x3D; g.next();while(!res.done)&#123; console.log(res.value); res &#x3D; g.next();&#125; 上面代码中，Generator 函数gen会自动执行完所有步骤。 但是，这不适合异步操作。如果必须保证前一步执行完，才能执行后一步，上面的自动执行就不可行。这时，Thunk 函数就能派上用处。以读取文件为例。下面的 Generator 函数封装了两个异步操作。 12345678910var fs &#x3D; require(&#39;fs&#39;);var thunkify &#x3D; require(&#39;thunkify&#39;);var readFileThunk &#x3D; thunkify(fs.readFile);var gen &#x3D; function* ()&#123; var r1 &#x3D; yield readFileThunk(&#39;&#x2F;etc&#x2F;fstab&#39;); console.log(r1.toString()); var r2 &#x3D; yield readFileThunk(&#39;&#x2F;etc&#x2F;shells&#39;); console.log(r2.toString());&#125;; 上面代码中，yield命令用于将程序的执行权移出 Generator 函数，那么就需要一种方法，将执行权再交还给 Generator 函数。 这种方法就是 Thunk 函数，因为它可以在回调函数里，将执行权交还给 Generator 函数。为了便于理解，我们先看如何手动执行上面这个 Generator 函数。 1234567891011var g &#x3D; gen();var r1 &#x3D; g.next();r1.value(function (err, data) &#123; if (err) throw err; var r2 &#x3D; g.next(data); r2.value(function (err, data) &#123; if (err) throw err; g.next(data); &#125;);&#125;); 上面代码中，变量g是 Generator 函数的内部指针，表示目前执行到哪一步。next方法负责将指针移动到下一步，并返回该步的信息（value属性和done属性）。 仔细查看上面的代码，可以发现 Generator 函数的执行过程，其实是将同一个回调函数，反复传入next方法的value属性。这使得我们可以用递归来自动完成这个过程。 Thunk 函数的自动流程管理Thunk 函数真正的威力，在于可以自动执行 Generator 函数。下面就是一个基于 Thunk 函数的 Generator 执行器。 1234567891011121314151617function run(fn) &#123; var gen &#x3D; fn(); function next(err, data) &#123; var result &#x3D; gen.next(data); if (result.done) return; result.value(next); &#125; next();&#125;function* g() &#123; &#x2F;&#x2F; ...&#125;run(g); 上面代码的run函数，就是一个 Generator 函数的自动执行器。内部的next函数就是 Thunk 的回调函数。next函数先将指针移到 Generator 函数的下一步（gen.next方法），然后判断 Generator 函数是否结束（result.done属性），如果没结束，就将next函数再传入 Thunk 函数（result.value属性），否则就直接退出。 有了这个执行器，执行 Generator 函数方便多了。不管内部有多少个异步操作，直接把 Generator 函数传入run函数即可。当然，前提是每一个异步操作，都要是 Thunk 函数，也就是说，跟在yield命令后面的必须是 Thunk 函数。 12345678var g &#x3D; function* ()&#123; var f1 &#x3D; yield readFileThunk(&#39;fileA&#39;); var f2 &#x3D; yield readFileThunk(&#39;fileB&#39;); &#x2F;&#x2F; ... var fn &#x3D; yield readFileThunk(&#39;fileN&#39;);&#125;;run(g); 上面代码中，函数g封装了n个异步的读取文件操作，只要执行run函数，这些操作就会自动完成。这样一来，异步操作不仅可以写得像同步操作，而且一行代码就可以执行。 Thunk 函数并不是 Generator 函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制 Generator 函数的流程，接收和交还程序的执行权。回调函数可以做到这一点，Promise 对象也可以做到这一点。 co 模块基本用法co 模块是著名程序员 TJ Holowaychuk 于 2013 年 6 月发布的一个小工具，用于 Generator 函数的自动执行。 下面是一个 Generator 函数，用于依次读取两个文件。 123456var gen &#x3D; function* () &#123; var f1 &#x3D; yield readFile(&#39;&#x2F;etc&#x2F;fstab&#39;); var f2 &#x3D; yield readFile(&#39;&#x2F;etc&#x2F;shells&#39;); console.log(f1.toString()); console.log(f2.toString());&#125;; co 模块可以让你不用编写 Generator 函数的执行器。12var co &#x3D; require(&#39;co&#39;);co(gen); 上面代码中，Generator 函数只要传入co函数，就会自动执行。 co函数返回一个Promise对象，因此可以用then方法添加回调函数。123co(gen).then(function ()&#123; console.log(&#39;Generator 函数执行完成&#39;);&#125;); 上面代码中，等到 Generator 函数执行结束，就会输出一行提示。 co 模块的原理为什么 co 可以自动执行 Generator 函数？ 前面说过，Generator 就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。 两种方法可以做到这一点。 （1）回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。 （2）Promise 对象。将异步操作包装成 Promise 对象，用then方法交回执行权。 co 模块其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个模块。使用 co 的前提条件是，Generator 函数的yield命令后面，只能是 Thunk 函数或 Promise 对象。如果数组或对象的成员，全部都是 Promise 对象，也可以使用 co，详见后文的例子。 上一节已经介绍了基于 Thunk 函数的自动执行器。下面来看，基于 Promise 对象的自动执行器。这是理解 co 模块必须的。 基于 Promise 对象的自动执行还是沿用上面的例子。首先，把fs模块的readFile方法包装成一个 Promise 对象。 1234567891011121314151617var fs &#x3D; require(&#39;fs&#39;);var readFile &#x3D; function (fileName)&#123; return new Promise(function (resolve, reject)&#123; fs.readFile(fileName, function(error, data)&#123; if (error) return reject(error); resolve(data); &#125;); &#125;);&#125;;var gen &#x3D; function* ()&#123; var f1 &#x3D; yield readFile(&#39;&#x2F;etc&#x2F;fstab&#39;); var f2 &#x3D; yield readFile(&#39;&#x2F;etc&#x2F;shells&#39;); console.log(f1.toString()); console.log(f2.toString());&#125;; 然后，手动执行上面的 Generator 函数。 1234567var g &#x3D; gen();g.next().value.then(function(data)&#123; g.next(data).value.then(function(data)&#123; g.next(data); &#125;);&#125;); 手动执行其实就是用then方法，层层添加回调函数。理解了这一点，就可以写出一个自动执行器。 123456789101112131415function run(gen)&#123; var g &#x3D; gen(); function next(data)&#123; var result &#x3D; g.next(data); if (result.done) return result.value; result.value.then(function(data)&#123; next(data); &#125;); &#125; next();&#125;run(gen); 上面代码中，只要 Generator 函数还没执行到最后一步，next函数就调用自身，以此实现自动执行。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"async函数","slug":"21-async函数","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:59:58.000Z","comments":true,"path":"2020/04/18/21-async函数/","link":"","permalink":"http://yoursite.com/2020/04/18/21-async%E5%87%BD%E6%95%B0/","excerpt":"前言本文主要内容： 含义 基本用法 语法 async 函数的实现原理 与其他异步处理方法的比较 顶层 await","text":"前言本文主要内容： 含义 基本用法 语法 async 函数的实现原理 与其他异步处理方法的比较 顶层 await 含义 ES2017 标准引入了async函数，使得异步操作变得更加方便。 async 函数是什么？一句话，它就是 Generator 函数的语法糖。 前文有一个 Generator 函数，依次读取两个文件。 1234567891011121314151617const fs &#x3D; require(&#39;fs&#39;);const readFile &#x3D; function (fileName) &#123; return new Promise(function (resolve, reject) &#123; fs.readFile(fileName, function(error, data) &#123; if (error) return reject(error); resolve(data); &#125;); &#125;);&#125;;const gen &#x3D; function* () &#123; const f1 &#x3D; yield readFile(&#39;&#x2F;etc&#x2F;fstab&#39;); const f2 &#x3D; yield readFile(&#39;&#x2F;etc&#x2F;shells&#39;); console.log(f1.toString()); console.log(f2.toString());&#125;; 上面代码的函数gen可以写成async函数，就是下面这样。 123456const asyncReadFile &#x3D; async function () &#123; const f1 &#x3D; await readFile(&#39;&#x2F;etc&#x2F;fstab&#39;); const f2 &#x3D; await readFile(&#39;&#x2F;etc&#x2F;shells&#39;); console.log(f1.toString()); console.log(f2.toString());&#125;; 一比较就会发现，async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。 async函数对 Generator 函数的改进，体现在以下四点。 （1）内置执行器。 Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。 1asyncReadFile(); 上面的代码调用了asyncReadFile函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用next方法，或者用co模块，才能真正执行，得到最后结果。 （2）更好的语义。 async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。 （3）更广的适用性。 co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。 （4）返回值是 Promise。 async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。 进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。 基本用法async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。 下面是一个例子。 123456789async function getStockPriceByName(name) &#123; const symbol &#x3D; await getStockSymbol(name); const stockPrice &#x3D; await getStockPrice(symbol); return stockPrice;&#125;getStockPriceByName(&#39;goog&#39;).then(function (result) &#123; console.log(result);&#125;); 上面代码是一个获取股票报价的函数，函数前面的async关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个Promise对象。 下面是另一个例子，指定多少毫秒后输出一个值。 123456789101112function timeout(ms) &#123; return new Promise((resolve) &#x3D;&gt; &#123; setTimeout(resolve, ms); &#125;);&#125;async function asyncPrint(value, ms) &#123; await timeout(ms); console.log(value);&#125;asyncPrint(&#39;hello world&#39;, 50); 上面代码指定 50 毫秒以后，输出hello world。 由于async函数返回的是 Promise 对象，可以作为await命令的参数。所以，上面的例子也可以写成下面的形式。 123456789101112async function timeout(ms) &#123; await new Promise((resolve) &#x3D;&gt; &#123; setTimeout(resolve, ms); &#125;);&#125;async function asyncPrint(value, ms) &#123; await timeout(ms); console.log(value);&#125;asyncPrint(&#39;hello world&#39;, 50); async 函数有多种使用形式。 123456789101112131415161718192021222324252627&#x2F;&#x2F; 函数声明async function foo() &#123;&#125;&#x2F;&#x2F; 函数表达式const foo &#x3D; async function () &#123;&#125;;&#x2F;&#x2F; 对象的方法let obj &#x3D; &#123; async foo() &#123;&#125; &#125;;obj.foo().then(...)&#x2F;&#x2F; Class 的方法class Storage &#123; constructor() &#123; this.cachePromise &#x3D; caches.open(&#39;avatars&#39;); &#125; async getAvatar(name) &#123; const cache &#x3D; await this.cachePromise; return cache.match(&#96;&#x2F;avatars&#x2F;$&#123;name&#125;.jpg&#96;); &#125;&#125;const storage &#x3D; new Storage();storage.getAvatar(&#39;jake&#39;).then(…);&#x2F;&#x2F; 箭头函数const foo &#x3D; async () &#x3D;&gt; &#123;&#125;; 语法async函数的语法规则总体上比较简单，难点是错误处理机制。 返回 Promise 对象 async函数返回一个 Promise 对象。 async函数内部return语句返回的值，会成为then方法回调函数的参数。 123456async function f() &#123; return &#39;hello world&#39;;&#125;f().then(v &#x3D;&gt; console.log(v))&#x2F;&#x2F; &quot;hello world&quot; 上面代码中，函数f内部return命令返回的值，会被then方法回调函数接收到。 async函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。123456789async function f() &#123; throw new Error(&#39;出错了&#39;);&#125;f().then( v &#x3D;&gt; console.log(v), e &#x3D;&gt; console.log(e))&#x2F;&#x2F; Error: 出错了 Promise 对象的状态变化async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。 下面是一个例子。 1234567async function getTitle(url) &#123; let response &#x3D; await fetch(url); let html &#x3D; await response.text(); return html.match(&#x2F;&lt;title&gt;([\\s\\S]+)&lt;\\&#x2F;title&gt;&#x2F;i)[1];&#125;getTitle(&#39;https:&#x2F;&#x2F;tc39.github.io&#x2F;ecma262&#x2F;&#39;).then(console.log)&#x2F;&#x2F; &quot;ECMAScript 2017 Language Specification&quot; 上面代码中，函数getTitle内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行then方法里面的console.log。 await 命令正常情况下，await命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。 12345678async function f() &#123; &#x2F;&#x2F; 等同于 &#x2F;&#x2F; return 123; return await 123;&#125;f().then(v &#x3D;&gt; console.log(v))&#x2F;&#x2F; 123 上面代码中，await命令的参数是数值123，这时等同于return 123。 另一种情况是，await命令后面是一个thenable对象（即定义then方法的对象），那么await会将其等同于 Promise 对象。 123456789101112131415161718class Sleep &#123; constructor(timeout) &#123; this.timeout &#x3D; timeout; &#125; then(resolve, reject) &#123; const startTime &#x3D; Date.now(); setTimeout( () &#x3D;&gt; resolve(Date.now() - startTime), this.timeout ); &#125;&#125;(async () &#x3D;&gt; &#123; const sleepTime &#x3D; await new Sleep(1000); console.log(sleepTime);&#125;)();&#x2F;&#x2F; 1000 上面代码中，await命令后面是一个Sleep对象的实例。这个实例不是 Promise 对象，但是因为定义了then方法，await会将其视为Promise处理。 这个例子还演示了如何实现休眠效果。JavaScript 一直没有休眠的语法，但是借助await命令就可以让程序停顿指定的时间。下面给出了一个简化的sleep实现。 123456789101112131415function sleep(interval) &#123; return new Promise(resolve &#x3D;&gt; &#123; setTimeout(resolve, interval); &#125;)&#125;&#x2F;&#x2F; 用法async function one2FiveInAsync() &#123; for(let i &#x3D; 1; i &lt;&#x3D; 5; i++) &#123; console.log(i); await sleep(1000); &#125;&#125;one2FiveInAsync(); await命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。 12345678async function f() &#123; await Promise.reject(&#39;出错了&#39;);&#125;f().then(v &#x3D;&gt; console.log(v)).catch(e &#x3D;&gt; console.log(e))&#x2F;&#x2F; 出错了 注意，上面代码中，await语句前面没有return，但是reject方法的参数依然传入了catch方法的回调函数。这里如果在await前面加上return，效果是一样的。 任何一个await语句后面的 Promise 对象变为reject状态，那么整个async函数都会中断执行。 1234async function f() &#123; await Promise.reject(&#39;出错了&#39;); await Promise.resolve(&#39;hello world&#39;); &#x2F;&#x2F; 不会执行&#125; 上面代码中，第二个await语句是不会执行的，因为第一个await语句状态变成了reject。 有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个await放在try…catch结构里面，这样不管这个异步操作是否成功，第二个await都会执行。 1234567891011async function f() &#123; try &#123; await Promise.reject(&#39;出错了&#39;); &#125; catch(e) &#123; &#125; return await Promise.resolve(&#39;hello world&#39;);&#125;f().then(v &#x3D;&gt; console.log(v))&#x2F;&#x2F; hello world 另一种方法是await后面的 Promise 对象再跟一个catch方法，处理前面可能出现的错误。 12345678910async function f() &#123; await Promise.reject(&#39;出错了&#39;) .catch(e &#x3D;&gt; console.log(e)); return await Promise.resolve(&#39;hello world&#39;);&#125;f().then(v &#x3D;&gt; console.log(v))&#x2F;&#x2F; 出错了&#x2F;&#x2F; hello world 错误处理如果await后面的异步操作出错，那么等同于async函数返回的 Promise 对象被reject。 12345678910async function f() &#123; await new Promise(function (resolve, reject) &#123; throw new Error(&#39;出错了&#39;); &#125;);&#125;f().then(v &#x3D;&gt; console.log(v)).catch(e &#x3D;&gt; console.log(e))&#x2F;&#x2F; Error：出错了 上面代码中，async函数f执行后，await后面的 Promise 对象会抛出一个错误对象，导致catch方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制，可以参考后文的“async 函数的实现原理”。 防止出错的方法，也是将其放在try…catch代码块之中。 123456789async function f() &#123; try &#123; await new Promise(function (resolve, reject) &#123; throw new Error(&#39;出错了&#39;); &#125;); &#125; catch(e) &#123; &#125; return await(&#39;hello world&#39;);&#125; 如果有多个await命令，可以统一放在try…catch结构中。 123456789101112async function main() &#123; try &#123; const val1 &#x3D; await firstStep(); const val2 &#x3D; await secondStep(val1); const val3 &#x3D; await thirdStep(val1, val2); console.log(&#39;Final: &#39;, val3); &#125; catch (err) &#123; console.error(err); &#125;&#125; 下面的例子使用try…catch结构，实现多次重复尝试。 123456789101112131415const superagent &#x3D; require(&#39;superagent&#39;);const NUM_RETRIES &#x3D; 3;async function test() &#123; let i; for (i &#x3D; 0; i &lt; NUM_RETRIES; ++i) &#123; try &#123; await superagent.get(&#39;http:&#x2F;&#x2F;google.com&#x2F;this-throws-an-error&#39;); break; &#125; catch(err) &#123;&#125; &#125; console.log(i); &#x2F;&#x2F; 3&#125;test(); 上面代码中，如果await操作成功，就会使用break语句退出循环；如果失败，会被catch语句捕捉，然后进入下一轮循环。 使用注意点 第一点，前面已经说过，await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try…catch代码块中。 第二点，多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。 12let foo &#x3D; await getFoo();let bar &#x3D; await getBar(); 上面代码中，getFoo和getBar是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发。 12345678&#x2F;&#x2F; 写法一let [foo, bar] &#x3D; await Promise.all([getFoo(), getBar()]);&#x2F;&#x2F; 写法二let fooPromise &#x3D; getFoo();let barPromise &#x3D; getBar();let foo &#x3D; await fooPromise;let bar &#x3D; await barPromise; 上面两种写法，getFoo和getBar都是同时触发，这样就会缩短程序的执行时间。 第三点，await命令只能用在async函数之中，如果用在普通函数，就会报错。 第四点，async 函数可以保留运行堆栈。 123const a &#x3D; () &#x3D;&gt; &#123; b().then(() &#x3D;&gt; c());&#125;; 上面代码中，函数a内部运行了一个异步任务b()。当b()运行的时候，函数a()不会中断，而是继续执行。等到b()运行结束，可能a()早就运行结束了，b()所在的上下文环境已经消失了。如果b()或c()报错，错误堆栈将不包括a()。 现在将这个例子改成async函数。 1234const a &#x3D; async () &#x3D;&gt; &#123; await b(); c();&#125;; 上面代码中，b()运行的时候，a()是暂停执行，上下文环境都保存着。一旦b()或c()报错，错误堆栈将包括a()。 async 函数的实现原理async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。 1234567891011async function fn(args) &#123; &#x2F;&#x2F; ...&#125;&#x2F;&#x2F; 等同于function fn(args) &#123; return spawn(function* () &#123; &#x2F;&#x2F; ... &#125;);&#125; 所有的async函数都可以写成上面的第二种形式，其中的spawn函数就是自动执行器。 与其他异步处理方法的比较我们通过一个例子，来看 async 函数与 Promise、Generator 函数的比较。 假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。 首先是 Promise 的写法。 123456789101112131415161718192021222324function chainAnimationsPromise(elem, animations) &#123; &#x2F;&#x2F; 变量ret用来保存上一个动画的返回值 let ret &#x3D; null; &#x2F;&#x2F; 新建一个空的Promise let p &#x3D; Promise.resolve(); &#x2F;&#x2F; 使用then方法，添加所有动画 for(let anim of animations) &#123; p &#x3D; p.then(function(val) &#123; ret &#x3D; val; return anim(elem); &#125;); &#125; &#x2F;&#x2F; 返回一个部署了错误捕捉机制的Promise return p.catch(function(e) &#123; &#x2F;* 忽略错误，继续执行 *&#x2F; &#125;).then(function() &#123; return ret; &#125;);&#125; 虽然 Promise 的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是 Promise 的 API（then、catch等等），操作本身的语义反而不容易看出来。 接着是 Generator 函数的写法。 123456789101112131415function chainAnimationsGenerator(elem, animations) &#123; return spawn(function*() &#123; let ret &#x3D; null; try &#123; for(let anim of animations) &#123; ret &#x3D; yield anim(elem); &#125; &#125; catch(e) &#123; &#x2F;* 忽略错误，继续执行 *&#x2F; &#125; return ret; &#125;);&#125; 上面代码使用 Generator 函数遍历了每个动画，语义比 Promise 写法更清晰，用户定义的操作全部都出现在spawn函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行 Generator 函数，上面代码的spawn函数就是自动执行器，它返回一个 Promise 对象，而且必须保证yield语句后面的表达式，必须返回一个 Promise。 最后是 async 函数的写法。 1234567891011async function chainAnimationsAsync(elem, animations) &#123; let ret &#x3D; null; try &#123; for(let anim of animations) &#123; ret &#x3D; await anim(elem); &#125; &#125; catch(e) &#123; &#x2F;* 忽略错误，继续执行 *&#x2F; &#125; return ret;&#125; 可以看到 Async 函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将 Generator 写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用 Generator 写法，自动执行器需要用户自己提供。 顶层 await根据语法规格，await命令只能出现在 async 函数内部，否则都会报错。 12&#x2F;&#x2F; 报错const data &#x3D; await fetch(&#39;https:&#x2F;&#x2F;api.example.com&#39;); 上面代码中，await命令独立使用，没有放在 async 函数里面，就会报错。 目前，有一个语法提案，允许在模块的顶层独立使用await命令，使得上面那行代码不会报错了。这个提案的目的，是借用await解决模块异步加载的问题。 顶层的await命令，保证只有异步操作完成，模块才会输出值。 1234&#x2F;&#x2F; awaiting.jsconst dynamic &#x3D; import(someMission);const data &#x3D; fetch(url);export const output &#x3D; someProcess((await dynamic).default, await data); 上面代码中，两个异步操作在输出的时候，都加上了await命令。只有等到异步操作完成，这个模块才会输出值。 加载这个模块的写法如下。 123456&#x2F;&#x2F; usage.jsimport &#123; output &#125; from &quot;.&#x2F;awaiting.js&quot;;function outputPlusValue(value) &#123; return output + value &#125;console.log(outputPlusValue(100));setTimeout(() &#x3D;&gt; console.log(outputPlusValue(100), 1000); 上面代码的写法，与普通的模块加载完全一样。也就是说，模块的使用者完全不用关心，依赖模块的内部有没有异步操作，正常加载即可。 这时，模块的加载会等待依赖模块（上例是awaiting.js）的异步操作完成，才执行后面的代码，有点像暂停在那里。所以，它总是会得到正确的output，不会因为加载时机的不同，而得到不一样的值。 下面是顶层await的一些使用场景。 12345678910111213&#x2F;&#x2F; import() 方法加载const strings &#x3D; await import(&#96;&#x2F;i18n&#x2F;$&#123;navigator.language&#125;&#96;);&#x2F;&#x2F; 数据库操作const connection &#x3D; await dbConnector();&#x2F;&#x2F; 依赖回滚let jQuery;try &#123; jQuery &#x3D; await import(&#39;https:&#x2F;&#x2F;cdn-a.com&#x2F;jQuery&#39;);&#125; catch &#123; jQuery &#x3D; await import(&#39;https:&#x2F;&#x2F;cdn-b.com&#x2F;jQuery&#39;);&#125; 注意，如果加载多个包含顶层await命令的模块，加载命令是同步执行的。 123456789101112&#x2F;&#x2F; x.jsconsole.log(&quot;X1&quot;);await new Promise(r &#x3D;&gt; setTimeout(r, 1000));console.log(&quot;X2&quot;);&#x2F;&#x2F; y.jsconsole.log(&quot;Y&quot;);&#x2F;&#x2F; z.jsimport &quot;.&#x2F;x.js&quot;;import &quot;.&#x2F;y.js&quot;;console.log(&quot;Z&quot;); 上面代码有三个模块，最后的z.js加载x.js和y.js，打印结果是X1、Y、X2、Z。这说明，z.js并没有等待x.js加载完成，再去加载y.js。 顶层的await命令有点像，交出代码的执行权给其他的模块加载，等异步操作完成后，再拿回执行权，继续向下执行。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"内置对象Date","slug":"21-内置对象：Date","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:59:52.000Z","comments":true,"path":"2020/04/18/21-内置对象：Date/","link":"","permalink":"http://yoursite.com/2020/04/18/21-%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%EF%BC%9ADate/","excerpt":"内置对象：Date Date 对象在实际开发中，使用得很频繁，且容易在细节地方出错，需要引起重视。 内置对象 Date 用来处理日期和时间。","text":"内置对象：Date Date 对象在实际开发中，使用得很频繁，且容易在细节地方出错，需要引起重视。 内置对象 Date 用来处理日期和时间。 需要注意的是：与 Math 对象不同，Date 对象是一个构造函数 ，需要先实例化后才能使用。 创建Date对象创建Date对象有两种写法： 写法一：如果Date()不写参数，就返回当前时间对象 写法二：如果Date()里面写参数，就返回括号里输入的时间对象 针对这两种写法，我们来具体讲一讲。 写法一：不传递参数时，则获取系统的当前时间对象代码举例： 123var date1 = new Date();console.log(date1);console.log(typeof date1); 代码解释：不传递参数时，表示的是获取系统的当前时间对象。也可以理解成是：获取当前代码执行的时间。 打印结果： 12Mon Feb 17 2020 21:57:22 GMT+0800 (中国标准时间)object 写法二：传递参数参数中既可以传递数字，也可以传递字符串。 代码举例： 1234567891011121314151617181920212223var date21 = new Date('2020/02/17 21:00:00');console.log(date21);// Mon Feb 17 2020 21:00:00 GMT+0800 (中国标准时间)var date22 = new Date(2020, 2, 18); // 第二个参数返回的是三月，不是二月console.log(date22);// Wed Mar 18 2020 00:00:00 GMT+0800 (中国标准时间)var date23 = new Date(2020, 3, 18, 22, 59, 58);console.log(date23);// Sat Apr 18 2020 22:59:58 GMT+0800 (中国标准时间)var date24 = new Date('2020/04/19'); // 返回的就是四月console.log(date24);// Sun Apr 19 2020 00:00:00 GMT+0800 (中国标准时间)var date25 = new Date('2020-05-20');console.log(date25);// Wed May 20 2020 08:00:00 GMT+0800 (中国标准时间)var date26 = new Date('Wed Jan 27 2017 12:00:00 GMT+0800 (中国标准时间)');console.log(date26);// Fri Jan 27 2017 12:00:00 GMT+0800 (中国标准时间) 日期的格式化上一段内容里，我们获取到了 Date 对象，但这个对象，打印出来的结果并不是特别直观。 如果我们需要获取日期的指定部分，就需要用到 Date对象自带的方法。 获取了日期指定的部分之后，我们就可以让日期按照指定的格式，进行展示（即日期的格式化）。比如说，我期望能以 2020-02-02 19:30:59 这种格式进行展示。 在这之前，我们先来看看 Date 对象有哪些方法。 Date对象的方法Date对象 有如下方法，可以获取日期和时间的指定部分： getFullYear() 获取年份 getMonth() 获取月 0-11（0代表一月） getDate() 获取日 1-31。即：获取的是几号 getDay() 获取星期 0-6（0代表周日，1代表周一） getHours() 获取小时 0-23 getMinutes() 获取分钟 0-59 getSeconds() 获取秒 0-59 getMilliseconds() 获取毫秒 （1s = 1000ms） 代码举例： 1234567891011121314151617// 我在执行这行代码时，当前时间为 2019年2月4日，周一，13:23:52var myDate = new Date();console.log(myDate); // 打印结果：Mon Feb 04 2019 13:23:52 GMT+0800 (中国标准时间)console.log(myDate.getFullYear()); // 打印结果：2019console.log(myDate.getMonth() + 1); // 打印结果：2console.log(myDate.getDate()); // 打印结果：4console.log(myDate.getDay()); // 打印结果：1console.log(myDate.getHours()); // 打印结果：13console.log(myDate.getMinutes()); // 打印结果：23console.log(myDate.getSeconds()); // 打印结果：52console.log(myDate.getMilliseconds()); // 打印结果：393console.log(myDate.getTime()); // 获取时间戳。打印结果：1549257832393 获取了日期和时间的指定部分之后，我们把它们用字符串拼接起来，就可以按照自己想要的格式，来展示日期。 举例1：年月日的格式化代码举例： 123456789// 格式化年月日：2020年2月2日 星期三var date = new Date();var year = date.getFullYear();var month = date.getMonth() + 1;var dates = date.getDate();var day = date.getDay();var arr = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'];console.log('今天是：' + year + '年' + month + '月' + dates + '日 ' + arr[day]); 举例2：时分秒的格式化封装一个函数，返回当前时间的时分秒，格式为 06:06:06） getTime()：获取时间戳Date对象 还有如下方法： getTime() 获取当前日期对象的时间戳。这个方法在实际开发中，用得比较多。 啥叫时间戳？接下来，我们解释一下。 时间戳：指的是从格林威治标准时间的1970年1月1日，0时0分0秒到当前日期所花费的毫秒数（1秒 = 1000毫秒）。 计算机底层在保存时间时，使用的都是时间戳。时间戳的存在，就是为了统一时间的单位。 我们再来看下面这样的代码： 123var myDate = new Date(\"1970/01/01 0:0:0\");console.log(myDate.getTime()); // 获取时间戳 打印结果（可能会让你感到惊讶） 1-28800000 为啥打印结果是-28800000，而不是0呢？这是因为，我们的当前代码，是在中文环境下运行的，与英文时间会存在8个小时的时差（中文时间比英文时间早了八个小时）。如果代码是在英文环境下运行，打印结果就是0。 利用时间戳检测代码的执行时间： 我们可以在业务代码的前面定义 时间戳1，在业务代码的后面定义 时间戳2。把这两个时间戳相减，就能得出业务代码的执行时间。 format()将时间对象转换为指定格式。 参考链接：https://www.cnblogs.com/tugenhua0707/p/3776808.html 练习举例1：模拟日历要求每天打开这个页面，都能定时显示当前的日期。 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div &#123; width: 800px; margin: 200px auto; color: red; text-align: center; font: 600 30px/30px \"simsun\"; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; //模拟日历 //需求：每天打开这个页面都能定时显示年月日和星期几 //1.创建一个当前日期的日期对象 var date = new Date(); //2.然后获取其中的年、月、日和星期 var year = date.getFullYear(); var month = date.getMonth(); var hao = date.getDate(); var week = date.getDay();// console.log(year+\" \"+month+\" \"+hao+\" \"+week); //3.赋值给div var arr = [\"星期日\",\"星期一\",\"星期二\",\"星期三\",\"星期四\",\"星期五\",\"星期六\"]; var div = document.getElementsByTagName(\"div\")[0]; div.innerText = \"今天是：\"+year+\"年\"+(month+1)+\"月\"+hao+\"日 \"+arr[week]; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 举例2：发布会倒计时实现思路： 设置一个定时器，每间隔1毫秒就自动刷新一次div的内容。 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div &#123; width: 1210px; margin: 200px auto; color: red; text-align: center; font: 600 30px/30px \"simsun\"; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;script&gt; var div = document.getElementsByTagName(\"div\")[0]; var timer = setInterval(fn, 1); function fn() &#123; var nowtime = new Date(); var future = new Date(\"2019/02/03 11:20:00\"); var timeSum = future.getTime() - nowtime.getTime(); //获取时间差：发布会时间减去此刻的毫秒值 var day = parseInt(timeSum / 1000 / 60 / 60 / 24); var hour = parseInt(timeSum / 1000 / 60 / 60 % 24); var minu = parseInt(timeSum / 1000 / 60 % 60); var sec = parseInt(timeSum / 1000 % 60); var millsec = parseInt(timeSum % 1000); //问题处理：所有的时间小于10的时候，在前面自动补0，毫秒值要补双0（比如如，把 8 秒改成 08 秒） day = day &lt; 10 ? \"0\" + day : day; //day小于10吗？如果小于，就补0；如果不小于，就是day本身 hour = hour &lt; 10 ? \"0\" + hour : hour; minu = minu &lt; 10 ? \"0\" + minu : minu; sec = sec &lt; 10 ? \"0\" + sec : sec; if (millsec &lt; 10) &#123; millsec = \"00\" + millsec; &#125; else if (millsec &lt; 100) &#123; millsec = \"0\" + millsec; &#125;// console.log(day);// console.log(parseInt(timeSum/1000/60/60/24)); if (timeSum &lt; 0) &#123; div.innerHTML = \"距离苹果发布会还有00天00小时00分00秒000毫秒\"; clearInterval(timer); return; &#125; div.innerHTML = \"距离苹果发布会还有\" + day + \"天\" + hour + \"小时\" + minu + \"分\" + sec + \"秒\" + millsec + \"毫秒\"; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Class的基本语法","slug":"22-Class的基本语法","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:59:42.000Z","comments":true,"path":"2020/04/18/22-Class的基本语法/","link":"","permalink":"http://yoursite.com/2020/04/18/22-Class%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","excerpt":"前言 简介 静态方法 实例属性的新写法 静态属性 私有方法和私有属性 new.target 属性","text":"前言 简介 静态方法 实例属性的新写法 静态属性 私有方法和私有属性 new.target 属性 简介 类的由来JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。 12345678910function Point(x, y) &#123; this.x &#x3D; x; this.y &#x3D; y;&#125;Point.prototype.toString &#x3D; function () &#123; return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;&#125;;var p &#x3D; new Point(1, 2); 上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。 ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。 基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的class改写，就是下面这样。 12345678910class Point &#123; constructor(x, y) &#123; this.x &#x3D; x; this.y &#x3D; y; &#125; toString() &#123; return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;; &#125;&#125; 上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。也就是说，ES5 的构造函数Point，对应 ES6 的Point类的构造方法。 Point类除了构造方法，还定义了一个toString方法。注意，定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。 ES6 的类，完全可以看作构造函数的另一种写法。 123456class Point &#123; &#x2F;&#x2F; ...&#125;typeof Point &#x2F;&#x2F; &quot;function&quot;Point &#x3D;&#x3D;&#x3D; Point.prototype.constructor &#x2F;&#x2F; true 上面代码表明，类的数据类型就是函数，类本身就指向构造函数。 使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。 12345678class Bar &#123; doStuff() &#123; console.log(&#39;stuff&#39;); &#125;&#125;var b &#x3D; new Bar();b.doStuff() &#x2F;&#x2F; &quot;stuff&quot; 构造函数的prototype属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。 在类的实例上面调用方法，其实就是调用原型上的方法。 1234class B &#123;&#125;let b &#x3D; new B();b.constructor &#x3D;&#x3D;&#x3D; B.prototype.constructor &#x2F;&#x2F; true 上面代码中，b是B类的实例，它的constructor方法就是B类原型的constructor方法。 由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign方法可以很方便地一次向类添加多个方法。 12345678910class Point &#123; constructor()&#123; &#x2F;&#x2F; ... &#125;&#125;Object.assign(Point.prototype, &#123; toString()&#123;&#125;, toValue()&#123;&#125;&#125;); prototype对象的constructor属性，直接指向“类”的本身，这与 ES5 的行为是一致的。 1234567- 另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。### constructor 方法- &#96;constructor&#96;方法是类的默认方法，通过&#96;new&#96;命令生成对象实例时，自动调用该方法。一个类必须有&#96;constructor&#96;方法，如果没有显式定义，一个空的&#96;constructor&#96;方法会被默认添加。 class Point {} // 等同于class Point { constructor() {}} 1234上面代码中，定义了一个空的类Point，JavaScript 引擎会自动为它添加一个空的constructor方法。- constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。 class Foo { constructor() { return Object.create(null); }} new Foo() instanceof Foo // false 1234上面代码中，constructor函数返回一个全新的对象，结果导致实例对象不是Foo类的实例。- 类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。 class Foo { constructor() { return Object.create(null); }} Foo()// TypeError: Class constructor Foo cannot be invoked without ‘new’ 1234### 类的实例- 生成类的实例的写法，与 ES5 完全一样，也是使用new命令。前面说过，如果忘记加上new，像函数那样调用Class，将会报错。 class Point { // …} // 报错var point = Point(2, 3); // 正确var point = new Point(2, 3); 12- 与 ES5 一样，**实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）**。 //定义类class Point { constructor(x, y) { this.x = x; this.y = y; } toString() { return ‘(‘ + this.x + ‘, ‘ + this.y + ‘)’; } } var point = new Point(2, 3); point.toString() // (2, 3) point.hasOwnProperty(‘x’) // truepoint.hasOwnProperty(‘y’) // truepoint.hasOwnProperty(‘toString’) // falsepoint.proto.hasOwnProperty(‘toString’) // true 1234上面代码中，x和y都是实例对象point自身的属性（因为定义在this变量上），所以&#96;hasOwnProperty&#96;方法返回true，而&#96;toString&#96;是原型对象的属性（因为定义在Point类上），所以&#96;hasOwnProperty&#96;方法返回&#96;false&#96;。这些都与 ES5 的行为保持一致。- 与 ES5 一样，类的所有实例共享一个原型对象。 var p1 = new Point(2,3);var p2 = new Point(3,2); p1.proto === p2.proto//true 123456上面代码中，p1和p2都是Point的实例，它们的原型都是Point.prototype，所以__proto__属性是相等的。- 这也意味着，**可以通过实例的__proto__属性为“类”添加方法**。 - &#96;__proto__&#96; 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 &#96;Object.getPrototypeOf&#96; 方法来获取实例对象的原型，然后再来为原型添加方法&#x2F;属性。 var p1 = new Point(2,3);var p2 = new Point(3,2); p1.proto.printName = function () { return ‘Oops’ }; p1.printName() // “Oops”p2.printName() // “Oops” var p3 = new Point(4,2);p3.printName() // “Oops” 123456上面代码在p1的原型上添加了一个printName方法，由于p1的原型就是p2的原型，因此p2也可以调用这个方法。而且，此后新建的实例p3也可以调用这个方法。这意味着，使用实例的&#96;__proto__&#96;属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。### 取值函数（getter）和存值函数（setter）与 ES5 一样，**在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为**。 class MyClass { constructor() { // … } get prop() { return ‘getter’; } set prop(value) { console.log(‘setter: ‘+value); }} let inst = new MyClass(); inst.prop = 123;// setter: 123 inst.prop// ‘getter’ 123456789上面代码中，prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。- 存值函数和取值函数是设置在属性的 Descriptor 对象上的。### 属性表达式类的属性名，可以采用表达式。 let methodName = ‘getArea’; class Square { constructor(length) { // … } methodName { // … }} 123456上面代码中，Square类的方法名getArea，是从表达式得到的。### Class 表达式与函数一样，类也可以**使用表达式的形式**定义。 const MyClass = class Me { getClassName() { return Me.name; }}; 12上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是Me，但是Me只在 Class 的内部可用，指代当前类。在 Class 外部，这个类只能用MyClass引用。 let inst = new MyClass();inst.getClassName() // MeMe.name // ReferenceError: Me is not defined 1234上面代码表示，Me只在 Class 内部有定义。如果类的内部没用到的话，可以省略Me，也就是可以写成下面的形式。 const MyClass = class { /* … */ }; 12采用 Class 表达式，可以写出立即执行的 Class。 let person = new class { constructor(name) { this.name = name; } sayName() { console.log(this.name); }}(‘张三’); person.sayName(); // “张三” 123456789101112上面代码中，person是一个立即执行的类的实例。### 注意点- （1）严格模式类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。- （2）不存在提升类不存在变量提升（hoist），这一点与 ES5 完全不同。 new Foo(); // ReferenceErrorclass Foo {} 12上面代码中，Foo类使用在前，定义在后，这样会报错，因为 ES6 不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，**必须保证子类在父类之后定义**。 { let Foo = class {}; class Bar extends Foo { }} 123456上面的代码不会报错，因为Bar继承Foo的时候，Foo已经有定义了。但是，如果存在class的提升，上面代码就会报错，因为class会被提升到代码头部，而let命令是不提升的，所以导致Bar继承Foo的时候，Foo还没有定义。- （3）name 属性由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。 class Point {}Point.name // “Point” 123456name属性总是返回紧跟在class关键字后面的类名。- （4）Generator 方法如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。 class Foo { constructor(…args) { this.args = args; } Symbol.iterator {for (let arg of this.args) { yield arg;}}} for (let x of new Foo(‘hello’, ‘world’)) { console.log(x);}// hello// world 123456上面代码中，Foo类的Symbol.iterator方法前有一个星号，表示该方法是一个 Generator 函数。Symbol.iterator方法返回一个Foo类的默认遍历器，for...of循环会自动调用这个遍历器。- （5）this 的指向类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。 class Logger { printName(name = ‘there’) { this.print(Hello ${name}); } print(text) { console.log(text); }} const logger = new Logger();const { printName } = logger;printName(); // TypeError: Cannot read property ‘print’ of undefined 1234上面代码中，printName方法中的this，默认指向Logger类的实例。但是，如果将这个方法提取出来单独使用，this会指向该方法运行时所在的环境（由于 class 内部是严格模式，所以 this 实际指向的是undefined），从而导致找不到print方法而报错。一个比较简单的解决方法是，在构造方法中绑定this，这样就不会找不到print方法了。 class Logger { constructor() { this.printName = this.printName.bind(this); } // …} 1另一种解决方法是使用箭头函数。 class Obj { constructor() { this.getThis = () =&gt; this; }} const myObj = new Obj();myObj.getThis() === myObj // true 12345678箭头函数内部的this总是指向定义时所在的对象。上面代码中，箭头函数位于构造函数内部，它的定义生效的时候，是在构造函数执行的时候。这时，箭头函数所在的运行环境，肯定是实例对象，所以this会总是指向实例对象。还有一种解决方法是使用Proxy，获取方法的时候，自动绑定this。## 静态方法- 类相当于实例的原型，所有在类中定义的方法，都会被实例继承。**如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”**。 class Foo { static classMethod() { return ‘hello’; }} Foo.classMethod() // ‘hello’ var foo = new Foo();foo.classMethod()// TypeError: foo.classMethod is not a function 1234上面代码中，Foo类的classMethod方法前有&#96;static&#96;关键字，表明该方法是一个静态方法，可以直接在Foo类上调用（Foo.classMethod()），而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。&gt; 注意，**如果静态方法包含&#96;this&#96;关键字，这个&#96;this&#96;指的是类，而不是实例**。 class Foo { static bar() { this.baz(); } static baz() { console.log(‘hello’); } baz() { console.log(‘world’); }} Foo.bar() // hello 1234上面代码中，静态方法bar调用了this.baz，这里的this指的是Foo类，而不是Foo的实例，等同于调用Foo.baz。另外，从这个例子还可以看出，静态方法可以与非静态方法重名。- 父类的静态方法，可以被子类继承。 class Foo { static classMethod() { return ‘hello’; }} class Bar extends Foo {} Bar.classMethod() // ‘hello’ 1234上面代码中，父类Foo有一个静态方法，子类Bar可以调用这个方法。- 静态方法也是可以从super对象上调用的。 class Foo { static classMethod() { return ‘hello’; }} class Bar extends Foo { static classMethod() { return super.classMethod() + ‘, too’; }} Bar.classMethod() // “hello, too” 1234## 实例属性的新写法实例属性除了定义在&#96;constructor()&#96;方法里面的&#96;this&#96;上面，也可以定义在类的最顶层。 class IncreasingCounter { constructor() { this._count = 0; } get value() { console.log(‘Getting the current value!’); return this._count; } increment() { this._count++; }} 12上面代码中，实例属性this._count定义在constructor()方法里面。另一种写法是，这个属性也可以定义在类的最顶层，其他都不变。 class IncreasingCounter { _count = 0; get value() { console.log(‘Getting the current value!’); return this._count; } increment() { this._count++; }} 12345678上面代码中，实例属性_count与取值函数value()和increment()方法，处于同一个层级。这时，不需要在实例属性前面加上this。这种新写法的好处是，所有实例对象自身的属性都定义在类的头部，看上去比较整齐，一眼就能看出这个类有哪些实例属性。## 静态属性静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。 class Foo {} Foo.prop = 1;Foo.prop // 1 1234上面的写法为Foo类定义了一个静态属性prop。目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。现在有一个提案提供了类的静态属性，写法是在实例属性的前面，加上static关键字。 class MyClass { static myStaticProp = 42; constructor() { console.log(MyClass.myStaticProp); // 42 }} 12345678## 私有方法和私有属性### 现有的解决方案私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问。这是常见需求，有利于代码的封装，但 ES6 不提供，只能通过变通方法模拟实现。一种做法是在命名上加以区别。 class Widget { // 公有方法 foo (baz) { this._bar(baz); } // 私有方法 _bar(baz) { return this.snaf = baz; } // …} 1234上面代码中，_bar方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。 class Widget { foo (baz) { bar.call(this, baz); } // …} function bar(baz) { return this.snaf = baz;} 1234上面代码中，foo是公开方法，内部调用了bar.call(this, baz)。这使得bar实际上成为了当前模块的私有方法。还有一种方法是利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。 const bar = Symbol(‘bar’);const snaf = Symbol(‘snaf’); export default class myClass{ // 公有方法 foo(baz) { thisbar; } // 私有方法 bar { return this[snaf] = baz; } // …}; 12上面代码中，bar和snaf都是Symbol值，一般情况下无法获取到它们，因此达到了私有方法和私有属性的效果。但是也不是绝对不行，Reflect.ownKeys()依然可以拿到它们。 const inst = new myClass(); Reflect.ownKeys(myClass.prototype)// [ ‘constructor’, ‘foo’, Symbol(bar) ]上面代码中，Symbol 值的属性名依然可以从类的外部拿到。 1234### 私有属性的提案目前，**有一个提案，为class加了私有属性。方法是在属性名之前，使用#表示**。 class IncreasingCounter { #count = 0; get value() { console.log(‘Getting the current value!’); return this.#count; } increment() { this.#count++; }} 12上面代码中，#count就是私有属性，只能在类的内部使用（this.#count）。如果在类的外部使用，就会报错。 const counter = new IncreasingCounter();counter.#count // 报错counter.#count = 42 // 报错 1234上面代码在类的外部，读取私有属性，就会报错。下面是另一个例子。 class Point { #x; constructor(x = 0) { this.#x = +x; } get x() { return this.#x; } set x(value) { this.#x = +value; }} 123456上面代码中，#x就是私有属性，在Point类之外是读取不到这个属性的。由于井号#是属性名的一部分，使用时必须带有#一起使用，所以#x和x是两个不同的属性。之所以要引入一个新的前缀#表示私有属性，而没有采用private关键字，是因为 JavaScript 是一门动态语言，没有类型声明，使用独立的符号似乎是唯一的比较方便可靠的方法，能够准确地区分一种属性是否为私有属性。另外，Ruby 语言使用@表示私有属性，ES6 没有用这个符号而使用#，是因为@已经被留给了 Decorator。这种写法不仅可以写私有属性，还可以用来写私有方法。 class Foo { #a; #b; constructor(a, b) { this.#a = a; this.#b = b; } #sum() { return #a + #b; } printSum() { console.log(this.#sum()); }} 1234上面代码中，#sum()就是一个私有方法。另外，私有属性也可以设置 getter 和 setter 方法。 class Counter { #xValue = 0; constructor() { super(); // … } get #x() { return #xValue; } set #x(value) { this.#xValue = value; }} 1234上面代码中，#x是一个私有属性，它的读写都通过get #x()和set #x()来完成。- 私有属性不限于从this引用，只要是在类的内部，实例也可以引用私有属性。 class Foo { #privateValue = 42; static getPrivateValue(foo) { return foo.#privateValue; }} Foo.getPrivateValue(new Foo()); // 42 1234上面代码允许从实例foo上面引用私有属性。- 私有属性和私有方法前面，也可以加上static关键字，表示这是一个静态的私有属性或私有方法。 class FakeMath { static PI = 22 / 7; static #totallyRandomNumber = 4; static #computeRandomNumber() { return FakeMath.#totallyRandomNumber; } static random() { console.log(‘I heard you like random numbers…’) return FakeMath.#computeRandomNumber(); }} FakeMath.PI // 3.142857142857143FakeMath.random()// I heard you like random numbers…// 4FakeMath.#totallyRandomNumber // 报错FakeMath.#computeRandomNumber() // 报错 123456上面代码中，&#96;#totallyRandomNumber&#96;是私有属性，&#96;#computeRandomNumber()&#96;是私有方法，只能在FakeMath这个类的内部调用，外部调用就会报错。## new.target 属性new是从构造函数生成实例对象的命令。ES6 为new命令引入了一个&#96;new.target&#96;属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过&#96;new&#96;命令或&#96;Reflect.construct()&#96;调用的，&#96;new.target&#96;会返回&#96;undefined&#96;，因此这个属性可以用来确定构造函数是怎么调用的。 function Person(name) { if (new.target !== undefined) { this.name = name; } else { throw new Error(‘必须使用 new 命令生成实例’); }} // 另一种写法function Person(name) { if (new.target === Person) { this.name = name; } else { throw new Error(‘必须使用 new 命令生成实例’); }} var person = new Person(‘张三’); // 正确var notAPerson = Person.call(person, ‘张三’); // 报错 1234上面代码确保构造函数只能通过new命令调用。- Class 内部调用new.target，返回当前 Class。 class Rectangle { constructor(length, width) { console.log(new.target === Rectangle); this.length = length; this.width = width; }} var obj = new Rectangle(3, 4); // 输出 true 12- 需要注意的是，子类继承父类时，new.target会返回子类。 class Rectangle { constructor(length, width) { console.log(new.target === Rectangle); // … }} class Square extends Rectangle { constructor(length, width) { super(length, width); }} var obj = new Square(3); // 输出 false 1234上面代码中，new.target会返回子类。利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。 class Shape { constructor() { if (new.target === Shape) { throw new Error(‘本类不能实例化’); } }} class Rectangle extends Shape { constructor(length, width) { super(); // … }} var x = new Shape(); // 报错var y = new Rectangle(3, 4); // 正确 ``` 上面代码中，Shape类不能被实例化，只能用于继承。 注意，在函数外部，使用new.target会报错。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"内置对象：String","slug":"22-内置对象：String","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T09:59:36.000Z","comments":true,"path":"2020/04/18/22-内置对象：String/","link":"","permalink":"http://yoursite.com/2020/04/18/22-%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%EF%BC%9AString/","excerpt":"前言 在日常开发中，String对象的使用频率是非常高的。所以有必要详细介绍。","text":"前言 在日常开发中，String对象的使用频率是非常高的。所以有必要详细介绍。 基本数据类型不能绑定属性和方法1、基本数据类型： 注意，基本数据类型string是无法绑定属性和方法的。比如说： 12345var str = \"qianguyihao\";str.aaa = 12;console.log(typeof str); //打印结果为：stringconsole.log(str.aaa); //打印结果为：undefined 上方代码中，当我们尝试打印str.aaa的时候，会发现打印结果为：undefined。也就是说，不能给 string 绑定属性和方法。 当然，我们可以打印str.length、str.indexOf(“m”)等等。因为这两个方法的底层做了数据类型转换（临时将 string 字符串转换为 String 对象，然后再调用内置方法），也就是我们在上一篇文章中讲到的包装类。 2、引用数据类型： 引用数据类型String是可以绑定属性和方法的。如下： 12345var strObj = new String(\"smyhvae\");strObj.aaa = 123;console.log(strObj);console.log(typeof strObj); //打印结果：Objectconsole.log(strObj.aaa); 内置对象Number也有一些自带的方法，比如： Number.MAX_VALUE; Number.MIN_VALUE; 内置对象Boolean也有一些自带的方法，但是用的不多。 在底层，字符串以字符数组的形式保存在底层，字符串是以字符数组的形式保存的。代码举例： 123var str = \"smyhvae\";console.log(str.length); // 获取字符串的长度console.log(str[2]); // 获取字符串中的第2个字符 上方代码中，smyhvae这个字符串在底层是以[&quot;s&quot;, &quot;m&quot;, &quot;y&quot;, &quot;h&quot;, &quot;v&quot;, &quot;a&quot;, &quot;e&quot;]的形式保存的。因此，我们既可以获取字符串的长度，也可以获取指定索引index位置的单个字符。这很像数组中的操作。 内置对象 String 的常见方法charAt()charAt：返回字符串指定位置的字符。不会修改原字符串。 语法： 1字符 = str.charAt(index); 解释：字符串中第一个字符的下标是 0。如果参数 index 不在 [0, string.length) 之间，该方法将返回一个空字符串。 而且，这里的 str.charAt(index)和str[index]的效果是一样的。 代码举例： 12345var str = new String(\"smyhvae\"); for (var i = 0; i &lt; str.length; i++) &#123; console.log(str.charAt(i)); &#125; 上面这个例子一般不用。一般打印数组和json的时候用索引，打印String不建议用索引。 charCodeAt()charCodeAt：返回字符串指定位置的字符的 Unicode 编码。不会修改原字符串。 语法： 1字符 = str.charCodeAt(index); 代码举例：打印字符串的占位长度 提示：一个英文占一个位置，一个中文占两个位置。 思路：判断该字符是否在0-127之间（在的话是英文，不在是非英文）。 代码实现： 1234567891011121314151617181920212223242526&lt;script&gt; // sort(); 底层用到了charCodeAt(); var str = \"I love my country!我你爱中国！\"; //需求：求一个字符串占有几个字符位。 //思路；如果是英文，站一个字符位，如果不是英文占两个字符位。 //技术点：判断该字符是否在0-127之间。（在的话是英文，不在是非英文） alert(getZFWlength(str)); alert(str.length); //定义方法：字符位 function getZFWlength(string) &#123; //定义一个计数器 var count = 0; for (var i = 0; i &lt; string.length; i++) &#123; //对每一位字符串进行判断，如果Unicode编码在0-127，计数器+1；否则+2 if (string.charCodeAt(i) &lt; 128 &amp;&amp; string.charCodeAt(i) &gt;= 0) &#123; count++; &#125; else &#123; count += 2; &#125; &#125; return count; &#125;&lt;/script&gt; 打印结果： 123024 从打印结果可以看出：字符串的长度是24，但是却占了30个字符位（一个中文占两个字符位）。 另外，sort()方法其实底层也是用到了charCodeAt()，因为用到了Unicode编码。 String.fromCharCode()String.fromCharCode()：根据字符的 Unicode 编码获取字符。 代码举例： 12345var result1 = String.fromCharCode(72);var result2 = String.fromCharCode(20013);console.log(result1); // 打印结果：Hconsole.log(result2); // 打印结果：中 indexOf()/lastIndexOf()indexOf()/lastIndexOf()：获取指定字符的索引。 语法： 1索引值 = str.indexOf(想要查询的字符); 解释：indexOf() 是从前向后索引字符串的位置。同理，lastIndexOf()是从后向前寻找。 作用：可以检索一个字符串中是否含有指定内容。如果字符串中含有该内容，则会返回其第一次出现的索引；如果没有找到指定的内容，则返回 -1。 因此可以得出一个技巧：如果获取的索引值为0，说明字符串是以查询的参数为开头的。 这个方法还可以指定第二个参数，用来 指定开始查找的位置。 代码举例1： 12345678var str = \"abcdea\";//给字符查索引(索引值为0,说明字符串以查询的参数为开头)console.log(str.indexOf(\"c\"));console.log(str.lastIndexOf(\"c\"));console.log(str.indexOf(\"a\"));console.log(str.lastIndexOf(\"a\")); 代码举例2：（两个参数时，需要特别注意） 1234var str = 'qianguyihao';result = str.indexOf('a', 3); // 从第三个位置开始查找 'a'这个字符 【重要】console.log(result); // 打印结果：9 上方代码中，indexOf()方法中携带了两个参数，具体解释请看注释。 concat()concat()：字符串的连接。 语法： 1新字符串 = str1.concat(str2)； //链接两个字符串 这种方法基本不用，直接把两个字符串相加就好。 是的，你会发现，数组中也有concat()方法，用于数组的连接。这个方法在数组中用得挺多的。 代码举例： 12345var str1 = 'qiangu';var str2 = 'yihao';var result = str1.concat(str2);console.log(result); // 打印结果：qianguyihao slice()slice()：从字符串中截取指定的内容。不会修改原字符串，而是将及截取到的内容返回。 语法： 1字符串 = str.slice(开始索引, 结束索引); //两个参数都是索引值。包左不包右。 解释：上面的参数，包左不包右。参数举例如下： (2, 5) 截取时，包左不包右。 (2) 表示从指定的索引位置开始，截取到最后。 (-3) 表示从倒数第几个开始，截取到最后。 (1, -1) 表示从第一个截取到倒数第一个。 (5, 2) 表示前面的大，后面的小，返回值为空。 substring()substring()：从字符串中截取指定的内容。和slice()类似。 语法： 1字符串 = str.substring(开始索引, 结束索引); //两个参数都是索引值。包左不包右。 substring()和slice()是类似的。但不同之处在于： substring()不能接受负值作为参数。如果传递了一个负值，则默认使用0。 substring()还会自动调整参数的位置，如果第二个参数小于第一个，则自动交换。比如说， substring(1, 0)截取的是第一个字符。 substr()substr()：从字符串中截取指定的内容。不会修改原字符串，而是将及截取到的内容返回。 语法： 1字符串 = str.substr(开始索引, 截取的长度); 参数举例： (2,4)：从索引值为2的字符开始，截取4个字符。 (1)：从指定位置开始，截取到最后。 (-3)：从倒数第几个开始，剪到最后. 不包括前大后小的情况。 备注：ECMAscript 没有对 substr() 方法进行标准化，因此不建议使用它。 split() 【重要】split()：将一个字符串拆分成一个数组。 语法： 1数组 = str.split(); 备注：split()这个方法在实际开发中用得非常多。一般来说，从接口拿到的json数据中，经常会收到类似于&quot;q, i, a, n&quot;这样的字符串，前端需要将这个字符串拆分成[&#39;q&#39;, &#39;i&#39;, &#39;a&#39;, &#39;n&#39;]数组，这个时候split()方法就排上用场了。 代码举例1： 12345var str = \"qian, gu, yi, hao\"; // 用逗号隔开的字符串var array = str.split(\",\"); // 将字符串 str 拆分成数组，通过逗号来拆分console.log(array); // 打印结果是数组：[\"qian\", \" gu\", \" yi\", \" hao\"] 代码举例2： 123456789101112//split()方法：字符串变数组var str3 = \"生命壹号|许嵩|smyhvae\";console.log(str3);console.log(str3.split()); // 无参数，表示：把字符串作为一个元素添加到数组中。console.log(str3.split(\"\")); //参数为空字符串，则表示：分隔字符串中每一个字符，分别添加到数组中console.log(str3.split(\"|\")); //参数为指定字符，表示：此字符将不会出现在数组的任意一个元素中console.log(str3.split(\"许\")); //同理 trim()trim()：去除字符串前后的空白。 代码举例： 1234//去除前后的空格，trim();var str1 = \" a b c \";console.log(str1);console.log(str1.trim()); replace()replace()：将字符串中的指定内容，替换为新的内容并返回。不会修改原字符串。 语法： 1新的字符串 = str.replace(被替换的内容，新的内容); 代码举例： 12345//replace()方法：替换var str2 = \"Today is fine day,today is fine day !!!\"console.log(str2);console.log(str2.replace(\"today\",\"tomorrow\")); //只能替换第一个todayconsole.log(str2.replace(/today/gi,\"tomorrow\")); //这里用到了正则，才能替换所有的today 大小写转换举例： 1234567var str = \"abcdEFG\";//转换成小写console.log(str.toLowerCase());//转换成大写console.log(str.toUpperCase()); html方法 anchor() 创建a链接 big() sub() sup() link() bold() 注意，str.link() 返回值是字符串。 举例： 12345678var str = \"你好\";console.log(str.anchor())console.log(str.big())console.log(str.sub())console.log(str.sup())console.log(str.link(\"http://www.baidu.com\"));console.log(str.bold()) 字符串练习练习1：”smyhvaevaesmyh”查找字符串中所有m出现的位置。 代码实现： 12345678var str2 = \"abcoefoxyozzopp\";for(var i=0;i&lt;str2.length;i++)&#123; //如果指定位置的符号=== \"o\" //str2[i] if( str2.charAt(i)===\"o\")&#123; console.log(i); &#125;&#125; 练习2：判断一个字符串中出现次数最多的字符，统计这个次数 12345678910111213141516171819202122232425262728293031323334353637&lt;script&gt; var str2 = \"smyhvaevaesmyhvae\"; //定义一个json，然后判断json中是够有该属性，如果有该属性，那么值+1;否则创建一个该属性，并赋值为1； var json = &#123;&#125;; for (var i = 0; i &lt; str2.length; i++) &#123; //判断：如果有该属性，那么值+1;否则创建一个该属性，并赋值为1； var key = str2.charAt(i); if (json[key] === undefined) &#123; json[key] = 1; &#125; else &#123; json[key] += 1; &#125; &#125; console.log(json); console.log(\"----------------\"); //获取json中属性值最大的选项 var maxKey = \"\"; var maxValue = 0; for (var k in json) &#123; // if(maxKey == \"\")&#123; // maxKey = k; // maxValue = json[k]; // &#125;else&#123; if (json[k] &gt; maxValue) &#123; maxKey = k; maxValue = json[k]; &#125; // &#125; &#125; console.log(maxKey); console.log(maxValue);&lt;/script&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"包装类","slug":"23-包装类","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T04:00:34.000Z","comments":true,"path":"2020/04/18/23-包装类/","link":"","permalink":"http://yoursite.com/2020/04/18/23-%E5%8C%85%E8%A3%85%E7%B1%BB/","excerpt":"包装类包装类的介绍我们都知道，js中的数据类型包括以下几种。 基本数据类型：String、Number、Boolean、Null、Undefined 引用数据类型：Object JS为我们提供了三个包装类： String()：将基本数据类型字符串，转换为String对象。 Number()：将基本数据类型的数字，转换为Number对象。 Boolean()：将基本数据类型的布尔值，转换为Boolean对象。 通过上面这这三个包装类，我们可以将基本数据类型的数据转换为对象。","text":"包装类包装类的介绍我们都知道，js中的数据类型包括以下几种。 基本数据类型：String、Number、Boolean、Null、Undefined 引用数据类型：Object JS为我们提供了三个包装类： String()：将基本数据类型字符串，转换为String对象。 Number()：将基本数据类型的数字，转换为Number对象。 Boolean()：将基本数据类型的布尔值，转换为Boolean对象。 通过上面这这三个包装类，我们可以将基本数据类型的数据转换为对象。 代码举例： 1234567var num = new Number(3);var str = new String(\"hello\");var bool = new Boolean(true);console.log(typeof num); // 打印结果：object 需要注意的是：我们在实际应用中不会使用基本数据类型的对象。如果使用基本数据类型的对象，在做一些比较时可能会带来一些不可预期的结果。 比如说： 1234var boo1 = new Boolean(true);var boo2 = new Boolean(true);console.log(boo1 === boo2); // 打印结果竟然是：false 再比如说： 12345var boo3 = new Boolean(false);if (boo3) &#123; console.log('qianguyihao'); // 这行代码竟然执行了&#125; 基本数据类型不能添加属性和方法方法和属性只能添加给对象，不能添加给基本数据类型。 注意：当我们对一些基本数据类型的值去调用属性和方法时，浏览器会临时使用包装类将其转换为对象，然后在调用对象的属性和方法；调用完以后，在将其转换为基本数据类型。 代码举例： 1234567var str = 123;str = str.toString(); // 将 number 类型转换为 string 类型str.hello = \"千古壹号\"; // 添加属性console.log(typeof str); // 打印结果：stringconsole.log(str.hello); // 打印结果：undefined 再比如，String 对象的很多内置方法，也可以直接给字符串用。此时，也是临时将字符串转换为 String 对象，然后再调用内置方法。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Class的继承","slug":"23-Class的继承","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T04:00:42.000Z","comments":true,"path":"2020/04/18/23-Class的继承/","link":"","permalink":"http://yoursite.com/2020/04/18/23-Class%E7%9A%84%E7%BB%A7%E6%89%BF/","excerpt":"前言本文主要内容： 简介 Object.getPrototypeOf() super 关键字 类的 prototype 属性和proto属性 原生构造函数的继承 Mixin 模式的实现","text":"前言本文主要内容： 简介 Object.getPrototypeOf() super 关键字 类的 prototype 属性和proto属性 原生构造函数的继承 Mixin 模式的实现 简介 Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。 12345class Point &#123;&#125;class ColorPoint extends Point &#123;&#125; 上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。下面，我们在ColorPoint内部加上代码。 12345678910class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); &#x2F;&#x2F; 调用父类的constructor(x, y) this.color &#x3D; color; &#125; toString() &#123; return this.color + &#39; &#39; + super.toString(); &#x2F;&#x2F; 调用父类的toString() &#125;&#125; 上面代码中，constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。 子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。12345678class Point &#123; &#x2F;* ... *&#x2F; &#125;class ColorPoint extends Point &#123; constructor() &#123; &#125;&#125;let cp &#x3D; new ColorPoint(); &#x2F;&#x2F; ReferenceError 上面代码中，ColorPoint继承了父类Point，但是它的构造函数没有调用super方法，导致新建实例时报错。 ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。 如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。 123456789class ColorPoint extends Point &#123;&#125;&#x2F;&#x2F; 等同于class ColorPoint extends Point &#123; constructor(...args) &#123; super(...args); &#125;&#125; 另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有super方法才能调用父类实例。 1234567891011121314class Point &#123; constructor(x, y) &#123; this.x &#x3D; x; this.y &#x3D; y; &#125;&#125;class ColorPoint extends Point &#123; constructor(x, y, color) &#123; this.color &#x3D; color; &#x2F;&#x2F; ReferenceError super(x, y); this.color &#x3D; color; &#x2F;&#x2F; 正确 &#125;&#125; 上面代码中，子类的constructor方法没有调用super之前，就使用this关键字，结果报错，而放在super方法之后就是正确的。 下面是生成子类实例的代码。 1234let cp &#x3D; new ColorPoint(25, 8, &#39;green&#39;);cp instanceof ColorPoint &#x2F;&#x2F; truecp instanceof Point &#x2F;&#x2F; true 上面代码中，实例对象cp同时是ColorPoint和Point两个类的实例，这与 ES5 的行为完全一致。 最后，父类的静态方法，也会被子类继承。 12345678910class A &#123; static hello() &#123; console.log(&#39;hello world&#39;); &#125;&#125;class B extends A &#123;&#125;B.hello() &#x2F;&#x2F; hello world 上面代码中，hello()是A类的静态方法，B继承A，也继承了A的静态方法。 Object.getPrototypeOf()Object.getPrototypeOf方法可以用来从子类上获取父类。 12Object.getPrototypeOf(ColorPoint) &#x3D;&#x3D;&#x3D; Point&#x2F;&#x2F; true 因此，可以使用这个方法判断，一个类是否继承了另一个类。 super 关键字super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。 第一种情况，super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。1234567class A &#123;&#125;class B extends A &#123; constructor() &#123; super(); &#125;&#125; 上面代码中，子类B的构造函数之中的super()，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。 注意，super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B的实例，因此super()在这里相当于A.prototype.constructor.call(this)。 123456789101112class A &#123; constructor() &#123; console.log(new.target.name); &#125;&#125;class B extends A &#123; constructor() &#123; super(); &#125;&#125;new A() &#x2F;&#x2F; Anew B() &#x2F;&#x2F; B 上面代码中，new.target指向当前正在执行的函数。可以看到，在super()执行时，它指向的是子类B的构造函数，而不是父类A的构造函数。也就是说，super()内部的this指向的是B。 作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。 1234567class A &#123;&#125;class B extends A &#123; m() &#123; super(); &#x2F;&#x2F; 报错 &#125;&#125; 上面代码中，super()用在B类的m方法之中，就会造成语法错误。 第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。 1234567891011121314class A &#123; p() &#123; return 2; &#125;&#125;class B extends A &#123; constructor() &#123; super(); console.log(super.p()); &#x2F;&#x2F; 2 &#125;&#125;let b &#x3D; new B(); 上面代码中，子类B当中的super.p()，就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()。 这里需要注意，由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。 如果属性定义在父类的原型对象上，super就可以取到。 ES6 规定，在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例。 123456789101112131415161718192021class A &#123; constructor() &#123; this.x &#x3D; 1; &#125; print() &#123; console.log(this.x); &#125;&#125;class B extends A &#123; constructor() &#123; super(); this.x &#x3D; 2; &#125; m() &#123; super.print(); &#125;&#125;let b &#x3D; new B();b.m() &#x2F;&#x2F; 2 上面代码中，super.print()虽然调用的是A.prototype.print()，但是A.prototype.print()内部的this指向子类B的实例，导致输出的是2，而不是1。也就是说，实际上执行的是super.print.call(this)。 由于this指向子类实例，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性。1234567891011121314151617class A &#123; constructor() &#123; this.x &#x3D; 1; &#125;&#125;class B extends A &#123; constructor() &#123; super(); this.x &#x3D; 2; super.x &#x3D; 3; console.log(super.x); &#x2F;&#x2F; undefined console.log(this.x); &#x2F;&#x2F; 3 &#125;&#125;let b &#x3D; new B(); 上面代码中，super.x赋值为3，这时等同于对this.x赋值为3。而当读取super.x的时候，读的是A.prototype.x，所以返回undefined。 如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。123456789101112131415161718192021222324class Parent &#123; static myMethod(msg) &#123; console.log(&#39;static&#39;, msg); &#125; myMethod(msg) &#123; console.log(&#39;instance&#39;, msg); &#125;&#125;class Child extends Parent &#123; static myMethod(msg) &#123; super.myMethod(msg); &#125; myMethod(msg) &#123; super.myMethod(msg); &#125;&#125;Child.myMethod(1); &#x2F;&#x2F; static 1var child &#x3D; new Child();child.myMethod(2); &#x2F;&#x2F; instance 2 上面代码中，super在静态方法之中指向父类，在普通方法之中指向父类的原型对象。 另外，在子类的静态方法中通过super调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例。 123456789101112131415161718192021class A &#123; constructor() &#123; this.x &#x3D; 1; &#125; static print() &#123; console.log(this.x); &#125;&#125;class B extends A &#123; constructor() &#123; super(); this.x &#x3D; 2; &#125; static m() &#123; super.print(); &#125;&#125;B.x &#x3D; 3;B.m() &#x2F;&#x2F; 3 上面代码中，静态方法B.m里面，super.print指向父类的静态方法。这个方法里面的this指向的是B，而不是B的实例。 注意，使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。 12345678class A &#123;&#125;class B extends A &#123; constructor() &#123; super(); console.log(super); &#x2F;&#x2F; 报错 &#125;&#125; 上面代码中，console.log(super)当中的super，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这时，如果能清晰地表明super的数据类型，就不会报错。 12345678910class A &#123;&#125;class B extends A &#123; constructor() &#123; super(); console.log(super.valueOf() instanceof B); &#x2F;&#x2F; true &#125;&#125;let b &#x3D; new B(); 上面代码中，super.valueOf()表明super是一个对象，因此就不会报错。同时，由于super使得this指向B的实例，所以super.valueOf()返回的是一个B的实例。 最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。 1234567var obj &#x3D; &#123; toString() &#123; return &quot;MyObject: &quot; + super.toString(); &#125;&#125;;obj.toString(); &#x2F;&#x2F; MyObject: [object Object] 类的 prototype 属性和proto属性大多数浏览器的 ES5 实现之中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class 作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。 （1）子类的__proto__属性，表示构造函数的继承，总是指向父类。 （2）子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。 12345678class A &#123;&#125;class B extends A &#123;&#125;B.__proto__ &#x3D;&#x3D;&#x3D; A &#x2F;&#x2F; trueB.prototype.__proto__ &#x3D;&#x3D;&#x3D; A.prototype &#x2F;&#x2F; true 上面代码中，子类B的__proto__属性指向父类A，子类B的prototype属性的proto属性指向父类A的prototype属性。 这样的结果是因为，类的继承是按照下面的模式实现的。 12345678910111213class A &#123;&#125;class B &#123;&#125;&#x2F;&#x2F; B 的实例继承 A 的实例Object.setPrototypeOf(B.prototype, A.prototype);&#x2F;&#x2F; B 继承 A 的静态属性Object.setPrototypeOf(B, A);const b &#x3D; new B(); 这两条继承链，可以这样理解：作为一个对象，子类（B）的原型（__proto__属性）是父类（A）；作为一个构造函数，子类（B）的原型对象（prototype属性）是父类的原型对象（prototype属性）的实例。 12345B.prototype &#x3D; Object.create(A.prototype);&#x2F;&#x2F; 等同于B.prototype.__proto__ &#x3D; A.prototype; extends关键字后面可以跟多种类型的值。 12class B extends A &#123;&#125; 上面代码的A，只要是一个有prototype属性的函数，就能被B继承。由于函数都有prototype属性（除了Function.prototype函数），因此A可以是任意函数。 下面，讨论两种情况。第一种，子类继承Object类。 12345class A extends Object &#123;&#125;A.__proto__ &#x3D;&#x3D;&#x3D; Object &#x2F;&#x2F; trueA.prototype.__proto__ &#x3D;&#x3D;&#x3D; Object.prototype &#x2F;&#x2F; true 这种情况下，A其实就是构造函数Object的复制，A的实例就是Object的实例。 第二种情况，不存在任何继承。 12345class A &#123;&#125;A.__proto__ &#x3D;&#x3D;&#x3D; Function.prototype &#x2F;&#x2F; trueA.prototype.__proto__ &#x3D;&#x3D;&#x3D; Object.prototype &#x2F;&#x2F; true 这种情况下，A作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承Function.prototype。但是，A调用后返回一个空对象（即Object实例），所以A.prototype.__proto__指向构造函数（Object）的prototype属性。 实例的 proto 属性子类实例的__proto__属性的__proto__属性，指向父类实例的proto属性。也就是说，子类的原型的原型，是父类的原型。 12345var p1 &#x3D; new Point(2, 3);var p2 &#x3D; new ColorPoint(2, 3, &#39;red&#39;);p2.__proto__ &#x3D;&#x3D;&#x3D; p1.__proto__ &#x2F;&#x2F; falsep2.__proto__.__proto__ &#x3D;&#x3D;&#x3D; p1.__proto__ &#x2F;&#x2F; true 上面代码中，ColorPoint继承了Point，导致前者原型的原型是后者的原型。 因此，通过子类实例的__proto__.__proto__属性，可以修改父类实例的行为。 12345p2.__proto__.__proto__.printName &#x3D; function () &#123; console.log(&#39;Ha&#39;);&#125;;p1.printName() &#x2F;&#x2F; &quot;Ha&quot; 上面代码在ColorPoint的实例p2上向Point类添加方法，结果影响到了Point的实例p1。 原生构造函数的继承原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript 的原生构造函数大致有下面这些。 Boolean() Number() String() Array() Date() Function() RegExp() Error() Object() 以前，这些原生构造函数是无法继承的。 ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。下面是一个继承Array的例子。 123456789101112class MyArray extends Array &#123; constructor(...args) &#123; super(...args); &#125;&#125;var arr &#x3D; new MyArray();arr[0] &#x3D; 12;arr.length &#x2F;&#x2F; 1arr.length &#x3D; 0;arr[0] &#x2F;&#x2F; undefined 上面代码定义了一个MyArray类，继承了Array构造函数，因此就可以从MyArray生成数组的实例。这意味着，ES6 可以自定义原生数据结构（比如Array、String等）的子类，这是 ES5 无法做到的。 上面这个例子也说明，extends关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。 1234567891011121314151617181920212223242526272829class VersionedArray extends Array &#123; constructor() &#123; super(); this.history &#x3D; [[]]; &#125; commit() &#123; this.history.push(this.slice()); &#125; revert() &#123; this.splice(0, this.length, ...this.history[this.history.length - 1]); &#125;&#125;var x &#x3D; new VersionedArray();x.push(1);x.push(2);x &#x2F;&#x2F; [1, 2]x.history &#x2F;&#x2F; [[]]x.commit();x.history &#x2F;&#x2F; [[], [1, 2]]x.push(3);x &#x2F;&#x2F; [1, 2, 3]x.history &#x2F;&#x2F; [[], [1, 2]]x.revert();x &#x2F;&#x2F; [1, 2] 上面代码中，VersionedArray会通过commit方法，将自己的当前状态生成一个版本快照，存入history属性。revert方法用来将数组重置为最新一次保存的版本。除此之外，VersionedArray依然是一个普通数组，所有原生的数组方法都可以在它上面调用。 Mixin 模式的实现Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。它的最简单实现如下。 1234567const a &#x3D; &#123; a: &#39;a&#39;&#125;;const b &#x3D; &#123; b: &#39;b&#39;&#125;;const c &#x3D; &#123;...a, ...b&#125;; &#x2F;&#x2F; &#123;a: &#39;a&#39;, b: &#39;b&#39;&#125; 上面代码中，c对象是a对象和b对象的合成，具有两者的接口。 下面是一个更完备的实现，将多个类的接口“混入”（mix in）另一个类。 12345678910111213141516171819202122232425262728function mix(...mixins) &#123; class Mix &#123; constructor() &#123; for (let mixin of mixins) &#123; copyProperties(this, new mixin()); &#x2F;&#x2F; 拷贝实例属性 &#125; &#125; &#125; for (let mixin of mixins) &#123; copyProperties(Mix, mixin); &#x2F;&#x2F; 拷贝静态属性 copyProperties(Mix.prototype, mixin.prototype); &#x2F;&#x2F; 拷贝原型属性 &#125; return Mix;&#125;function copyProperties(target, source) &#123; for (let key of Reflect.ownKeys(source)) &#123; if ( key !&#x3D;&#x3D; &#39;constructor&#39; &amp;&amp; key !&#x3D;&#x3D; &#39;prototype&#39; &amp;&amp; key !&#x3D;&#x3D; &#39;name&#39; ) &#123; let desc &#x3D; Object.getOwnPropertyDescriptor(source, key); Object.defineProperty(target, key, desc); &#125; &#125;&#125; 上面代码的mix函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。 123class DistributedEdit extends mix(Loggable, Serializable) &#123; &#x2F;&#x2F; ...&#125; Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。 Object.defineProperty(obj, prop, descriptor) 参数 obj 要定义属性的对象。 prop 要定义或修改的属性的名称或 Symbol 。 descriptor 要定义或修改的属性描述符。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"正则表达式","slug":"24-正则表达式","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T10:04:02.000Z","comments":true,"path":"2020/04/18/24-正则表达式/","link":"","permalink":"http://yoursite.com/2020/04/18/24-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"正则表达式简介定义：正则表达式用于定义一些字符串的规则。 作用：计算机可以根据正则表达式，来检查一个字符串是否符合指定的规则；或者将字符串中符合规则的内容提取出来。","text":"正则表达式简介定义：正则表达式用于定义一些字符串的规则。 作用：计算机可以根据正则表达式，来检查一个字符串是否符合指定的规则；或者将字符串中符合规则的内容提取出来。 如果你想查看正则更多的内容，可以查阅官方文档关于 RegExp 这个内置对象的用法。 创建正则表达式的对象方式一：使用构造函数创建正则表达式的对象语法： 123var 变量 = new RegExp(\"正则表达式\"); // 注意，参数是字符串var 变量 = new RegExp(\"正则表达式\", \"匹配模式\"); // 注意，两个参数都是字符串 备注：RegExp的意思是 Regular expression。使用typeof检查正则对象，会返回object。 上面的语法中，既可以传一个参数，也可以传两个参数。 创建了正则表达式的对象后，该怎么使用呢？大致分为两个步骤： （1）创建正则表达式的对象 reg。 （2）使用 reg 的test() 方法，判断指定字符串是否符合规则。 正则表达式的test()方法：【重要】 1myReg.test(str); // 判断字符串 str 是否符合 指定的 myReg 这个正则表达式的规则 解释：使用test()这个方法可以用来检查一个字符串是否符合正则表达式的规则，如果符合则返回true，否则返回false。 我们来看看下面的例子。 1、传一个参数时： 构造函数 RegExp 中，可以只传一个参数。 代码举例： 12345678var reg = new RegExp(\"a\"); // 定义一个正则表达式：检查一个字符串中是否含有 avar str1 = \"qianguyihao\";var str2 = \"smyh\";// 通过 test()方法，判断字符串是否符合 上面定义的 reg 规则console.log(reg.test(str1)); // 打印结果：trueconsole.log(reg.test(str2)); // 打印结果：false 注意，上面的例子中，我们是先定义了一个正则表达式的规则，然后通过正则表达式的test()方法来判断字符串是否符合之前定义的规则。 2、传两个参数时：匹配模式 【重要】 构造函数 RegExp 中，也可以传两个参数。我们可以传递一个匹配模式作为第二个参数。这个参数可以是： i 忽略大小写。这里的 i 指的是 ignore。 g 全局匹配模式。这里的 g 指的是 global。 代码举例： 1234var reg = new RegExp('A', 'i');var str = 'qiangu';console.log(reg.test(str)); // 打印结果：true 方式二：使用字面量创建正则表达式我们可以使用字面量来创建正则表达式。 语法： 123var 变量 = /正则表达式/; // 注意，这个语法里没有引号var 变量 = /正则表达式/匹配模式; // 注意，这个语法里没有引号 代码举例： 12345var reg = /A/i; // 定义正则表达式的规则：检查一个字符串中是否含有 a。忽略大小写。var str = \"qiangu\";console.log(typeof reg); // 打印结果：objectconsole.log(reg.test(str)); // 打印结果：true 以上两种方式的对比 方式一：使用构造函数创建时，更加灵活，因为参数中还可以传递变量。 方式二：使用字面量的方式创建，更加简单。 代码举例： 123var reg = new RegExp(\"a\", \"i\"); // 方式一var reg = /a/i; // 方式二 上面这两行代码的作用是等价的。 避坑指南：全局匹配 g 慎用test()方法对于非全局匹配的正则表达式，test()只会检测是否存在某个目标字符串（只要存在就为 true），多次检测的结果都相同。例如： 123456const reg = /test/;const str = '_test_test';reg.test(str) // truereg.test(str) // truereg.test(str) // true 重点来了。 当设置全局标志 /g 时，一旦字符串中还存在匹配，test() 方法都将返回 true，同时匹配成功后将把 lastIndex 属性的值设置为上次匹配成功结果之后的第一个字符所在的位置，下次匹配将从 lastIndex 指示的位置开始；匹配不成功时返回 false，同时将 lastIndex 属性的值重置为 0。 举例：（很重要的例子，看仔细） 1234567891011const reg = /test/g;const str = '_test_test';console.log(reg.test(str)); // trueconsole.log(reg.lastIndex); // 5console.log(reg.test(str)); // trueconsole.log(reg.lastIndex); // 10console.log(reg.test(str)); // falseconsole.log(reg.lastIndex); // 0 总结： 全局匹配模式g一般用于 exec()、match()、replace()等方法。 全局匹配模式g如果用于test()方法会有问题。因为g模式会生成一个lastindex参数来存储匹配最后一次的位置。 正则表达式的简单语法检查一个字符串中是否包含 a或b写法1： 1var reg = /a|b/; 解释：使用 | 表示或的意思。 写法2： 1var reg = /[ab]/; // 跟上面的那行语法，是等价的 解释：这里的[]也是表示或的意思。 []这个符号在正则还是比较常用的。我们接下来看几个例子。 []表示：或一些规则： /[ab]/ 等价于 /a|b/：检查一个字符串中是否包含 a或b /[a-z]/：检查一个字符串那种是否包含任意小写字母 /[A-Z]/：任意大写字母 /[A-z]/：任意字母 /[0-9]/：任意数字 /a[bde]c/：检查一个字符串中是否包含 abc 或 adc 或 aec [^ ] 表示：除了举例1： 1234var reg = /[^ab]/; // 规则：字符串中，除了a、b之外，还有没有其他的字符内容？var str = \"acb\";console.log(reg.test(str)); // 打印结果：true 举例2：（可以用来验证某字符串是否为 纯数字） 123456var reg = /[^0-9]/; // 规则：字符串中，除了数字之外，还有没有其他的内容？var str1 = \"1991\";var str2 = \"199a1\";console.log(reg.test(str1)); // 打印结果：false （如果字符串是 纯数字，则返回 false）console.log(reg.test(str2)); // 打印结果：true 支持正则表达式的 String 对象的方法 String对象的如下方法，是支持正则表达式的： 方法 描述 备注 split() 将字符串拆分成数组 search() 搜索字符串中是否含有指定内容，返回索引 index match() 根据正则表达式，从一个字符串中将符合条件的内容提取出来 replace() 将字符串中的指定内容，替换为新的内容并返回 下面来分别介绍和举例。 split()split()：将一个字符串拆分成一个数组。可以接受一个正则表达式作为参数。 备注：关于split()更详细的用法，可以看之前的关于《内置对象：String》这篇文章。 正则相关的举例：根据任意字母，将字符串拆分成数组。 代码实现：（通过正则） 1234var str = \"1a2b3c4d5e6f7g\";var result = str.split(/[A-z]/); // 参数是一个正则表达式：表示所有字母console.log(result); 打印结果： 1[\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"\"] search()search()：搜索字符串中是否含有指定内容。如果搜索到指定内容，则会返回第一次出现的索引；否则返回-1。 search()方法可以接受一个正则表达式作为参数，然后会根据正则表达式去检索字符串。serach()只会查找第一个，即使设置全局匹配也没用。 举例： 123456var str = \"hello abc hello aec afc\";/** 搜索字符串中是否含有abc 或 aec 或 afc*/result = str.search(/a[bef]c/);console.log(result); // 打印结果：6 match()match()：根据正则表达式，从一个字符串中将符合条件的内容提取出来，封装到一个数组中返回（即使只查询到一个结果）。 注意：默认情况下，match()方法只会找到第一个符合要求的内容，找到以后就停止检索。我们可以设置正则表达式为全局匹配模式，这样就会匹配到所有的内容，并以数组的形式返回。 另外，我们可以为一个正则表达式设置多个匹配模式，且匹配模式的顺序无所谓。 代码举例： 123456789var str = \"1a2a3a4a5e6f7A8B9C\";var result1 = str.match(/[a-z]/); // 找到符合要求的第一个内容，然后返回var result2 = str.match(/[a-z]/g); // 设置为“全局匹配”模式，匹配字符串中 所有的小写字母var result3 = str.match(/[a-z]/gi); // 设置多个匹配模式，匹配字符串中 所有的字母（忽略大小写）console.log(result1); // 打印结果：[\"a\"]console.log(result2); // 打印结果：[\"a\", \"a\", \"a\", \"a\", \"e\", \"f\"]console.log(result3); // 打印结果：[\"a\", \"a\", \"a\", \"a\", \"e\", \"f\", \"A\", \"B\", \"C\"] 总结： match()这个方法还是很实用的，可以在一个很长的字符串中，提取出有规则的内容。 replace()replace()：将字符串中的指定内容，替换为新的内容并返回。不会修改原字符串。 语法： 1新的字符串 = str.replace(被替换的内容，新的内容); 参数解释： 被替换的内容：可以接受一个正则表达式作为参数。 新的内容：默认只会替换第一个。如果需要替换全部符合条件的内容，可以设置正则表达式为全局匹配模式。 代码举例： 123456//replace()方法：替换var str2 = \"Today is fine day,today is fine day !!!\"console.log(str2);console.log(str2.replace(\"today\",\"tomorrow\")); //只能替换第一个todayconsole.log(str2.replace(/today/gi,\"tomorrow\")); //这里用到了正则，且为“全局匹配”模式，才能替换所有的today 常见正则表达式举例检查一个字符串是否是一个合法手机号手机号的规则： 以1开头 第二位是3~9之间任意数字 三位以后任意9位数字 正则实现： 12345var phoneStr = \"13067890123\";var phoneReg = /^1[3-9][0-9]&#123;9&#125;$/;console.log(phoneReg.test(phoneStr)); 备注：如果在正则表达式中同时使用^和$符号，则要求字符串必须完全符合正则表达式。 去掉字符串开头和结尾的空格正则实现： 1str = str.replace(/^\\s*|\\s*$/g,\"\"); 解释如下： 123str = str.replace(/^\\s*/, \"\"); //去除开头的空格str = str.replace(/\\s*$/, \"\"); //去除结尾的空格 判断字符串是否为电子邮件正则实现： 12345var emailReg = /^\\w&#123;3,&#125;(\\.\\w+)*@[A-z0-9]+(\\.[A-z]&#123;2,5&#125;)&#123;1,2&#125;$/;var email = \"abchello@163.com\";console.log(emailReg.test(email));","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"事件简介","slug":"25-事件简介","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T10:03:54.000Z","comments":true,"path":"2020/04/18/25-事件简介/","link":"","permalink":"http://yoursite.com/2020/04/18/25-%E4%BA%8B%E4%BB%B6%E7%AE%80%E4%BB%8B/","excerpt":"事件简介事件：就是文档或浏览器窗口中发生的一些特定的交互瞬间。对于 Web 应用来说，有下面这些代表性的事件：点击某个元素、将鼠标移动至某个元素上方、关闭弹窗等等。 JavaScript 是以事件驱动为核心的一门语言。JavaScript 与 HTML 之间的交互是通过事件实现的。","text":"事件简介事件：就是文档或浏览器窗口中发生的一些特定的交互瞬间。对于 Web 应用来说，有下面这些代表性的事件：点击某个元素、将鼠标移动至某个元素上方、关闭弹窗等等。 JavaScript 是以事件驱动为核心的一门语言。JavaScript 与 HTML 之间的交互是通过事件实现的。 事件的三要素事件的三要素：事件源、事件、事件驱动程序。 比如，我用手去按开关，灯亮了。这件事情里，事件源是：手。事件是：按开关。事件驱动程序是：灯开了或者关了。 再比如，网页上弹出一个广告，我点击右上角的X，广告就关闭了。这件事情里，事件源是：X。事件是：onclick。事件驱动程序是：广告关闭了。 于是我们可以总结出：谁引发的后续事件，谁就是事件源。 总结如下： 事件源：引发后续事件的html标签。 事件：js已经定义好了（见下图）。 事件驱动程序：对样式和html的操作。也就是DOM。 也就是说，我们可以在时间对应的属性中写一些js代码，当事件被触发时，这些代码将会执行。 代码书写步骤如下：（重要） （1）获取事件源：document.getElementById(“box”); // 类似于Android里面的findViewById （2）绑定事件： 事件源box.事件onclick = function(){ 事件驱动程序 }; （3）书写事件驱动程序：关于DOM的操作。 最简单的代码举例：（点击box1，然后弹框） 1234567891011121314&lt;body&gt;&lt;div id=\"box1\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; // 1、获取事件源 var div = document.getElementById(\"box1\"); // 2、绑定事件 div.onclick = function () &#123; // 3、书写事件驱动程序 alert(\"我是弹出的内容\"); &#125;&lt;/script&gt;&lt;/body&gt; 常见的事件如下： 事件 触发 onabort 图像加载被中断 onblur 元素失去焦点 onchange 用户改变域的内容 onclick 鼠标点击某个对象 ondblclick 鼠标双击某个对象 onerror 当加载文档或图像时发生某个错误 onfocus 元素获得焦点 onkeydown 某个键盘的键被按下 onkeypress 某个键盘的键被按下或按住 onkeyup 某个键盘的键被松开 onload 某个页面或图像被完成加载 onmousedown 某个鼠标按键被按下 onmousemove 鼠标被移动 onmouseout 鼠标从某元素移开 onmouseover 鼠标被移到某元素之上 onmouseup 某个鼠标按键被松开 onreset 重置按钮被点击 onresize 窗口或框架被调整尺寸 onselect 文本被选定 onsubmit 提交按钮被点击 onunload 用户退出页面 下面针对这事件的三要素，进行分别介绍。 1、获取事件源的方式（DOM节点的获取）获取事件源的常见方式如下： 12345var div1 = document.getElementById(\"box1\"); //方式一：通过id获取单个标签var arr1 = document.getElementsByTagName(\"div\"); //方式二：通过 标签名 获得 标签数组，所以有svar arr2 = document.getElementsByClassName(\"hehe\"); //方式三：通过 类名 获得 标签数组，所以有s 2、绑定事件的方式方式一：直接绑定匿名函数 123456789&lt;div id=\"box1\" &gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var div1 = document.getElementById(\"box1\"); //绑定事件的第一种方式 div1.onclick = function () &#123; alert(\"我是弹出的内容\"); &#125;&lt;/script&gt; 方式二：先单独定义函数，再绑定 1234567891011 &lt;div id=\"box1\" &gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var div1 = document.getElementById(\"box1\"); //绑定事件的第二种方式 div1.onclick = fn; //注意，这里是fn，不是fn()。fn()指的是返回值。 //单独定义函数 function fn() &#123; alert(\"我是弹出的内容\"); &#125;&lt;/script&gt; 注意上方代码的注释。绑定的时候，是写fn，不是写fn()。fn代表的是整个函数，而fn()代表的是返回值。 方式三：行内绑定 12345678910&lt;!--行内绑定--&gt;&lt;div id=\"box1\" onclick=\"fn()\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; function fn() &#123; alert(\"我是弹出的内容\"); &#125;&lt;/script&gt; 注意第一行代码，绑定时，是写的&quot;fn()&quot;，不是写的&quot;fn&quot;。因为绑定的这段代码不是写在js代码里的，而是被识别成了字符串。 3、事件驱动程序我们在上面是拿alert举例，不仅如此，我们还可以操作标签的属性和样式。举例如下： 点击鼠标时，原本粉色的div变大了，背景变红： 1234567891011121314151617181920212223 &lt;style&gt; #box1 &#123; width: 100px; height: 100px; background-color: pink; cursor: pointer; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"box1\" &gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var div1 = document.getElementById(\"box1\"); //点击鼠标时，原本粉色的div变大了，背景变红了 div1.onclick = function () &#123; div1.style.width = \"200px\"; //属性值要写引号 div1.style.height = \"200px\"; div1.style.backgroundColor = \"red\"; //属性名是backgroundColor，不是background-color &#125;&lt;/script&gt; 上方代码的注意事项： 在js里写属性值时，要用引号 在js里写属性名时，是backgroundColor，不是CSS里面的background-color。 onload事件 onload事件比较特殊，这里单独讲一下。 当页面加载（文本和图片）完毕的时候，触发onload事件。 举例： 12345&lt;script type=\"text/javascript\"&gt; window.onload = function () &#123; console.log(\"smyhvae\"); //等页面加载完毕时，打印字符串 &#125;&lt;/script&gt; 有一点我们要知道：js的加载是和html同步加载的。因此，如果使用元素在定义元素之前，容易报错。这个时候，onload事件就能派上用场了，我们可以把使用元素的代码放在onload里，就能保证这段代码是最后执行。 建议是：整个页面上所有元素加载完毕再执行js内容。所以，window.onload可以预防使用标签在定义标签之前。 事件举例：京东顶部广告栏当鼠标点击右上角的X时，关掉整个广告栏，这就要用到事件。 代码实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; * &#123; padding: 0; margin: 0; &#125; .top-banner &#123; background-color: pink; height: 80px; &#125; .w &#123; width: 1210px; margin: 10px auto; position: relative; &#125; img &#123; display: block; width: 1210px; height: 80px; background-color: blue; &#125; a &#123; position: absolute; top: 5px; right: 5px; color: #fff; background-color: #000; text-decoration: none; width: 20px; height: 20px; font: 700 14px/20px \"simsum\"; text-align: center; &#125; .hide &#123; display: none!important; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"top-banner\" id=\"topBanner\"&gt; &lt;div class=\"w\"&gt; &lt;img src=\"\" alt=\"\"/&gt; &lt;a href=\"#\" id=\"closeBanner\"&gt;×&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;script&gt; //需求：点击案例，隐藏盒子。 //思路：点击a链接，让top-banner这个盒子隐藏起来（加隐藏类名）。 //1.获取事件源和相关元素 var closeBanner = document.getElementById(\"closeBanner\"); var topBanner = document.getElementById(\"topBanner\"); //2.绑定事件 closeBanner.onclick = function () &#123; //3.书写事件驱动程序 //类控制// topBanner.className += \" hide\"; //保留原类名，添加新类名 topBanner.className = \"hide\";//替换旧类名（方式一）// topBanner.style.display = \"none\"; //方式二：与上一行代码的效果相同 &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注意最后一行代码，这种方式会替换旧类名，意思是，不管之前的类名叫什么，都会被修改。 事件举例：要求实现效果：当鼠标悬停在img上时，更换为另外一张图片；鼠标离开时，还原为本来的图片。 代码实现： 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; //window.onload页面加载完毕以后再执行此代码 window.onload = function () &#123; //需求：鼠标放到img上，更换为另一张图片，也就是修改路径（src的值）。 //步骤： //1.获取事件源 //2.绑定事件 //3.书写事件驱动程序 //1.获取事件源 var img = document.getElementById(\"box\"); //2.绑定事件(悬停事件：鼠标进入到事件源中，立即触发事件) img.onmouseover = function () &#123; //3.书写事件驱动程序(修改src) img.src = \"image/jd2.png\";// this.src = \"image/jd2.png\"; &#125; //2.绑定事件(悬停事件：鼠标进入到事件源中，立即触发事件) img.onmouseout = function () &#123; //3.书写事件驱动程序(修改src) img.src = \"image/jd1.png\"; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;img id=\"box\" src=\"image/jd1.png\" style=\"cursor: pointer;border: 1px solid #ccc;\"/&gt;&lt;/html&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"DOM简介和DOM操作","slug":"26-DOM简介和DOM操作","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T10:05:26.000Z","comments":true,"path":"2020/04/18/26-DOM简介和DOM操作/","link":"","permalink":"http://yoursite.com/2020/04/18/26-DOM%E7%AE%80%E4%BB%8B%E5%92%8CDOM%E6%93%8D%E4%BD%9C/","excerpt":"常见概念JavaScript的组成JavaScript基础分为三个部分： ECMAScript：JavaScript的语法标准。包括变量、表达式、运算符、函数、if语句、for语句等。 DOM：文档对象模型（Document object Model），操作网页上的元素的API。比如让盒子移动、变色、轮播图等。 BOM：浏览器对象模型（Browser Object Model），操作浏览器部分功能的API。比如让浏览器自动滚动。","text":"常见概念JavaScript的组成JavaScript基础分为三个部分： ECMAScript：JavaScript的语法标准。包括变量、表达式、运算符、函数、if语句、for语句等。 DOM：文档对象模型（Document object Model），操作网页上的元素的API。比如让盒子移动、变色、轮播图等。 BOM：浏览器对象模型（Browser Object Model），操作浏览器部分功能的API。比如让浏览器自动滚动。 节点 节点（Node）：构成 HTML 网页的最基本单元。网页中的每一个部分都可以称为是一个节点，比如：html标签、属性、文本、注释、整个文档等都是一个节点。 虽然都是节点，但是实际上他们的具体类型是不同的。常见节点分为四类： 文档节点（文档）：整个 HTML 文档。整个 HTML 文档就是一个文档节点。 元素节点（标签）：HTML标签。 属性节点（属性）：元素的属性。 文本节点（文本）：HTML标签中的文本内容（包括标签之间的空格、换行）。 节点的类型不同，属性和方法也都不尽相同。所有的节点都是Object。 什么是DOMDOM：Document Object Model，文档对象模型。DOM 为文档提供了结构化表示，并定义了如何通过脚本来访问文档结构。目的其实就是为了能让js操作html元素而制定的一个规范。 DOM就是由节点组成的。 解析过程：HTML加载完毕，渲染引擎会在内存中把HTML文档，生成一个DOM树，getElementById是获取内中DOM上的元素节点。然后操作的时候修改的是该元素的属性。 DOM树：（一切都是节点） DOM的数据结构如下： 上图可知，在HTML当中，一切都是节点（非常重要）。节点的分类，在上一段中，已经讲了。 整个html文档就是一个文档节点。所有的节点都是Object。 DOM可以做什么 找对象（元素节点） 设置元素的属性值 设置元素的样式 动态创建和删除元素 事件的触发响应：事件源、事件、事件的驱动程序 元素节点的获取DOM节点的获取方式其实就是获取事件源的方式。关于事件，上一篇文章中已经讲到了。 想要操作元素节点，必须首先要找到该节点。有三种方式可以获取DOM节点： 12345var div1 = document.getElementById(\"box1\"); //方式一：通过 id 获取 一个 元素节点（为什么是一个呢？因为 id 是唯一的）var arr1 = document.getElementsByTagName(\"div\"); //方式二：通过 标签名 获取 元素节点数组，所以有svar arr2 = document.getElementsByClassName(\"hehe\"); //方式三：通过 类名 获取 元素节点数组，所以有s 既然方式二、方式三获取的是标签数组，那么习惯性是先遍历之后再使用。 特殊情况：数组中的值只有1个。即便如此，这一个值也是包在数组里的。这个值的获取方式如下： 123document.getElementsByTagName(\"div1\")[0]; //取数组中的第一个元素document.getElementsByClassName(\"hehe\")[0]; //取数组中的第一个元素 DOM访问关系的获取DOM的节点并不是孤立的，因此可以通过DOM节点之间的相对关系对它们进行访问。 节点的访问关系，是以属性的方式存在的。 这里我们要重点知道parentNode和children这两个属性的用法。下面分别介绍。 获取父节点调用者就是节点。一个节点只有一个父节点，调用方式就是 1节点.parentNode 获取兄弟节点1、下一个节点 | 下一个元素节点： Sibling的中文是兄弟。 （1）nextSibling： 火狐、谷歌、IE9+版本：都指的是下一个节点（包括标签、空文档和换行节点）。 IE678版本：指下一个元素节点（标签）。 （2）nextElementSibling： 火狐、谷歌、IE9+版本：都指的是下一个元素节点（标签）。 总结：为了获取下一个元素节点，我们可以这样做：在IE678中用nextSibling，在火狐谷歌IE9+以后用nextElementSibling，于是，综合这两个属性，可以这样写： 1下一个兄弟节点 = 节点.nextElementSibling || 节点.nextSibling 2、前一个节点 | 前一个元素节点： previous的中文是：前一个。 （1）previousSibling： 火狐、谷歌、IE9+版本：都指的是前一个节点（包括标签、空文档和换行节点）。 IE678版本：指前一个元素节点（标签）。 （2）previousElementSibling： 火狐、谷歌、IE9+版本：都指的是前一个元素节点（标签）。 总结：为了获取前一个元素节点，我们可以这样做：在IE678中用previousSibling，在火狐谷歌IE9+以后用previousElementSibling，于是，综合这两个属性，可以这样写： 1前一个兄弟节点 = 节点.previousElementSibling || 节点.previousSibling 3、补充：获得任意一个兄弟节点： 1节点自己.parentNode.children[index]; //随意得到兄弟节点 获取单个的子节点1、第一个子节点 | 第一个子元素节点： （1）firstChild： 火狐、谷歌、IE9+版本：都指的是第一个子节点（包括标签、空文档和换行节点）。 IE678版本：指第一个子元素节点（标签）。 （2）firstElementChild： 火狐、谷歌、IE9+版本：都指的是第一个子元素节点（标签）。 总结：为了获取第一个子元素节点，我们可以这样做：在IE678中用firstChild，在火狐谷歌IE9+以后用firstElementChild，于是，综合这两个属性，可以这样写： 1第一个子元素节点 = 节点.firstElementChild || 节点.firstChild 2、最后一个子节点 | 最后一个子元素节点： （1）lastChild： 火狐、谷歌、IE9+版本：都指的是最后一个子节点（包括标签、空文档和换行节点）。 IE678版本：指最后一个子元素节点（标签）。 （2）lastElementChild： 火狐、谷歌、IE9+版本：都指的是最后一个子元素节点（标签）。 总结：为了获取最后一个子元素节点，我们可以这样做：在IE678中用lastChild，在火狐谷歌IE9+以后用lastElementChild，于是，综合这两个属性，可以这样写： 1最后一个子元素节点 = 节点.lastElementChild || 节点.lastChild 获取所有的子节点（1）childNodes：标准属性。返回的是指定元素的子节点的集合（包括元素节点、所有属性、文本节点）。是W3C的亲儿子。 火狐 谷歌等高本版会把换行也看做是子节点。 用法： 1子节点数组 = 父节点.childNodes; //获取所有节点。 （2）children：非标准属性。返回的是指定元素的子元素节点的集合。【重要】 它只返回HTML节点，甚至不返回文本节点。 在IE6/7/8中包含注释节点（在IE678中，注释节点不要写在里面）。 虽然不是标准的DOM属性，但它和innerHTML方法一样，得到了几乎所有浏览器的支持。 用法：（用的最多） 1子节点数组 = 父节点.children; //获取所有节点。用的最多。 DOM节点的操作（重要）上一段的内容：节点的访问关系都是属性。 本段的内容：节点的操作都是函数（方法）。 创建节点 createElement格式如下： 1新的标签(元素节点) = document.createElement(\"标签名\"); 比如，如果我们想创建一个li标签，或者是创建一个不存在的adbc标签，可以这样做： 12345678910&lt;script type=\"text/javascript\"&gt; var a1 = document.createElement(\"li\"); //创建一个li标签 var a2 = document.createElement(\"adbc\"); //创建一个不存在的标签 console.log(a1); console.log(a2); console.log(typeof a1); console.log(typeof a2);&lt;/script&gt; 插入节点 appendChild插入节点有两种方式，它们的含义是不同的。 方式1： 1父节点.appendChild(新的子节点); 解释：父节点的最后插入一个新的子节点。 方式2： 1父节点.insertBefore(新的子节点,作为参考的子节点) 特别强调： 关于方式1的appendChild方法，这里要强调一下。比如，现在有下面这样一个div结构： 12345678&lt;div class=\"box11\"&gt; &lt;div class=\"box12\"&gt;生命壹号&lt;/div&gt;&lt;/div&gt;&lt;div class=\"box21\"&gt; &lt;div class=\"box22\"&gt;永不止步&lt;/div&gt;&lt;/div&gt; 上方结构中，子盒子box12是在父亲box11里的，子盒子box22是在父亲box21里面的。现在，如果我调用方法box11.appendChild(box22)，最后产生的结果是：box22会跑到box11中（也就是说，box22不在box21里面了）。这是一个很神奇的事情： 删除节点 removeChild格式如下： 1父节点.removeChild(子节点); 解释：用父节点删除子节点。必须要指定是删除哪个子节点。 如果我想删除自己这个节点，可以这么做： 1node1.parentNode.removeChild(node1); 复制节点（克隆节点）格式如下： 123要复制的节点.cloneNode(); //括号里不带参数和带参数false，效果是一样的。要复制的节点.cloneNode(true); 括号里带不带参数，效果是不同的。解释如下： 不带参数/带参数false：只复制节点本身，不复制子节点。 带参数true：既复制节点本身，也复制其所有的子节点。 设置节点的属性我们可以获取节点的属性值、设置节点的属性值、删除节点的属性。 我们就统一拿下面这个标签来举例： 1&lt;img src=\"images/1.jpg\" class=\"image-box\" title=\"美女图片\" alt=\"地铁一瞥\" id=\"a1\"&gt; 下面分别介绍。 1、获取节点的属性值方式1： 12元素节点.属性名;元素节点[属性名]; 举例：（获取节点的属性值） 1234567891011121314151617&lt;body&gt;&lt;img src=\"images/1.jpg\" class=\"image-box\" title=\"美女图片\" alt=\"地铁一瞥\" id=\"a1\"&gt;&lt;script type=\"text/javascript\"&gt; var myNode = document.getElementsByTagName(\"img\")[0]; console.log(myNode.src); console.log(myNode.className); //注意，是className，不是class console.log(myNode.title); console.log(\"------------\"); console.log(myNode[\"src\"]); console.log(myNode[\"className\"]); //注意，是className，不是class console.log(myNode[\"title\"]);&lt;/script&gt;&lt;/body&gt; 方式2： 1元素节点.getAttribute(\"属性名称\"); 举例： 123console.log(myNode.getAttribute(\"src\"));console.log(myNode.getAttribute(\"class\")); //注意是class，不是classNameconsole.log(myNode.getAttribute(\"title\")); 方式1和方式2的区别在于：前者是直接操作标签，后者是把标签作为DOM节点。推荐方式2。 2、设置节点的属性值方式1举例：（设置节点的属性值） 12myNode.src = \"images/2.jpg\" //修改src的属性值myNode.className = \"image2-box\"; //修改class的name 方式2： 1元素节点.setAttribute(\"属性名\", \"新的属性值\"); 方式2举例：（设置节点的属性值） 123myNode.setAttribute(\"src\",\"images/3.jpg\");myNode.setAttribute(\"class\",\"image3-box\");myNode.setAttribute(\"id\",\"你好\"); 3、删除节点的属性格式： 1元素节点.removeAttribute(属性名); 举例：（删除节点的属性） 12myNode.removeAttribute(\"class\");myNode.removeAttribute(\"id\"); 总结获取节点的属性值和设置节点的属性值，都有两种方式。 如果是节点的“原始属性”（比如 普通标签的class/className属性、普通标签的style属性、普通标签的 title属性、img 标签的src属性、超链接的href属性等），方式1和方式2是等价的，可以混用。怎么理解混用呢？比如说：用 div.title = &#39;我是标题&#39;设置属性，用 div.getAttribute(&#39;title&#39;)获取属性，就是混用。 但如果是节点的“非原始属性”，比如： 123div.aaa = 'qianguyihao';div.setAttribute('bbb', 'qianguyihao'); 上面的这个“非原始属性”，在使用这两种方式时，是有区别的。区别如下： 方式1 的元素节点.属性和元素节点[属性]：绑定的属性值不会出现在标签上。 方式2 的get/set/removeAttribut：绑定的属性值会出现在标签上。 这两种方式不能交换使用，get值和set值必须使用同一种方法。 举例： 123456789101112131415161718&lt;body&gt;&lt;div id=\"box\" title=\"主体\" class=\"asdfasdfadsfd\"&gt;我爱你中国&lt;/div&gt;&lt;script&gt; var div = document.getElementById(\"box\"); //采用方式一进行set div.aaaa = \"1111\"; console.log(div.aaaa); //打印结果：1111。可以打印出来，但是不会出现在标签上 //采用方式二进行set div.setAttribute(\"bbbb\",\"2222\"); //bbbb作为新增的属性，会出现在标签上 console.log(div.getAttribute(\"aaaa\")); //打印结果：null。因为方式一的set，无法采用方式二进行get。 console.log(div.bbbb); //打印结果：undefined。因为方式二的set，无法采用方式一进行get。&lt;/script&gt;&lt;/body&gt; DOM对象的属性-补充innerHTML和innerText的区别 value：标签的value属性。 innerHTML：双闭合标签里面的内容（包含标签）。 innerText：双闭合标签里面的内容（不包含标签）。（老版本的火狐用textContent） 获取内容举例： 如果我们想获取innerHTML和innerText里的内容，看看会如何：（innerHTML会获取到标签本身，而innerText则不会） 修改内容举例：（innerHTML会修改标签本身，而innerText则不会） nodeType属性这里讲一下nodeType属性。 nodeType == 1 表示的是元素节点（标签） 。记住：在这里，元素就是标签。 nodeType == 2 表示是属性节点。 nodeType == 3 是文本节点。 nodeType、nodeName、nodeValue我们那下面这个标签来举例： 123&lt;div id=\"box\" value=\"111\"&gt; 生命壹号&lt;/div&gt; 上面这个标签就包含了三种节点： 元素节点（标签）getElementById 属性节点 getAttributeNode 文本节点 firstChild 获取这三个节点的方式如下： 12345678910111213var element = document.getElementById(\"box1\"); //获取元素节点（标签）var attribute = element.getAttributeNode(\"id\"); //获取box1的属性节点var txt = element.firstChild; //获取box1的文本节点var value = element.getAttribute(\"id\"); //获取id的属性值console.log(element);console.log(\"--------------\");console.log(attribute);console.log(\"--------------\");console.log(txt);console.log(\"--------------\");console.log(value); 既然这三个都是节点，如果我想获取它们的nodeType、nodeName、nodeValue，代码如下： 12345678910111213141516171819202122var element = document.getElementById(\"box1\"); //获取元素节点（标签）var attribute = element.getAttributeNode(\"id\"); //获取box1的属性节点var txt = element.firstChild; //获取box1的文本节点//获取nodeTypeconsole.log(element.nodeType); //1console.log(attribute.nodeType); //2console.log(txt.nodeType); //3console.log(\"--------------\");//获取nodeNameconsole.log(element.nodeName); //DIVconsole.log(attribute.nodeName); //idconsole.log(txt.nodeName); //#textconsole.log(\"--------------\");//获取nodeValueconsole.log(element.nodeValue); //nullconsole.log(attribute.nodeValue); //box1console.log(txt.nodeValue); //生命壹号 文档的加载浏览器在加载一个页面时，是按照自上向下的顺序加载的，读取到一行就运行一行。如果将script标签写到页面的上边，在代码执行时，页面还没有加载，页面没有加载DOM对象也没有加载，会导致无法获取到DOM对象。 onload 事件： onload 事件会在整个页面加载完成之后才触发。为 window 绑定一个onload事件，该事件对应的响应函数将会在页面加载完成之后执行，这样可以确保我们的代码执行时所有的DOM对象已经加载完毕了。 代码举例： 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; // 【方式一：先加载，后执行】这段 js 代码是写在 &lt;head&gt; 标签里的，所以建议放在 window.onload 里面。 window.onload = function() &#123; // 获取id为btn的按钮 var btn = document.getElementById(\"btn\"); // 为按钮绑定点击事件 btn.onclick = function() &#123; alert(\"hello\"); &#125;; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=\"btn\"&gt;点我一下&lt;/button&gt; &lt;script type=\"text/javascript\"&gt; // 【方式二：后加载，后执行】这段 js 代码是写在 &lt;body&gt; 标签里的，代码的位置是处在页面的下方。这么做，也可以确保：在页面加载完毕后，再执行 js 代码。 // 获取id为btn的按钮 var btn = document.getElementById(\"btn\"); // 为按钮绑定点击事件 btn.onclick = function() &#123; alert(\"hello\"); &#125;; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 上方代码中，方式一和方式二均可以确保：在页面加载完毕后，再执行 js 代码。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"通过style对象获取和设置行内样式","slug":"27-通过style对象获取和设置行内样式","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T10:05:20.000Z","comments":true,"path":"2020/04/18/27-通过style对象获取和设置行内样式/","link":"","permalink":"http://yoursite.com/2020/04/18/27-%E9%80%9A%E8%BF%87style%E5%AF%B9%E8%B1%A1%E8%8E%B7%E5%8F%96%E5%92%8C%E8%AE%BE%E7%BD%AE%E8%A1%8C%E5%86%85%E6%A0%B7%E5%BC%8F/","excerpt":"style属性的获取和修改在DOM当中，如果想设置样式，有两种形式： className（针对内嵌样式） style（针对行内样式）","text":"style属性的获取和修改在DOM当中，如果想设置样式，有两种形式： className（针对内嵌样式） style（针对行内样式） 接下来主要讲style。 需要注意的是：style是一个对象，只能获取行内样式，不能获取内嵌的样式和外链的样式。例如： 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; div &#123; border: 6px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box1\" style=\"width: 200px;height: 100px;background-color: pink;\"&gt;&lt;/div&gt; &lt;script&gt; var box1 = document.getElementsByTagName(\"div\")[0]; console.log(box1.style.backgroundColor); console.log(box1.style.border); //没有打印结果，因为这个属性不是行内样式 console.log(typeof box1.style); //因为是对象，所以打印结果是Object console.log(box1.style); //打印结果是对象 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 因为border属性不是行内样式，所以无法通过style对象获取。 通过 js 读取元素的样式语法：（方式一） 1元素.style.样式名 备注：我们通过style属性读取的样式都是行内样式。 语法：（方式二） 123元素.style[\"属性\"]; //格式box.style[\"width\"]; //举例 方式二最大的优点是：可以给属性传递参数。 通过 js 设置元素的样式语法： 1元素.style.样式名 = 样式值; 举例： 12box1.style.width &#x3D; &quot;300px&quot;;box1.style.backgroundColor &#x3D; &quot;red&quot;; &#x2F;&#x2F; 驼峰命名法 备注：我们通过style属性设置的样式都是行内样式，而行内样式有较高的优先级。但是如果在样式中的其他地方写了!important，则此时!important会有更高的优先级。 style属性的注意事项style属性需要注意以下几点： （1）样式少的时候使用。 （2）style是对象。我们在上方已经打印出来，typeof的结果是Object。 （3）值是字符串，没有设置值是“”。 （4）命名规则，驼峰命名。 （5）只能获取行内样式，和内嵌和外链无关。 （6）box.style.cssText = “字符串形式的样式”。 cssText这个属性，其实就是把行内样式里面的值当做字符串来对待。在上方代码的基础之上，举例： 123456789&lt;script&gt; var box1 = document.getElementsByTagName(\"div\")[0]; //通过cssText一次性设置行内样式 box1.style.cssText = \"width: 300px;height: 300px;background-color: green;\"; console.log(box1.style.cssText); //这一行更加可以理解,style是对象&lt;/script&gt; style的常用属性style的常用属性包括： backgroundColor backgroundImage color width height border opacity 设置透明度 (IE8以前是filter: alpha(opacity=xx)) 注意DOM对象style的属性和标签中style内的值不一样，因为在JS中，-不能作为标识符。比如： DOM中：backgroundColor CSS中：background-color style属性的举例我们针对上面列举的几个style的样式，来举几个例子： 举例1、改变div的大小和透明度 举例2、当前输入的文本框高亮显示 举例3、高级隔行变色、高亮显示 下面来逐一实现。 举例1：改变div的大小和透明度代码举例： 12345678910111213141516&lt;body&gt;&lt;div style=\"width: 100px;height: 100px;background-color: pink;\"&gt;&lt;/div&gt;&lt;script&gt; var div = document.getElementsByTagName(\"div\")[0]; div.onmouseover = function () &#123; div.style.width = \"200px\"; div.style.height = \"200px\"; div.style.backgroundColor = \"black\"; div.style.opacity = \"0.2\"; //设置背景色的透明度。单位是0.1 div.style.filter = \"alpha(opacity=20)\"; //上一行代码的兼容性写法。注意单位是百进制 &#125;&lt;/script&gt;&lt;/body&gt; 举例2：当前输入的文本框高亮显示代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; input &#123; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;input type=\"text\"/&gt; &lt;input type=\"text\"/&gt; &lt;input type=\"text\"/&gt; &lt;input type=\"text\"/&gt; &lt;input type=\"text\"/&gt;&lt;/ul&gt;&lt;script&gt; //需求：让所有的input标签获取焦点后高亮显示 //1.获取事件源 var inpArr = document.getElementsByTagName(\"input\"); //2.绑定事件 //3.书写事件驱动程序 for (var i = 0; i &lt; inpArr.length; i++) &#123; //获取焦点后，所有的input标签被绑定onfocus事件 inpArr[i].onfocus = function () &#123; this.style.border = \"2px solid red\"; this.style.backgroundColor = \"#ccc\"; &#125; //绑定onblur事件，取消样式 inpArr[i].onblur = function () &#123; this.style.border = \"\"; this.style.backgroundColor = \"\"; &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 举例3：高级隔行变色、高亮显示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; * &#123; padding: 0; margin: 0; text-align: center; &#125; .wrap &#123; width: 500px; margin: 100px auto 0; &#125; table &#123; border-collapse: collapse; border-spacing: 0; border: 1px solid #c0c0c0; width: 500px; &#125; th, td &#123; border: 1px solid #d0d0d0; color: #404060; padding: 10px; &#125; th &#123; background-color: #09c; font: bold 16px \"微软雅黑\"; color: #fff; &#125; td &#123; font: 14px \"微软雅黑\"; &#125; tbody tr &#123; background-color: #f0f0f0; cursor: pointer; &#125; .current &#123; background-color: red !important; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"wrap\"&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;课程&lt;/th&gt; &lt;th&gt;成绩&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody id=\"target\"&gt; &lt;tr&gt; &lt;td&gt; 1 &lt;/td&gt; &lt;td&gt;生命壹号&lt;/td&gt; &lt;td&gt;语文&lt;/td&gt; &lt;td&gt;100&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; 2 &lt;/td&gt; &lt;td&gt;生命贰号&lt;/td&gt; &lt;td&gt;日语&lt;/td&gt; &lt;td&gt;99&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; 3 &lt;/td&gt; &lt;td&gt;生命叁号&lt;/td&gt; &lt;td&gt;营销学&lt;/td&gt; &lt;td&gt;98&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; 4 &lt;/td&gt; &lt;td&gt;生命伍号&lt;/td&gt; &lt;td&gt;数学&lt;/td&gt; &lt;td&gt;90&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; 5 &lt;/td&gt; &lt;td&gt;许嵩&lt;/td&gt; &lt;td&gt;英语&lt;/td&gt; &lt;td&gt;96&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; 6 &lt;/td&gt; &lt;td&gt;vae&lt;/td&gt; &lt;td&gt;体育&lt;/td&gt; &lt;td&gt;90&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt;&lt;script&gt; //需求：让tr各行变色，鼠标放入tr中，高亮显示。 //1.隔行变色。 var tbody = document.getElementById(\"target\"); var trArr = tbody.children; //循环判断并各行赋值属性（背景色） for (var i = 0; i &lt; trArr.length; i++) &#123; if (i % 2 !== 0) &#123; trArr[i].style.backgroundColor = \"#a3a3a3\"; &#125; else &#123; trArr[i].style.backgroundColor = \"#ccc\"; &#125; //鼠标进入高亮显示 //难点：鼠标移开的时候要回复原始颜色。 //计数器（进入tr之后，立刻记录颜色，然后移开的时候使用记录好的颜色） var myColor = \"\"; trArr[i].onmouseover = function () &#123; //赋值颜色之前，先记录颜色 myColor = this.style.backgroundColor; this.style.backgroundColor = \"#fff\"; &#125; trArr[i].onmouseout = function () &#123; this.style.backgroundColor = myColor; &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 代码解释： 上方代码中，我们用到了计数器myColor来记录每一行最原始的颜色（赋值白色之前）。如果不用计数器，可能很多人以为代码是写的：（错误的代码） 12345678910111213141516171819202122232425&lt;script&gt; //需求：让tr各行变色，鼠标放入tr中，高亮显示。 //1.隔行变色。 var tbody = document.getElementById(\"target\"); var trArr = tbody.children; //循环判断并各行赋值属性（背景色） for (var i = 0; i &lt; trArr.length; i++) &#123; if (i % 2 !== 0) &#123; trArr[i].style.backgroundColor = \"#a3a3a3\"; &#125; else &#123; trArr[i].style.backgroundColor = \"#ccc\"; &#125; //鼠标进入高亮显示 //难点：鼠标移开的时候要回复原始颜色。 //计数器（进入tr之后，立刻记录颜色，然后移开的时候使用记录好的颜色） trArr[i].onmouseover = function () &#123; this.style.backgroundColor = \"#fff\"; &#125; trArr[i].onmouseout = function () &#123; this.style.backgroundColor = \"#a3a3a3\"; &#125; &#125;&lt;/script&gt; 通过 js 获取元素当前显示的样式我们在上面的内容中，通过元素.style.className的方式只能获取行内样式。但是，有些元素，也写了内嵌样式或外链样式。 既然样式有这么种，那么，如何获取元素当前显示的样式（包括行内样式、内嵌样式、外链样式）呢？我们接下来看一看。 获取元素当前正在显示的样式（1）w3c的做法： 1window.getComputedStyle(\"要获取样式的元素\", \"伪元素\"); 两个参数都是必须要有的。参数二中，如果没有伪元素就用 null 代替（一般都传null）。 （2）IE和opera的做法： 1obj.currentStyle; 注意： 如果当前元素没有设置该样式，则获取它的默认值。 该方法会返回一个对象，对象中封装了当前元素对应的样式，可以通过对象.样式名来读取具体的某一个样式。 通过currentStyle和getComputedStyle()读取到的样式都是只读的，不能修改，如果要修改必须通过style属性。 综合上面两种写法，就有了一种兼容性的写法，同时将其封装。代码举例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div &#123; background-color: pink; /*border: 1px solid #000;*/ padding: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div style=\"width: 100px;height: 100px;\"&gt;&lt;/div&gt;&lt;script&gt; var div1 = document.getElementsByTagName(\"div\")[0]; console.log(getStyle(div1, \"width\")); console.log(getStyle(div1, \"padding\")); console.log(getStyle(div1, \"background-color\")); /* * 兼容方法，获取元素当前正在显示的样式。 * 参数： * obj 要获取样式的元素 *. name 要获取的样式名 */ function getStyle(ele, attr) &#123; if (window.getComputedStyle) &#123; return window.getComputedStyle(ele, null)[attr]; &#125; return ele.currentStyle[attr]; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"offset相关属性和匀速动画","slug":"28-offset相关属性和匀速动画(含轮播图的实现)","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T04:02:00.000Z","comments":true,"path":"2020/04/18/28-offset相关属性和匀速动画(含轮播图的实现)/","link":"","permalink":"http://yoursite.com/2020/04/18/28-offset%E7%9B%B8%E5%85%B3%E5%B1%9E%E6%80%A7%E5%92%8C%E5%8C%80%E9%80%9F%E5%8A%A8%E7%94%BB(%E5%90%AB%E8%BD%AE%E6%92%AD%E5%9B%BE%E7%9A%84%E5%AE%9E%E7%8E%B0)/","excerpt":"前言JS动画的主要内容如下： 1、三大家族和一个事件对象： 三大家族：offset/scroll/client。也叫三大系列。 事件对象/event（事件被触动时，鼠标和键盘的状态）（通过属性控制）。 2、动画(闪现/匀速/缓动) 3、冒泡/兼容/封装","text":"前言JS动画的主要内容如下： 1、三大家族和一个事件对象： 三大家族：offset/scroll/client。也叫三大系列。 事件对象/event（事件被触动时，鼠标和键盘的状态）（通过属性控制）。 2、动画(闪现/匀速/缓动) 3、冒泡/兼容/封装 offset 家族的组成我们知道，JS动画的三大家族包括：offset/scroll/client。今天来讲一下offset，以及与其相关的匀速动画。 offset的中文是：偏移，补偿，位移。 js中有一套方便的获取元素尺寸的办法就是offset家族。offset家族包括： offsetWidth offsetHight offsetLeft offsetTop offsetParent 下面分别介绍。 1、offsetWidth 和 offsetHightoffsetWidth 和 offsetHight：获取元素的宽高 + padding + border，不包括margin。如下： offsetWidth = width + padding + border offsetHeight = Height + padding + border 这两个属性，他们绑定在了所有的节点元素上。获取元素之后，只要调用这两个属性，我们就能够获取元素节点的宽和高。 举例如下： 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div &#123; width: 100px; height: 100px; padding: 10px; border: 10px solid #000; margin: 100px; background-color: pink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"box\"&gt;&lt;/div&gt;&lt;script&gt; var div1 = document.getElementsByTagName(\"div\")[0]; console.log(div1.offsetHeight); //打印结果：140（100+20+20） console.log(typeof div1.offsetHeight); //打印结果：number&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、offsetParentoffsetParent：获取当前元素的定位父元素。 如果当前元素的父元素，有CSS定位（position为absolute、relative、fixed），那么 offsetParent 获取的是最近的那个父元素。 如果当前元素的父元素，没有CSS定位（position为absolute、relative、fixed），那么offsetParent 获取的是body。 举例： 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"box1\" style=\"position: absolute;\"&gt; &lt;div class=\"box2\" style=\"position: fixed;\"&gt; &lt;div class=\"box3\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; var box3 = document.getElementsByClassName(\"box3\")[0]; console.log(box3.offsetParent);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3、offsetLeft 和 offsetTopoffsetLeft：当前元素相对于其定位父元素的水平偏移量。 offsetTop：当前元素相对于其定位父元素的垂直偏移量。 备注：从父亲的 padding 开始算起，父亲的 border 不算在内。 举例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .box1 &#123; width: 300px; height: 300px; padding: 100px; margin: 100px; position: relative; border: 100px solid #000; background-color: pink; &#125; .box2 &#123; width: 100px; height: 100px; background-color: red; /*position: absolute;*/ /*left: 10px;*/ /*top: 10px;*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"box1\"&gt; &lt;div class=\"box2\" style=\"left: 10px\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var box2 = document.getElementsByClassName(\"box2\")[0]; //offsetTop和offsetLeft console.log(box2.offsetLeft); //100 console.log(box2.style.left); //10px&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在父盒子有定位的情况下，offsetLeft == style.left(去掉px之后)。注意，后者只识别行内样式。但区别不仅仅于此，下面会讲。 offsetLeft 和 style.left 区别（1）最大区别在于： offsetLeft 可以返回无定位父元素的偏移量。如果父元素中都没有定位，则body为准。 style.left 只能获取行内样式，如果父元素中都没有设置定位，则返回””（意思是，返回空字符串）; （2）offsetTop 返回的是数字，而 style.top 返回的是字符串，而且还带有单位：px。 比如： 123div.offsetLeft = 100;div.style.left = \"100px\"; （3）offsetLeft 和 offsetTop 只读，而 style.left 和 style.top 可读写（只读是获取值，可写是修改值） 总结：我们一般的做法是：用offsetLeft 和 offsetTop 获取值，用style.left 和 style.top 赋值（比较方便）。理由如下： style.left：只能获取行内式，获取的值可能为空，容易出现NaN。 offsetLeft：获取值特别方便，而且是现成的number，方便计算。它是只读的，不能赋值。 动画的种类 闪现（基本不用） 匀速（本文重点） 缓动（后续重点） 简单举例如下：（每间隔500ms，向右移动盒子100px） 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div &#123; width: 100px; height: 100px; background-color: pink; position: absolute; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;动画&lt;/button&gt;&lt;div class=\"box\" style=\"left: 0px\"&gt;&lt;/div&gt;&lt;script&gt; var btn = document.getElementsByTagName(\"button\")[0]; var div = document.getElementsByTagName(\"div\")[0]; //1、闪动 // btn.onclick = function () &#123; // div.style.left = \"500px\"; // &#125; //2、匀速运动 btn.onclick = function () &#123; //定时器，每隔一定的时间向右走一些 setInterval(function () &#123; console.log(parseInt(div.style.left)); //动画原理： 盒子未来的位置 = 盒子现在的位置 + 步长； //用style.left赋值，用offsetLeft获取值。 div.style.left = div.offsetLeft + 100 + \"px\"; //div.style.left = parseInt(div.style.left)+10+\"px\"; //NaN不能用 &#125;, 500); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 匀速动画的封装：每间隔30ms，移动盒子10px【重要】代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .box1 &#123; margin: 0; padding: 5px; height: 300px; background-color: #ddd; position: relative; &#125; button &#123; margin: 5px; &#125; .box2 &#123; width: 100px; height: 100px; background-color: red; position: absolute; left: 195px; top: 40px; &#125; .box3 &#123; width: 100px; height: 100px; background-color: yellow; position: absolute; left: 0; top: 150px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"box1\"&gt; &lt;button&gt;运动到 left = 200px&lt;/button&gt; &lt;button&gt;运动到 left = 400px&lt;/button&gt; &lt;div class=\"box2\"&gt;&lt;/div&gt; &lt;div class=\"box3\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var btnArr = document.getElementsByTagName(\"button\"); var box2 = document.getElementsByClassName(\"box2\")[0]; var box3 = document.getElementsByClassName(\"box3\")[0]; //绑定事件 btnArr[0].onclick = function () &#123; //如果有一天我们要传递另外一个盒子，那么我们的方法就不好用了 //所以我们要增加第二个参数，被移动的盒子本身。 animate(box2, 200); animate(box3, 200); &#125; btnArr[1].onclick = function () &#123; animate(box2, 400); animate(box3, 400); &#125; //【重要】方法的封装：每间隔30ms，将盒子向右移动10px function animate(ele, target) &#123; //要用定时器，先清除定时器 //一个盒子只能有一个定时器，这样的话，不会和其他盒子出现定时器冲突 //我们可以把定时器本身，当成为盒子的一个属性 clearInterval(ele.timer); //我们要求盒子既能向前又能向后，那么我们的步长就得有正有负 //目标值如果大于当前值取正，目标值如果小于当前值取负 var speed = target &gt; ele.offsetLeft ? 10 : -10; //speed指的是步长 ele.timer = setInterval(function () &#123; //在执行之前就获取当前值和目标值之差 var val = target - ele.offsetLeft; ele.style.left = ele.offsetLeft + speed + \"px\"; //移动的过程中，如果目标值和当前值之差如果小于步长，那么就不能在前进了 //因为步长有正有负，所有转换成绝对值来比较 if (Math.abs(val) &lt; Math.abs(speed)) &#123; ele.style.left = target + \"px\"; clearInterval(ele.timer); &#125; &#125;, 30) &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上方代码中的方法封装，可以作为一个模板步骤，要记住。其实，这个封装的方法，写成下面这样，会更严谨，更容易理解：（将if语句进行了改进） 1234567891011121314151617181920212223//【重要】方法的封装：每间隔30ms，将盒子向右移动10pxfunction animate(ele, target) &#123; //要用定时器，先清除定时器 //一个盒子只能有一个定时器，这样的话，不会和其他盒子出现定时器冲突 //我们可以把定时器本身，当成为盒子的一个属性 clearInterval(ele.timer); //我们要求盒子既能向前又能向后，那么我们的步长就得有正有负 //目标值如果大于当前值取正，目标值如果小于当前值取负 var speed = target &gt; ele.offsetLeft ? 10 : -10; //speed指的是步长 ele.timer = setInterval(function () &#123; //在执行之前就获取当前值和目标值之差 var val = target - ele.offsetLeft; //移动的过程中，如果目标值和当前值之差如果小于步长，那么就不能在前进了 //因为步长有正有负，所有转换成绝对值来比较 if (Math.abs(val) &lt; Math.abs(speed)) &#123; //如果val小于步长，则直接到达目的地；否则，每次移动一个步长 ele.style.left = target + \"px\"; clearInterval(ele.timer); &#125; else &#123; ele.style.left = ele.offsetLeft + speed + \"px\"; &#125; &#125;, 30)&#125; 代码举例：轮播图的实现完整版代码如下：（注释已经比较详细） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style type=\"text/css\"&gt; * &#123; padding: 0; margin: 0; list-style: none; border: 0; &#125; .all &#123; width: 500px; height: 200px; padding: 7px; border: 1px solid #ccc; margin: 100px auto; position: relative; &#125; .screen &#123; width: 500px; height: 200px; overflow: hidden; position: relative; &#125; .screen li &#123; width: 500px; height: 200px; overflow: hidden; float: left; &#125; .screen ul &#123; position: absolute; left: 0; top: 0px; width: 3000px; &#125; .all ol &#123; position: absolute; right: 10px; bottom: 10px; line-height: 20px; text-align: center; &#125; .all ol li &#123; float: left; width: 20px; height: 20px; background: #fff; border: 1px solid #ccc; margin-left: 10px; cursor: pointer; &#125; .all ol li.current &#123; background: yellow; &#125; #arr &#123; display: none; &#125; #arr span &#123; width: 40px; height: 40px; position: absolute; left: 5px; top: 50%; margin-top: -20px; background: #000; cursor: pointer; line-height: 40px; text-align: center; font-weight: bold; font-family: '黑体'; font-size: 30px; color: #fff; opacity: 0.3; border: 1px solid #fff; &#125; #arr #right &#123; right: 5px; left: auto; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function () &#123; //需求：无缝滚动。 //思路：赋值第一张图片放到ul的最后，然后当图片切换到第五张的时候 // 直接切换第六章，再次从第一张切换到第二张的时候先瞬间切换到 // 第一张图片，然后滑动到第二张 //步骤： //1.获取事件源及相关元素。（老三步） //2.复制第一张图片所在的li,添加到ul的最后面。 //3.给ol中添加li，ul中的个数-1个，并点亮第一个按钮。 //4.鼠标放到ol的li上切换图片 //5.添加定时器 //6.左右切换图片（鼠标放上去隐藏，移开显示） //1.获取事件源及相关元素。（老三步） var all = document.getElementById(\"all\"); var screen = all.firstElementChild || all.firstChild; var imgWidth = screen.offsetWidth; var ul = screen.firstElementChild || screen.firstChild; var ol = screen.children[1]; var div = screen.lastElementChild || screen.lastChild; var spanArr = div.children; //2.复制第一张图片所在的li,添加到ul的最后面。 var ulNewLi = ul.children[0].cloneNode(true); ul.appendChild(ulNewLi); //3.给ol中添加li，ul中的个数-1个，并点亮第一个按钮。 for (var i = 0; i &lt; ul.children.length - 1; i++) &#123; var olNewLi = document.createElement(\"li\"); olNewLi.innerHTML = i + 1; ol.appendChild(olNewLi) &#125; var olLiArr = ol.children; olLiArr[0].className = \"current\"; //4.鼠标放到ol的li上切换图片 for (var i = 0; i &lt; olLiArr.length; i++) &#123; //自定义属性，把索引值绑定到元素的index属性上 olLiArr[i].index = i; olLiArr[i].onmouseover = function () &#123; //排他思想 for (var j = 0; j &lt; olLiArr.length; j++) &#123; olLiArr[j].className = \"\"; &#125; this.className = \"current\"; //鼠标放到小的方块上的时候索引值和key以及square同步// key = this.index;// square = this.index; key = square = this.index; //移动盒子 animate(ul, -this.index * imgWidth); &#125; &#125; //5.添加定时器 var timer = setInterval(autoPlay, 1000); //固定向右切换图片 //两个定时器（一个记录图片，一个记录小方块） var key = 0; var square = 0; function autoPlay() &#123; //通过控制key的自增来模拟图片的索引值，然后移动ul key++; if (key &gt; olLiArr.length) &#123; //图片已经滑动到最后一张，接下来，跳转到第一张，然后在滑动到第二张 ul.style.left = 0; key = 1; &#125; animate(ul, -key * imgWidth); //通过控制square的自增来模拟小方块的索引值，然后点亮盒子 //排他思想做小方块 square++; if (square &gt; olLiArr.length - 1) &#123;//索引值不能大于等于5，如果等于5，立刻变为0； square = 0; &#125; for (var i = 0; i &lt; olLiArr.length; i++) &#123; olLiArr[i].className = \"\"; &#125; olLiArr[square].className = \"current\"; &#125; //鼠标放上去清除定时器，移开后在开启定时器 all.onmouseover = function () &#123; div.style.display = \"block\"; clearInterval(timer); &#125; all.onmouseout = function () &#123; div.style.display = \"none\"; timer = setInterval(autoPlay, 1000); &#125; //6.左右切换图片（鼠标放上去显示，移开隐藏） spanArr[0].onclick = function () &#123; //通过控制key的自增来模拟图片的索引值，然后移动ul key--; if (key &lt; 0) &#123; //先移动到最后一张，然后key的值取之前一张的索引值，然后在向前移动 ul.style.left = -imgWidth * (olLiArr.length) + \"px\"; key = olLiArr.length - 1; &#125; animate(ul, -key * imgWidth); //通过控制square的自增来模拟小方块的索引值，然后点亮盒子 //排他思想做小方块 square--; if (square &lt; 0) &#123;//索引值不能大于等于5，如果等于5，立刻变为0； square = olLiArr.length - 1; &#125; for (var i = 0; i &lt; olLiArr.length; i++) &#123; olLiArr[i].className = \"\"; &#125; olLiArr[square].className = \"current\"; &#125; spanArr[1].onclick = function () &#123; //右侧的和定时器一模一样 autoPlay(); &#125; function animate(ele, target) &#123; clearInterval(ele.timer); var speed = target &gt; ele.offsetLeft ? 10 : -10; ele.timer = setInterval(function () &#123; var val = target - ele.offsetLeft; ele.style.left = ele.offsetLeft + speed + \"px\"; if (Math.abs(val) &lt; Math.abs(speed)) &#123; ele.style.left = target + \"px\"; clearInterval(ele.timer); &#125; &#125;, 10) &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"all\" id='all'&gt; &lt;div class=\"screen\" id=\"screen\"&gt; &lt;ul id=\"ul\"&gt; &lt;li&gt;&lt;img src=\"images/1.jpg\" width=\"500\" height=\"200\"/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/2.jpg\" width=\"500\" height=\"200\"/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/3.jpg\" width=\"500\" height=\"200\"/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/4.jpg\" width=\"500\" height=\"200\"/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/5.jpg\" width=\"500\" height=\"200\"/&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;/ol&gt; &lt;div id=\"arr\"&gt; &lt;span id=\"left\"&gt;&lt;&lt;/span&gt; &lt;span id=\"right\"&gt;&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"29-scroll相关属性和缓动动画","slug":"29-scroll相关属性和缓动动画","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T10:05:06.000Z","comments":true,"path":"2020/04/18/29-scroll相关属性和缓动动画/","link":"","permalink":"http://yoursite.com/2020/04/18/29-scroll%E7%9B%B8%E5%85%B3%E5%B1%9E%E6%80%A7%E5%92%8C%E7%BC%93%E5%8A%A8%E5%8A%A8%E7%94%BB/","excerpt":"scroll 相关属性window.onscroll() 方法当我们用鼠标滚轮，滚动网页的时候，会触发 window.onscroll() 方法。效果如下：（注意看控制台的打印结果）","text":"scroll 相关属性window.onscroll() 方法当我们用鼠标滚轮，滚动网页的时候，会触发 window.onscroll() 方法。效果如下：（注意看控制台的打印结果） 如果你需要做滚动监听，可以使用这个方法。 我们来看看和 scroll 相关的有哪些属性。 1、ScrollWidth 和 scrollHeightScrollWidth 和 scrollHeight：获取元素整个滚动区域的宽、高。包括 width 和 padding，不包括 border和margin。 注意： scrollHeight 的特点是：如果内容超出了盒子，scrollHeight为内容的高（包括超出的内容）；如果不超出，scrollHeight为盒子本身的高度。ScrollWidth同理。 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div &#123; width: 100px; height: 100px; padding: 10px; margin: 3px; border: 8px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"box\"&gt; 静，能寒窗苦守；动，能点石成金。 静，能寒窗苦守；动，能点石成金。 静，能寒窗苦守；动，能点石成金。 静，能寒窗苦守；动，能点石成金。 静，能寒窗苦守；动，能点石成金。 静，能寒窗苦守；动，能点石成金。&lt;/div&gt;&lt;script&gt; var div = document.getElementsByTagName(\"div\")[0]; // `scrollHeight` 的特点是：如果内容超出了盒子，`scrollHeight`为内容的高（包括超出的内容）；如果不超出，`scrollHeight`为盒子本身的高度。 //IE8以下（不包括IE8），为盒子本身内容的高度。 console.log(div.scrollWidth); console.log(div.scrollHeight);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、scrollTop 和 scrollLeft scrollLeft：获取水平滚动条滚动的距离。 scrollTop：获取垂直滚动条滚动的距离。 实战经验： 当某个元素满足scrollHeight - scrollTop == clientHeight时，说明垂直滚动条滚动到底了。 当某个元素满足scrollWidth - scrollLeft == clientWidth时，说明水平滚动条滚动到底了。 这个实战经验非常有用，可以用来判断用户是否已经将内容滑动到底了。比如说，有些场景下，希望用户能够看完“长长的活动规则”，才允许触发接下来的表单操作。 scrollTop 的兼容性如果要获取页面滚动的距离，scrollTop 这个属性的写法要注意兼容性，如下。 （1）如果文档没有 DTD 声明，写法为： 1document.body.scrollTop 在没有 DTD 声明的情况下，要求是这种写法，chrome浏览器才能认出来。 （2）如果文档有 DTD 声明，写法为： 1document.documentElement.scrollTop 在有 DTD 声明的情况下，要求是这种写法，IE6、7、8才能认出来。 综合上面这两个，就诞生了一种兼容性的写法： 123document.body.scrollTop || document.documentElement.scrollTop //方式一document.body.scrollTop + document.documentElement.scrollTop //方式二 另外还有一种兼容性的写法：window.pageYOffset 和 window.pageXOffset。这种写法无视DTD的声明。这种写法支持的浏览器版本是：火狐/谷歌/ie9+。 综合上面的几种写法，为了兼容，不管有没有DTD，最终版的兼容性写法： 1window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop; 判断是否已经 DTD 声明方法如下： 12document.compatMode === \"CSS1Compat\" // 已声明document.compatMode === \"BackCompat\" // 未声明 将 scrollTop 和 scrollLeft 进行封装这里，我们将 scrollTop 和 scrollLeft 封装为一个方法，名叫scroll()，返回值为 一个对象。以后就直接调用scroll().top 和 scroll().left就好。 代码实现： 12345678910111213141516171819202122232425262728293031323334&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; body &#123; height: 6000px; width: 5000px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; //需求：封装一个兼容的scroll().返回的是对象，用scroll().top获取scrollTop，用scroll().left获取scrollLeft window.onscroll = function () &#123;// var myScroll = scroll();// myScroll.top; console.log(scroll().top); console.log(scroll().left); &#125; //函数封装（简单封装，实际工作使用） function scroll() &#123; return &#123; //此函数的返回值是对象 left: window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop, right: window.pageXOffset || document.body.scrollLeft || document.documentElement.scrollLeft &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上方代码中，函数定义的那部分就是要封装的代码。 另外还有一种比较麻烦的封装方式：（仅供参考） 12345678910111213141516171819function scroll() &#123; // 开始封装自己的scrollTop if(window.pageYOffset !== undefined) &#123; // ie9+ 高版本浏览器 // 因为 window.pageYOffset 默认的是 0 所以这里需要判断 return &#123; left: window.pageXOffset, top: window.pageYOffset &#125; &#125; else if(document.compatMode === \"CSS1Compat\") &#123; // 标准浏览器 来判断有没有声明DTD return &#123; left: document.documentElement.scrollLeft, top: document.documentElement.scrollTop &#125; &#125; return &#123; // 未声明 DTD left: document.body.scrollLeft, top: document.body.scrollTop &#125;&#125; 获取 html 文档的方法获取title、body、head、html标签的方法如下： document.title 文档标题； document.head 文档的头标签 document.body 文档的body标签； document.documentElement （这个很重要）。 document.documentElement表示文档的html标签。也就是说，基本结构当中的 html 标签而是通过document.documentElement访问的，并不是通过 document.html 去访问的。 scrollTop 举例：固定导航栏完整版代码实现： （1）index.html： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0 &#125; img &#123; vertical-align: top; &#125; .main &#123; margin: 0 auto; width: 1000px; margin-top: 10px; &#125; #Q-nav1 &#123; overflow: hidden; &#125; .fixed &#123; position: fixed; top: 0; left: 0; &#125; &lt;/style&gt; &lt;!--引入工具js--&gt; &lt;script src=\"tools.js\"&gt;&lt;/script&gt; &lt;script&gt; window.onload = function () &#123; //需求1：当我们滚动界面的时候，被卷曲的头部如果超过第二个盒子距离顶部的位置，那么直接给第二个盒子加类名.fixed //需求2：当我们滚动界面的时候，被卷曲的头部如果小于第二个盒子距离顶部的位置，那么直接给第二个盒子取消类名.fixed //1.老三步。 var topDiv = document.getElementById(\"top\"); var height = topDiv.offsetHeight; var middle = document.getElementById(\"Q-nav1\"); var main = document.getElementById(\"main\"); window.onscroll = function () &#123; //2.判断 ，被卷曲的头部的大小 if (scroll().top &gt; height) &#123; //3.满足条件添加类，否则删除类 middle.className += \" fixed\"; //第二个盒子也要占位置，为了避免重叠，我们给第三个盒子一个上padding的空间，把这个空间留给第二个盒子 main.style.paddingTop = middle.offsetHeight + \"px\"; &#125; else &#123; middle.className = \"\"; //清零 main.style.paddingTop = 0; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"top\" id=\"top\"&gt; &lt;img src=\"images/top.png\" alt=\"\"/&gt;&lt;/div&gt;&lt;div id=\"Q-nav1\"&gt; &lt;img src=\"images/nav.png\" alt=\"\"/&gt;&lt;/div&gt;&lt;div class=\"main\" id=\"main\"&gt; &lt;img src=\"images/main.png\" alt=\"\"/&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 上方代码中，有一个技巧： 1main.style.paddingTop = middle.offsetHeight + \"px\"; 仔细看注释就好。 （2）tools.js： 12345678910111213141516171819202122/** * Created by smyhvae on 2018/02/03. */function scroll() &#123; // 开始封装自己的scrollTop if (window.pageYOffset !== undefined) &#123; // ie9+ 高版本浏览器 // 因为 window.pageYOffset 默认的是 0 所以这里需要判断 return &#123; left: window.pageXOffset, top: window.pageYOffset &#125; &#125; else if (document.compatMode === \"CSS1Compat\") &#123; // 标准浏览器 来判断有没有声明DTD return &#123; left: document.documentElement.scrollLeft, top: document.documentElement.scrollTop &#125; &#125; return &#123; // 未声明 DTD left: document.body.scrollLeft, top: document.body.scrollTop &#125;&#125; 缓动动画三个函数缓慢动画里，我们要用到三个函数，这里先列出来： Math.ceil() 向上取整 Math.floor() 向下取整 Math.round(); 四舍五入 缓动动画的原理缓动动画的原理就是：在移动的过程中，步长越来越小。 设置步长为：目标位置和盒子当前位置的十分之一。用公式表达，即： 1盒子位置 &#x3D; 盒子本身位置 + (目标位置 - 盒子本身位置)&#x2F; 10； 代码举例： 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div &#123; width: 100px; height: 100px; background-color: pink; position: absolute; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;运动到left = 400px&lt;/button&gt;&lt;div&gt;&lt;/div&gt;&lt;script&gt; var btn = document.getElementsByTagName(\"button\")[0]; var div = document.getElementsByTagName(\"div\")[0]; btn.onclick = function () &#123; setInterval(function () &#123; //动画原理：盒子未来的位置 = 盒子当前的位置+步长 div.style.left = div.offsetLeft + (400 - div.offsetLeft) / 10 + \"px\"; &#125;, 30); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 缓慢动画的封装（解决四舍五入的问题）我们发现一个问题，上图中的盒子最终并没有到达400px的位置，而是只到了396.04px就停住了： 原因是：JS在取整的运算时，进行了四舍五入。 我么发现，通过div.style.left获取的值是精确的，通过div.offsetLeft获取的left值会进行四舍五入。 此时，我们就要用到取整的函数了。 通过对缓动动画进行封装，完整版的代码实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div &#123; width: 100px; height: 100px; background-color: pink; position: absolute; left: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;运动到200&lt;/button&gt;&lt;button&gt;运动到400&lt;/button&gt;&lt;div&gt;&lt;/div&gt;&lt;script&gt; var btn = document.getElementsByTagName(\"button\"); var div = document.getElementsByTagName(\"div\")[0]; btn[0].onclick = function () &#123; animate(div, 200); &#125; btn[1].onclick = function () &#123; animate(div, 400); &#125; //缓动动画封装 function animate(ele, target) &#123; //要用定时器，先清定时器 //一个萝卜一个坑儿，一个元素对应一个定时器 clearInterval(ele.timer); //定义定时器 ele.timer = setInterval(function () &#123; //获取步长 //步长应该是越来越小的，缓动的算法。 var step = (target - ele.offsetLeft) / 10; //对步长进行二次加工(大于0向上取整,小于0向下取整) //达到的效果是：最后10像素的时候都是1像素1像素的向目标位置移动，就能够到达指定位置。 step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); //动画原理： 目标位置 = 当前位置 + 步长 ele.style.left = ele.offsetLeft + step + \"px\"; console.log(step); //检测缓动动画有没有停止 console.log(\"smyhvae\"); if (Math.abs(target - ele.offsetLeft) &lt;= Math.abs(step)) &#123; //处理小数赋值 ele.style.left = target + \"px\"; clearInterval(ele.timer); &#125; &#125;, 30); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; window.scrollTo()方法举例：返回到顶部小火箭（1）index.html： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; img &#123; position: fixed; bottom: 100px; right: 50px; cursor: pointer; display: none; border: 1px solid #000; &#125; div &#123; width: 1210px; margin: 100px auto; text-align: center; font: 500 26px/35px \"simsun\"; color: red; &#125; &lt;/style&gt; &lt;script src=\"tools.js\"&gt;&lt;/script&gt; &lt;script&gt; window.onload = function () &#123; //需求：被卷去的头部超过100显示小火箭，然后点击小火箭屏幕缓慢移动到最顶端。 //难点：我们以前是移动盒子，现在是移动屏幕，我们没有学过如何移动屏幕。 // 技术点：window.scrollTo(x,y);浏览器显示区域跳转到指定的坐标 //步骤： //1.老三步 var img = document.getElementsByTagName(\"img\")[0]; window.onscroll = function () &#123; //被卷去的距离大于200显示小火箭，否则隐藏 //2.显示隐藏小火箭 if (scroll().top &gt; 1000) &#123; img.style.display = \"block\"; &#125; else &#123; img.style.display = \"none\"; &#125; //每次移动滚动条的时候都给leader赋值，模拟leader获取距离顶部的距离 leader = scroll().top; &#125; //3.缓动跳转到页面最顶端（利用我们的缓动动画） var timer = null; var target = 0; //目标位置 var leader = 0; //显示区域自身的位置 img.onclick = function () &#123; //技术点：window.scrollTo(0,0); //要用定时器，先清定时器 clearInterval(timer); timer = setInterval(function () &#123; //获取步长 var step = (target - leader) / 10; //二次处理步长 step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); leader = leader + step; //往上移动的过程中，step是负数。当前位置减去步长，就等于下一步的位置。 //显示区域移动 window.scrollTo(0, leader); //清除定时器 if (leader === 0) &#123; clearInterval(timer); &#125; &#125;, 25); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=\"images/Top.jpg\"/&gt;&lt;div&gt; 我是最顶端.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; （2）tools.js: 123456789101112131415161718192021222324/** * Created by smyhvae on 2015/12/8. *///函数：获取scrollTop和scrollLeft的值function scroll() &#123; // 开始封装自己的scrollTop if (window.pageYOffset != null) &#123; // ie9+ 高版本浏览器 // 因为 window.pageYOffset 默认的是 0 所以这里需要判断 return &#123; left: window.pageXOffset, top: window.pageYOffset &#125; &#125; else if (document.compatMode === \"CSS1Compat\") &#123; // 标准浏览器 来判断有没有声明DTD return &#123; left: document.documentElement.scrollLeft, top: document.documentElement.scrollTop &#125; &#125; return &#123; // 未声明 DTD left: document.body.scrollLeft, top: document.body.scrollTop &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"client相关属性","slug":"30-client-可视区","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T10:04:52.000Z","comments":true,"path":"2020/04/18/30-client-可视区/","link":"","permalink":"http://yoursite.com/2020/04/18/30-client-%E5%8F%AF%E8%A7%86%E5%8C%BA/","excerpt":"client 家族的组成clientWidth 和 clientHeight元素调用时： clientWidth：获取元素的可见宽度（width + padding）。 clientHeight：获取元素的可见高度（height + padding）。","text":"client 家族的组成clientWidth 和 clientHeight元素调用时： clientWidth：获取元素的可见宽度（width + padding）。 clientHeight：获取元素的可见高度（height + padding）。 body/html 调用时： clientWidth：获取网页可视区域宽度。 clientHeight：获取网页可视区域高度。 声明： clientWidth 和 clientHeight 属性是只读的，不可修改。 clientWidth 和 clientHeight 的值都是不带 px 的，返回的都是一个数字，可以直接进行计算。 clientX 和 clientYevent调用： clientX：鼠标距离可视区域左侧距离。 clientY：鼠标距离可视区域上侧距离。 clientTop 和 clientLeft clientTop：盒子的上border。 clientLeft：盒子的左border。 三大家族 offset/scroll/client 的区别区别1：宽高 offsetWidth = width + padding + border offsetHeight = height + padding + border scrollWidth = 内容宽度（不包含border） scrollHeight = 内容高度（不包含border） clientWidth = width + padding clientHeight = height + padding 区别2：上左offsetTop/offsetLeft： 调用者：任意元素。(盒子为主) 作用：距离父系盒子中带有定位的距离。 scrollTop/scrollLeft： 调用者：document.body.scrollTop（window调用）(盒子也可以调用，但必须有滚动条) 作用：浏览器无法显示的部分（被卷去的部分）。 clientY/clientX： 调用者：event 作用：鼠标距离浏览器可视区域的距离（左、上）。 函数封装：获取浏览器的宽高（可视区域）函数封装如下： 12345678910111213141516171819202122//函数封装：获取屏幕可视区域的宽高function client() &#123; if (window.innerHeight !== undefined) &#123; //ie9及其以上的版本的写法 return &#123; \"width\": window.innerWidth, \"height\": window.innerHeight &#125; &#125; else if (document.compatMode === \"CSS1Compat\") &#123; //标准模式的写法（有DTD时） return &#123; \"width\": document.documentElement.clientWidth, \"height\": document.documentElement.clientHeight &#125; &#125; else &#123; //没有DTD时的写法 return &#123; \"width\": document.body.clientWidth, \"height\": document.body.clientHeight &#125; &#125;&#125; 案例：根据浏览器的可视宽度，给定不同的背景的色。 PS：这个可以用来做响应式。 代码如下：（需要用到上面的封装好的方法） 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=\"tools.js\"&gt;&lt;/script&gt;&lt;script&gt; //需求：浏览器每次更改大小，判断是否符合某一标准然后给背景上色。 // // &gt;960红色，大于640小于960蓝色，小于640绿色。 window.onresize = fn; //页面大小发生变化时，执行该函数。 //页面加载的时候直接执行一次函数，确定浏览器可视区域的宽，给背景上色 fn(); //封装成函数，然后指定的时候去调用和绑定函数名 function fn() &#123; if (client().width &gt; 960) &#123; document.body.style.backgroundColor = \"red\"; &#125; else if (client().width &gt; 640) &#123; document.body.style.backgroundColor = \"blue\"; &#125; else &#123; document.body.style.backgroundColor = \"green\"; &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上当代码中，window.onresize事件指的是：在窗口或框架被调整大小时发生。各个事件的解释如下： window.onscroll 屏幕滑动 window.onresize 浏览器大小变化 window.onload 页面加载完毕 div.onmousemove 鼠标在盒子上移动（注意：不是盒子移动） 获取显示器的分辨率比如，我的电脑的显示器分辨率是：1920*1080。 获取显示器的分辨率： 123window.onresize = function () &#123; document.title = window.screen.width + \" \" + window.screen.height;&#125; 上图中，不管我如何改变浏览器的窗口大小，title栏显示的值永远都是我的显示器分辨率：1920*1080。 pageX,clientX,screenX,offsetX区别pageX/pageY: 鼠标相对于整个页面的X/Y坐标。 注意，整个页面的意思就是你整个网页的全部，比如说网页很宽很长，宽2000px，高3000px，那pageX,pageY的最大值就是它们了。 特别说明：IE不支持！ clientX/clientY： 事件发生时鼠标在浏览器内容区域的X/Y坐标（不包含滚动条）。 浏览器内容区域即浏览器窗口中用来显示网页的可视区域，注意这个可视，也就是说需要拖动滚动条才能看到的区域不算。 当你将浏览器窗口缩小时，clientX/clientY的最大值也会缩小，但始终，它们的最大值不会超过你浏览器可视区域。 特别说明：IE下此属性不规范，它们的最小值不是0而是2，也就是说IE下的clientX/clientY比火狐下始终大2px。 screenX/screenY: 鼠标在屏幕上的坐标。screenX,screenY的最大值不会超过屏幕分辨率。 offsetX/offsetY: 特别说明：只有IE支持！相当于IE下的pageX,pageY。 总结","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"事件绑定和事件对象Event","slug":"31-事件的绑定和事件对象Event","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T10:04:46.000Z","comments":true,"path":"2020/04/18/31-事件的绑定和事件对象Event/","link":"","permalink":"http://yoursite.com/2020/04/18/31-%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%BB%91%E5%AE%9A%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1Event/","excerpt":"绑定事件的两种方式/DOM事件的级别DOM的写法：onclick","text":"绑定事件的两种方式/DOM事件的级别DOM的写法：onclick 123element.onclick = function () &#123;&#125; 举例： 12345678910111213141516&lt;body&gt;&lt;button&gt;点我&lt;/button&gt;&lt;script&gt; var btn = document.getElementsByTagName(\"button\")[0]; //这种事件绑定的方式，如果绑定多个，则后面的会覆盖掉前面的 btn.onclick = function () &#123; console.log(\"事件1\"); &#125; btn.onclick = function () &#123; console.log(\"事件2\"); &#125;&lt;/script&gt;&lt;/body&gt; 点击按钮后，上方代码的打印结果： 1事件2 我们可以看到，DOM对象.事件 = 函数的这种绑定事件的方式：一个元素的一个事件只能绑定一个响应函数。如果绑定了多个响应函数，则后者会覆盖前者。 DOM2的写法：addEventListener（高版本浏览器）123element.addEventListener('click', function () &#123;&#125;, false); 参数解释： 参数1：事件名的字符串(注意，没有on) 参数2：回调函数：当事件触发时，该函数会被执行 参数3：true表示捕获阶段触发，false表示冒泡阶段触发（默认）。如果不写，则默认为false。【重要】 举例： 1234567891011121314151617181920&lt;body&gt;&lt;button&gt;按钮&lt;/button&gt;&lt;script&gt; var btn = document.getElementsByTagName(\"button\")[0]; // addEventListener: 事件监听器。 原事件被执行的时候，后面绑定的事件照样被执行 // 这种写法不存在响应函数被覆盖的情况。（更适合团队开发） btn.addEventListener(\"click\", fn1); btn.addEventListener(\"click\", fn2); function fn1() &#123; console.log(\"事件1\"); &#125; function fn2() &#123; console.log(\"事件2\"); &#125;&lt;/script&gt;&lt;/body&gt; 点击按钮后，上方代码的打印结果： 12事件1事件2 我们可以看到，addEventListener()这种绑定事件的方式： 一个元素的一个事件，可以绑定多个响应函数。不存在响应函数被覆盖的情况。执行顺序是：事件被触发时，响应函数会按照函数的绑定顺序执行。 addEventListener()中的this，是绑定事件的对象。 addEventListener()不支持 IE8 及以下的浏览器。在IE8中可以使用attachEvent来绑定事件（详见下一小段）。 DOM2的写法：attachEvent（IE8及以下版本浏览器）123element.attachEvent('onclick', function () &#123;&#125;); 参数解释： 参数1：事件名的字符串(注意，有on) 参数2：回调函数：当事件触发时，该函数会被执行 举例： 1234567891011121314&lt;body&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;script&gt; var btn = document.getElementsByTagName('button')[0]; btn.attachEvent('onclick', function() &#123; console.log('事件1'); &#125;); btn.attachEvent('onclick', function() &#123; console.log('事件2'); &#125;); &lt;/script&gt;&lt;/body&gt; 在低版本的IE浏览器上，点击按钮后，上方代码的打印结果： 12事件2事件1 我们可以看到，attachEvent()这种绑定事件的方式： 一个元素的一个事件，可以绑定多个响应函数。不存在响应函数被覆盖的情况。注意：执行顺序是，后绑定的先执行。 attachEvent()中的this，是window 兼容性写法上面的内容里，需要强调的是： addEventListener()中的this，是绑定事件的对象。 attachEvent()中的this，是window。 既然这两个写法的this不同，那么，有没有一种兼容性的写法可以确保这两种绑定方式的this是相同的呢？我们可以封装一下。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;body&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;script&gt; var btn = document.getElementsByTagName('button')[0]; myBind(btn , \"click\" , function()&#123; alert(this); &#125;); //定义一个函数，用来为指定元素绑定响应函数 /* * addEventListener()中的this，是绑定事件的对象 * attachEvent()中的this，是window * 需要统一两个方法this */ /* * 参数： * element 要绑定事件的对象 * eventStr 事件的字符串(不要on) * callback 回调函数 */ function myBind(element , eventStr , callback)&#123; if(element.addEventListener)&#123; //大部分浏览器兼容的方式 element.addEventListener(eventStr , callback , false); &#125;else&#123; /* * this是谁，由调用方式决定 * callback.call(element) */ //IE8及以下 element.attachEvent(\"on\"+eventStr , function()&#123; //在匿名函数 function 中调用回调函数callback callback.call(element); &#125;); &#125; &#125; &lt;/script&gt;&lt;/body&gt; 事件对象当事件的响应函数被触发时，会产生一个事件对象event。浏览器每次都会将这个事件event作为实参传进之前的响应函数。 这个对象中包含了与当前事件相关的一切信息。比如鼠标的坐标、键盘的哪个按键被按下、鼠标滚轮滚动的方向等。 获取 event 对象（兼容性问题）所有浏览器都支持event对象，但支持的方式不同。如下。 （1）普通浏览器的写法是 event。比如： （2）ie 678 的写法是 window.event。此时，事件对象 event 是作为window对象的属性保存的。 于是，我们可以采取一种兼容性的写法。如下： 1event = event || window.event; // 兼容性写法 代码举例： 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; //点击页面的任何部分 document.onclick = function (event) &#123; event = event || window.event; ////兼容性写法 console.log(event); console.log(event.timeStamp); console.log(event.bubbles); console.log(event.button); console.log(event.pageX); console.log(event.pageY); console.log(event.screenX); console.log(event.screenY); console.log(event.target); console.log(event.type); console.log(event.clientX); console.log(event.clientY); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; event 属性event 有很多属性 由于pageX 和 pageY的兼容性不好，我们可以这样做： 鼠标在页面的位置 = 滚动条滚动的距离 + 可视区域的坐标。 Event举例举例1：使 div 跟随鼠标移动代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; #box1 &#123; width: 100px; height: 100px; background-color: red; /* * 开启box1的绝对定位 */ position: absolute; &#125; &lt;/style&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function() &#123; /* * 使div可以跟随鼠标移动 */ //获取box1 var box1 = document.getElementById(\"box1\"); //给整个页面绑定：鼠标移动事件 document.onmousemove = function(event) &#123; //兼容的方式获取event对象 event = event || window.event; // 鼠标在页面的位置 = 滚动条滚动的距离 + 可视区域的坐标。 var pagex = event.pageX || scroll().left + event.clientX; var pagey = event.pageY || scroll().top + event.clientY; // 设置div的偏移量（相对于整个页面） // 注意，如果想通过 style.left 来设置属性，一定要给 box1开启绝对定位。 box1.style.left = pagex + \"px\"; box1.style.top = pagey + \"px\"; &#125;; &#125;; // scroll 函数封装 function scroll() &#123; return &#123; //此函数的返回值是对象 left: window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop, right: window.pageXOffset || document.body.scrollLeft || document.documentElement.scrollLeft &#125;; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body style=\"height: 1000px;width: 2000px;\"&gt; &lt;div id=\"box1\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 举例2：获取鼠标距离所在盒子的距离关键点： 1鼠标距离所在盒子的距离 &#x3D; 鼠标在整个页面的位置 - 所在盒子在整个页面的位置 代码演示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .box &#123; width: 300px; height: 200px; padding-top: 100px; background-color: pink; margin: 100px; text-align: center; font: 18px/30px \"simsun\"; cursor: pointer; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"box\"&gt;&lt;/div&gt;&lt;script src=\"animate.js\"&gt;&lt;/script&gt;&lt;script&gt; //需求：鼠标进入盒子之后只要移动，哪怕1像素，随时显示鼠标在盒子中的坐标。 //技术点：新事件，onmousemove：在事件源上，哪怕鼠标移动1像素也会触动这个事件。 //一定程度上，模拟了定时器 //步骤： //1.老三步和新五步 //2.获取鼠标在整个页面的位置 //3.获取盒子在整个页面的位置 //4.用鼠标的位置减去盒子的位置赋值给盒子的内容。 //1.老三步和新五步 var div = document.getElementsByTagName(\"div\")[0]; div.onmousemove = function (event) &#123; event = event || window.event; //2.获取鼠标在整个页面的位置 var pagex = event.pageX || scroll().left + event.clientX; var pagey = event.pageY || scroll().top + event.clientY; //3.获取盒子在整个页面的位置 // var xx = // var yy = //4.用鼠标的位置减去盒子的位置赋值给盒子的内容。 var targetx = pagex - div.offsetLeft; var targety = pagey - div.offsetTop; this.innerHTML = \"鼠标在盒子中的X坐标为：\" + targetx + \"px;&lt;br&gt;鼠标在盒子中的Y坐标为：\" + targety + \"px;\" &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 举例3：商品放大镜代码实现： （1）index.html: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .box &#123; width: 350px; height: 350px; margin: 100px; border: 1px solid #ccc; position: relative; &#125; .big &#123; width: 400px; height: 400px; position: absolute; top: 0; left: 360px; border: 1px solid #ccc; overflow: hidden; display: none; &#125; /*mask的中文是：遮罩*/ .mask &#123; width: 175px; height: 175px; background: rgba(255, 255, 0, 0.4); position: absolute; top: 0; left: 0; cursor: move; display: none; &#125; .small &#123; position: relative; &#125; img &#123; vertical-align: top; &#125; &lt;/style&gt; &lt;script src=\"tools.js\"&gt;&lt;/script&gt; &lt;script&gt; window.onload = function () &#123; //需求：鼠标放到小盒子上，让大盒子里面的图片和我们同步等比例移动。 //技术点：onmouseenter==onmouseover 第一个不冒泡 //技术点：onmouseleave==onmouseout 第一个不冒泡 //步骤： //1.鼠标放上去显示盒子，移开隐藏盒子。 //2.老三步和新五步（黄盒子跟随移动） //3.右侧的大图片，等比例移动。 //0.获取相关元素 var box = document.getElementsByClassName(\"box\")[0]; var small = box.firstElementChild || box.firstChild; var big = box.children[1]; var mask = small.children[1]; var bigImg = big.children[0]; //1.鼠标放上去显示盒子，移开隐藏盒子。(为小盒子绑定事件) small.onmouseenter = function () &#123; //封装好方法调用：显示元素 show(mask); show(big); &#125; small.onmouseleave = function () &#123; //封装好方法调用：隐藏元素 hide(mask); hide(big); &#125; //2.老三步和新五步（黄盒子跟随移动） //绑定的事件是onmousemove，而事件源是small(只要在小盒子上移动1像素，黄盒子也要跟随) small.onmousemove = function (event) &#123; //新五步 event = event || window.event; //想要移动黄盒子，必须要知道鼠标在small小图中的位置。 var pagex = event.pageX || scroll().left + event.clientX; var pagey = event.pageY || scroll().top + event.clientY; //x：mask的left值，y：mask的top值。 var x = pagex - box.offsetLeft - mask.offsetWidth / 2; //除以2，可以保证鼠标mask的中间 var y = pagey - box.offsetTop - mask.offsetHeight / 2; //限制换盒子的范围 //left取值为大于0，小盒子的宽-mask的宽。 if (x &lt; 0) &#123; x = 0; &#125; if (x &gt; small.offsetWidth - mask.offsetWidth) &#123; x = small.offsetWidth - mask.offsetWidth; &#125; //top同理。 if (y &lt; 0) &#123; y = 0; &#125; if (y &gt; small.offsetHeight - mask.offsetHeight) &#123; y = small.offsetHeight - mask.offsetHeight; &#125; //移动黄盒子 console.log(small.offsetHeight); mask.style.left = x + \"px\"; mask.style.top = y + \"px\"; //3.右侧的大图片，等比例移动。 //如何移动大图片？等比例移动。 // 大图片/大盒子 = 小图片/mask盒子 // 大图片走的距离/mask走的距离 = （大图片-大盒子）/（小图片-黄盒子）// var bili = (bigImg.offsetWidth-big.offsetWidth)/(small.offsetWidth-mask.offsetWidth); //大图片走的距离/mask盒子都的距离 = 大图片/小图片 var bili = bigImg.offsetWidth / small.offsetWidth; var xx = bili * x; //知道比例，就可以移动大图片了 var yy = bili * y; bigImg.style.marginTop = -yy + \"px\"; bigImg.style.marginLeft = -xx + \"px\"; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"box\"&gt; &lt;div class=\"small\"&gt; &lt;img src=\"images/001.jpg\" alt=\"\"/&gt; &lt;div class=\"mask\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"big\"&gt; &lt;img src=\"images/0001.jpg\" alt=\"\"/&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; （2）tools.js: 1234567891011121314151617181920212223242526272829303132/** * Created by smyhvae on 2018/02/03. *///显示和隐藏function show(ele) &#123; ele.style.display = \"block\";&#125;function hide(ele) &#123; ele.style.display = \"none\";&#125;function scroll() &#123; // 开始封装自己的scrollTop if (window.pageYOffset != null) &#123; // ie9+ 高版本浏览器 // 因为 window.pageYOffset 默认的是 0 所以这里需要判断 return &#123; left: window.pageXOffset, top: window.pageYOffset &#125; &#125; else if (document.compatMode === \"CSS1Compat\") &#123; // 标准浏览器 来判断有没有声明DTD return &#123; left: document.documentElement.scrollLeft, top: document.documentElement.scrollTop &#125; &#125; return &#123; // 未声明 DTD left: document.body.scrollLeft, top: document.body.scrollTop &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"事件的传播和事件冒泡","slug":"32-事件的传播和事件冒泡","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T10:04:36.000Z","comments":true,"path":"2020/04/18/32-事件的传播和事件冒泡/","link":"","permalink":"http://yoursite.com/2020/04/18/32-%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BC%A0%E6%92%AD%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1/","excerpt":"DOM事件流事件传播的三个阶段是：事件捕获、事件冒泡和目标。 事件捕获阶段：事件从祖先元素往子元素查找（DOM树结构），直到捕获到事件目标 target。在这个过程中，默认情况下，事件相应的监听函数是不会被触发的。 事件目标：当到达目标元素之后，执行目标元素该事件相应的处理函数。如果没有绑定监听函数，那就不执行。 事件冒泡阶段：事件从事件目标 target 开始，从子元素往祖先元素冒泡，直到页面的最上一级标签。","text":"DOM事件流事件传播的三个阶段是：事件捕获、事件冒泡和目标。 事件捕获阶段：事件从祖先元素往子元素查找（DOM树结构），直到捕获到事件目标 target。在这个过程中，默认情况下，事件相应的监听函数是不会被触发的。 事件目标：当到达目标元素之后，执行目标元素该事件相应的处理函数。如果没有绑定监听函数，那就不执行。 事件冒泡阶段：事件从事件目标 target 开始，从子元素往祖先元素冒泡，直到页面的最上一级标签。 如下图所示： 事件捕获addEventListener可以捕获事件： 123box1.addEventListener(\"click\", function () &#123; alert(\"捕获 box3\");&#125;, true); 上面的方法中，参数为true，代表事件在捕获阶段执行。 代码演示： 12345678910111213141516//参数为true，代表事件在「捕获」阶段触发；参数为false或者不写参数，代表事件在「冒泡」阶段触发box3.addEventListener(\"click\", function () &#123; alert(\"捕获 child\");&#125;, true);box2.addEventListener(\"click\", function () &#123; alert(\"捕获 father\");&#125;, true);box1.addEventListener(\"click\", function () &#123; alert(\"捕获 grandfather\");&#125;, true);document.addEventListener(\"click\", function () &#123; alert(\"捕获 body\");&#125;, true); 重点：捕获阶段，事件依次传递的顺序是：window –&gt; document –&gt; html–&gt; body –&gt; 父元素、子元素、目标元素。 这几个元素在事件捕获阶段的完整写法是： 1234567891011121314151617181920212223window.addEventListener(\"click\", function () &#123; alert(\"捕获 window\");&#125;, true);document.addEventListener(\"click\", function () &#123; alert(\"捕获 document\");&#125;, true);document.documentElement.addEventListener(\"click\", function () &#123; alert(\"捕获 html\");&#125;, true);document.body.addEventListener(\"click\", function () &#123; alert(\"捕获 body\");&#125;, true);fatherBox.addEventListener(\"click\", function () &#123; alert(\"捕获 father\");&#125;, true);childBox.addEventListener(\"click\", function () &#123; alert(\"捕获 child\");&#125;, true); 说明： （1）第一个接收到事件的对象是 window（有人会说body，有人会说html，这都是错误的）。 （2）JS中涉及到DOM对象时，有两个对象最常用：window、doucument。它们俩是最先获取到事件的。 补充一个知识点： 在 js中： 如果想获取 html节点，方法是document.documentElement。 如果想获取 body 节点，方法是：document.body。 二者不要混淆了。 事件冒泡事件冒泡: 当一个元素上的事件被触发的时候（比如说鼠标点击了一个按钮），同样的事件将会在那个元素的所有祖先元素中被触发。这一过程被称为事件冒泡；这个事件从原始元素开始一直冒泡到DOM树的最上层。 通俗来讲，冒泡指的是：子元素的事件被触发时，父元素的同样的事件也会被触发。取消冒泡就是取消这种机制。 代码演示： 12345678910111213141516//事件冒泡box3.onclick = function () &#123; alert(\"child\");&#125;box2.onclick = function () &#123; alert(\"father\");&#125;box1.onclick = function () &#123; alert(\"grandfather\");&#125;document.onclick = function () &#123; alert(\"body\");&#125; 上图显示，当我点击子元素 box3 的时候，它的父元素box2、box1、body都依次被触发了。即使我改变代码的顺序，也不会影响效果的顺序。 当然，上面的代码中，我们用 addEventListener 这种 DOM2的写法也是可以的，但是第三个参数要写 false，或者不写。 冒泡顺序： 一般的浏览器: （除IE6.0之外的浏览器） div -&gt; body -&gt; html -&gt; document -&gt; window IE6.0： div -&gt; body -&gt; html -&gt; document 不是所有的事件都能冒泡以下事件不冒泡：blur、focus、load、unload、onmouseenter、onmouseleave。意思是，事件不会往父元素那里传递。 我们检查一个元素是否会冒泡，可以通过事件的以下参数： 1event.bubbles 如果返回值为true，说明该事件会冒泡；反之则相反。 举例： 123456box1.onclick = function (event) &#123; alert(\"冒泡 child\"); event = event || window.event; console.log(event.bubbles); //打印结果：true。说明 onclick 事件是可以冒泡的&#125; 阻止冒泡大部分情况下，冒泡都是有益的。当然，如果你想阻止冒泡，也是可以的。可以按下面的方法阻止冒泡。 阻止冒泡的方法w3c的方法：（火狐、谷歌、IE11） 1event.stopPropagation(); IE10以下则是： 1event.cancelBubble = true 兼容代码如下： 12345678910111213box3.onclick = function (event) &#123; alert(\"child\"); //阻止冒泡 event = event || window.event; if (event &amp;&amp; event.stopPropagation) &#123; event.stopPropagation(); &#125; else &#123; event.cancelBubble = true; &#125; &#125; 上方代码中，我们对box3进行了阻止冒泡，产生的效果是：事件不会继续传递到 father、grandfather、body了。 阻止冒泡的举例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; #box1 &#123; width: 100px; height: 100px; background-color: red; /* * 开启box1的绝对定位 */ position: absolute; &#125; &lt;/style&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function() &#123; /* * 使div可以跟随鼠标移动 */ //获取box1 var box1 = document.getElementById('box1'); //给整个页面绑定：鼠标移动事件 document.onmousemove = function(event) &#123; //兼容的方式获取event对象 event = event || window.event; // 鼠标在页面的位置 = 滚动条滚动的距离 + 可视区域的坐标。 var pagex = event.pageX || scroll().left + event.clientX; var pagey = event.pageY || scroll().top + event.clientY; // 设置div的偏移量（相对于整个页面） // 注意，如果想通过 style.left 来设置属性，一定要给 box1 开启绝对定位。 box1.style.left = pagex + 'px'; box1.style.top = pagey + 'px'; &#125;; // 【重要注释】 // 当 document.onmousemove 和 box2.onmousemove 同时触发时，通过 box2 阻止事件向 document 冒泡。 // 也就是说，只要是在 box2 的区域，就只触发 document.onmousemove 事件 var box2 = document.getElementById('box2'); box2.onmousemove = function(event) &#123; //阻止冒泡 event = event || window.event; if (event &amp;&amp; event.stopPropagation) &#123; event.stopPropagation(); &#125; else &#123; event.cancelBubble = true; &#125; &#125;; &#125;; // scroll 函数封装 function scroll() &#123; return &#123; //此函数的返回值是对象 left: window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop, right: window.pageXOffset || document.body.scrollLeft || document.documentElement.scrollLeft, &#125;; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body style=\"height: 1000px;width: 2000px;\"&gt; &lt;div id=\"box2\" style=\"width: 300px; height: 300px; background-color: #bfa;\"&gt;&lt;/div&gt; &lt;div id=\"box1\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"事件委托","slug":"33-事件委托","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T10:04:32.000Z","comments":true,"path":"2020/04/18/33-事件委托/","link":"","permalink":"http://yoursite.com/2020/04/18/33-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/","excerpt":"事件委托事件委托，通俗地来讲，就是把一个元素响应事件（click、keydown……）的函数委托到另一个元素。","text":"事件委托事件委托，通俗地来讲，就是把一个元素响应事件（click、keydown……）的函数委托到另一个元素。 比如说有一个列表 ul，列表之中有大量的列表项 &lt;a&gt;标签： 12345&lt;ul id=\"parent-list\"&gt; &lt;li&gt;&lt;a href=\"javascript:;\" class=\"my_link\"&gt;超链接一&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"javascript:;\" class=\"my_link\"&gt;超链接二&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"javascript:;\" class=\"my_link\"&gt;超链接三&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 当我们的鼠标移到&lt;a&gt;标签上的时候，需要获取此&lt;a&gt;的相关信息并飘出悬浮窗以显示详细信息，或者当某个&lt;a&gt;被点击的时候需要触发相应的处理事件。我们通常的写法，是为每个&lt;a&gt;都绑定类似onMouseOver或者onClick之类的事件监听： 12345678910window.onload = function()&#123; var parentNode = document.getElementById(\"parent-list\"); var aNodes = parentNode.getElementByTagName(\"a\"); for(var i=0, l = aNodes.length; i &lt; l; i++)&#123; aNodes[i].onclick = function() &#123; console.log('我是超链接 a 的单击相应函数'); &#125; &#125;&#125; 但是，上面的做法过于消耗内存和性能。我们希望，只绑定一次事件，即可应用到多个元素上，即使元素是后来添加的。 因此，比较好的方法就是把这个点击事件绑定到他的父层，也就是 ul 上，然后在执行事件函数的时候再去匹配判断目标元素。如下： 1234567891011121314151617181920212223242526272829303132 &lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function() &#123; // 获取父节点，并为它绑定click单击事件。 false 表示事件在冒泡阶段触发（默认） document.getElementById('parent-list').addEventListener('click', function(event) &#123; event = event || window.event; // e.target 表示：触发事件的对象 //如果触发事件的对象是我们期望的元素，则执行否则不执行 if (event.target &amp;&amp; event.target.className == 'link') &#123; // 或者写成 if (event.target &amp;&amp; event.target.nodeName.toUpperCase() == 'A') &#123; console.log('我是ul的单击响应函数'); &#125; &#125;, false); &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id=\"parent-list\" style=\"background-color: #bfa;\"&gt; &lt;li&gt; &lt;p&gt;我是p元素&lt;/p&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=\"javascript:;\" class=\"link\"&gt;超链接一&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"javascript:;\" class=\"link\"&gt;超链接二&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"javascript:;\" class=\"link\"&gt;超链接三&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; 上方代码，为父节点注册 click 事件，当子节点被点击的时候，click事件会从子节点开始向父节点冒泡。父节点捕获到事件之后，开始执行方法体里的内容：通过判断 event.target 拿到了被点击的子节点&lt;a&gt;。从而可以获取到相应的信息，并作处理。 换而言之，参数为false，说明事件是在冒泡阶段触发（子元素向父元素传递事件）。而父节点注册了事件函数，子节点没有注册事件函数，此时，会在父节点中执行函数体里的代码。 总结：事件委托是利用了冒泡机制，减少了事件绑定的次数，减少内存消耗，提高性能。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"定时器typeof和数据类型转换","slug":"36-定时器","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-20T01:33:12.000Z","comments":true,"path":"2020/04/18/36-定时器/","link":"","permalink":"http://yoursite.com/2020/04/18/36-%E5%AE%9A%E6%97%B6%E5%99%A8/","excerpt":"定时器的常见方法 setInterval()：循环调用。将一段代码，每隔一段时间执行一次。（循环执行） setTimeout()：延时调用。将一段代码，等待一段时间之后再执行。（只执行一次）","text":"定时器的常见方法 setInterval()：循环调用。将一段代码，每隔一段时间执行一次。（循环执行） setTimeout()：延时调用。将一段代码，等待一段时间之后再执行。（只执行一次） 备注：在实际开发中，二者是可以根据需要，互相替代的。 setInterval() 的使用setInterval()：循环调用。将一段代码，每隔一段时间执行一次。（循环执行） 参数： 参数1：回调函数，该函数会每隔一段时间被调用一次。 参数2：每次调用的间隔时间，单位是毫秒。 返回值：返回一个Number类型的数据。这个数字用来作为定时器的唯一标识，方便用来清除定时器。 定义定时器方式一：匿名函数 每间隔一秒，将 数字 加1： 12345 let num = 1;setInterval(function () &#123; num ++; console.log(num);&#125;, 1000); 方式二： 每间隔一秒，将 数字 加1： 12345setInterval(fn,1000); num ++; console.log(num);&#125; 清除定时器定时器的返回值是作为这个定时器的唯一标识，可以用来清除定时器。具体方法是：假设定时器setInterval()的返回值是参数1，那么clearInterval(参数1)就可以清除定时器。 setTimeout()的道理是一样的。 代码举例： 123456789101112&lt;script&gt; let num = 1; const timer = setInterval(function () &#123; console.log(num); //每间隔一秒，打印一次num的值 num ++; if(num === 5) &#123; //打印四次之后，就清除定时器 clearInterval(timer); &#125; &#125;, 1000);&lt;/script&gt; setTimeout() 的使用setTimeout()：延时调用。将一段代码，等待一段时间之后再执行。（只执行一次） 参数： 参数1：回调函数，该函数会每隔一段时间被调用一次。 参数2：每次调用的间隔时间，单位是毫秒。 返回值：返回一个Number类型的数据。这个数字用来作为定时器的唯一标识，方便用来清除定时器。 定义和清除定时器代码举例： 12345const timer = setTimeout(function() &#123; console.log(1); // 3秒之后，再执行这段代码。&#125;, 3000);clearTimeout(timer); 代码举例：（箭头函数写法） 123setTimeout(() =&gt; &#123; console.log(1); // 3秒之后，再执行这段代码。&#125;, 3000); setTimeout() 举例：5秒后关闭网页两侧的广告栏假设网页两侧的广告栏为两个img标签，它们的样式为： 12345&lt;style&gt; ... ...&lt;/style&gt; 5秒后关闭广告栏的js代码为： 123456789101112&lt;script&gt; window.onload = function () &#123; //获取相关元素 var imgArr = document.getElementsByTagName(\"img\"); //设置定时器：5秒后关闭两侧的广告栏 setTimeout(fn,5000); function fn()&#123; imgArr[0].style.display = \"none\"; imgArr[1].style.display = \"none\"; &#125; &#125;&lt;/script&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"BOM简介","slug":"35-BOM简介和navigator.userAgent&History&Location","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T10:05:40.000Z","comments":true,"path":"2020/04/18/35-BOM简介和navigator.userAgent&History&Location/","link":"","permalink":"http://yoursite.com/2020/04/18/35-BOM%E7%AE%80%E4%BB%8B%E5%92%8Cnavigator.userAgent&History&Location/","excerpt":"常见概念JavaScript的组成JavaScript基础分为三个部分： ECMAScript：JavaScript的语法标准。包括变量、表达式、运算符、函数、if语句、for语句等。 DOM：文档对象模型（Document object Model），操作网页上的元素的API。比如让盒子移动、变色、轮播图等。 BOM：浏览器对象模型（Browser Object Model），操作浏览器部分功能的API。比如让浏览器自动滚动。","text":"常见概念JavaScript的组成JavaScript基础分为三个部分： ECMAScript：JavaScript的语法标准。包括变量、表达式、运算符、函数、if语句、for语句等。 DOM：文档对象模型（Document object Model），操作网页上的元素的API。比如让盒子移动、变色、轮播图等。 BOM：浏览器对象模型（Browser Object Model），操作浏览器部分功能的API。比如让浏览器自动滚动。 常见的 BOM 对象 BOM可以让我们通过JS来操作浏览器。BOM中为我们提供了一些对象，来完成对浏览器相关的操作。 常见的 BOM对象有： Window：代表整个浏览器的窗口，同时 window 也是网页中的全局对象。 Navigator：代表当前浏览器的信息，通过该对象可以识别不同的浏览器。 Location：代表当前浏览器的地址栏信息，通过 Location 可以获取地址栏信息，或者操作浏览器跳转页面。 History：代表浏览器的历史记录，通过该对象可以操作浏览器的历史记录。由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页，而且该操作只在当次访问时有效。 Screen：代表用户的屏幕信息，通过该对象可以获取用户的显示器的相关信息。 备注：这些 BOM 对象都是作为 window 对象的属性保存的，可以通过window对象来使用，也可以直接使用。比如说，我可以使用 window.location.href，也可以直接使用 location.href，二者是等价的。 备注2：不要忘了，之前学习过的document也是在window中保存的。 这篇文章，我们先来讲一下 几个常见的 BOM 对象。 Navigator 和 navigator.userAgentNavigator代表当前浏览器的信息，通过该对象可以识别不同的浏览器。 由于历史原因，Navigator对象中的大部分属性都已经不能帮助我们识别浏览器了。 一般我们只会使用navigator.userAgent来获取浏览器的信息。 userAgent 的值是一个字符串，简称 UA，这个字符串中包含了用来描述浏览器信息的内容，不同的浏览器会有不同的userAgent。 代码举例：（获取当前浏览器的UA） 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var ua = navigator.userAgent; // 获取当前浏览器的 userAgent console.log('qianguyihao 当前浏览器的UA是：' + ua); if (/firefox/i.test(ua)) &#123; alert('是火狐浏览器'); &#125; else if (/chrome/i.test(ua)) &#123; alert('是Chrome浏览器'); &#125; else if (/msie/i.test(ua)) &#123; alert('是IE浏览器'); &#125; else if ('ActiveXObject' in window) &#123; alert('是 IE11 浏览器'); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 在电脑上模拟移动端浏览器不同浏览器（包括微信内置的浏览器）的 userAgent 信息，是不一样的，我们可以根据 navigator.userAgent属性来获取。 比如说，我们在电脑浏览器上，按F12，然后在控制台输入navigator.userAgent， MacOS上的Chrome浏览器的 userAgent 是： 1&quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;66.0.3359.117 Safari&#x2F;537.36&quot; 我们还可以在电脑浏览器的控制台里可以添加很多设备，通过这种方式，可以模拟移动端浏览器的场景，非常有用，请务必掌握。操作如下： （1）需要点击 edit，手动添加： （2）添加时，根据 User agent 来识别不同的浏览器： 不同浏览器的 userAgentiOS 版微信浏览器： 1Mozilla&#x2F;5.0 (iPhone; CPU iPhone OS 9_3 like Mac OS X) AppleWebKit&#x2F;601.1.46 (KHTML, like Gecko) Mobile&#x2F;13E233 MicroMessenger&#x2F;6.3.15 NetType&#x2F;WIFI Language&#x2F;zh_CN Android 版微信浏览器： 1Mozilla&#x2F;5.0 (Linux; Android 5.0.1; GT-I9502 Build&#x2F;LRX22C; wv) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Version&#x2F;4.0 Chrome&#x2F;43.0.2357.121 Mobile Safari&#x2F;537.36 MicroMessenger&#x2F;6.1.0.78_r1129455.543 NetType&#x2F;WIFI iOS 版本QQ浏览器： 1Mozilla&#x2F;5.0 (iPhone; CPU iPhone OS 11_2_2 like Mac OS X) AppleWebKit&#x2F;604.4.7 (KHTML, like Gecko) Mobile&#x2F;15C202 QQ&#x2F;7.3.5.473 V1_IPH_SQ_7.3.5_1_APP_A Pixel&#x2F;1125 Core&#x2F;UIWebView Device&#x2F;Apple(iPhone X) NetType&#x2F;WIFI QBWebViewType&#x2F;1 Android 版 QQ浏览器： 1Mozilla&#x2F;5.0 (Linux; Android 4.4.2; PE-TL20 Build&#x2F;HuaweiPE-TL20; wv) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Version&#x2F;4.0 Chrome&#x2F;57.0.2987.132 MQQBrowser&#x2F;6.2 TBS&#x2F;043807 Mobile Safari&#x2F;537.36 V1_AND_SQ_7.3.2_762_YYB_D QQ&#x2F;7.3.2.3350 NetType&#x2F;WIFI WebP&#x2F;0.3.0 Pixel&#x2F;1080 参考链接： 微信、QQ在Android和iOS的UserAgent 判断微信内置浏览器的UserAgent 微信内置浏览器UserAgent的判断 History 对象History对象：可以用来操作浏览器的向前或向后翻页。 History对象的属性1history.length 解释：获取浏览器历史列表中的 url 数量。注意，只是统计当次的数量，如果浏览器关了，数量会重置为1。 History对象的方法方法1： 1history.back(); 解释：用来回退到上一个页面，作用和浏览器的「回退按钮」一样。 方法2： 1history.forward(); 解释：用来跳转下一个页面，作用和浏览器的「前进按钮」一样。 方法3： 123456789101112history.go( int n); // 需要整数作为参数// 代码举例：history.go( 1 ); // 向前跳转一个页面，相当于 history.forward()history.go( 2 ); // 表示向前跳转两个页面history.go( 0 ); // 刷新当前页面history.go( -1 ); // 向后跳转一个页面，相当于 history.back()history.go( -2 ); // 向后跳转两个页面 解释：向前/向后跳转 n 个页面。 Location 对象Location 对象：封装了浏览器地址栏的 URL 信息。 下面介绍一些常见的属性和方法。 Location 对象的属性属性1： 123location.hreflocation.href &#x3D; &#39;https:&#x2F;&#x2F;xxx&#39;; 解释：获取当前页面的 url 路径（或者设置 url 路径）。 代码举例1： 1console.log(location.href); // 获取当前页面的url 路径 代码举例2： 1location.href = 'www.baidu.com'; // 跳转到指定的页面链接。通俗理解就是：跳转到其他的页面 从上方的举例2中可以看出：如果直接将location.href属性修改为一个绝对路径（或相对路径），则页面会自动跳转到该路径，并生成相应的历史记录。 Location 对象的方法方法1： 1location.assign(str); 解释：用来跳转到其他的页面，作用和直接修改location.href一样。 方法2： 1location.reload(); 解释：用于重新加载当前页面，作用和刷新按钮一样。 代码举例： 12location.reload(); // 重新加载当前页面。location.reload(true); // 在方法的参数中传递一个true，则会强制清空缓存刷新页面。 方法3： 12location.replace(); 解释：使用一个新的页面替换当前页面，调用完毕也会跳转页面。但不会生成历史记录，不能使用「后退按钮」后退。 hash和history的区别 为什么要有 hash 和 history？ 对于 Vue 这类渐进式前端开发框架，为了构建 SPA（单页面应用），需要引入前端路由系统，这也就是 Vue-Router 存在的意义。前端路由的核心，就在于 —— 改变视图的同时不会向后端发出请求。 为了达到这一目的，浏览器当前提供了以下两种支持： hash —— 即地址栏 URL 中的 # 符号（此 hash 不是密码学里的散列运算）。 比如这个 URL：http://www.abc.com/#/hello，hash 的值为 #/hello。它的特点在于：hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。 history —— 利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。（需要特定浏览器支持） 这两个方法应用于浏览器的历史记录栈，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改时，虽然改变了当前的 URL，但浏览器不会立即向后端发送请求。 因此可以说，hash 模式和 history 模式都属于浏览器自身的特性，Vue-Router 只是利用了这两个特性（通过调用浏览器提供的接口）来实现前端路由。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"BOM的常见内置方法和内置对象","slug":"37-BOM的常见内置方法和内置对象","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T10:06:48.000Z","comments":true,"path":"2020/04/18/37-BOM的常见内置方法和内置对象/","link":"","permalink":"http://yoursite.com/2020/04/18/37-BOM%E7%9A%84%E5%B8%B8%E8%A7%81%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E5%92%8C%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/","excerpt":"BOM的介绍JavaScript的组成JavaScript基础分为三个部分： ECMAScript：JavaScript的语法标准。包括变量、表达式、运算符、函数、if语句、for语句等。 DOM：文档对象模型，操作网页上的元素的API。比如让盒子移动、变色、轮播图等。 BOM：浏览器对象模型，操作浏览器部分功能的API。比如让浏览器自动滚动。","text":"BOM的介绍JavaScript的组成JavaScript基础分为三个部分： ECMAScript：JavaScript的语法标准。包括变量、表达式、运算符、函数、if语句、for语句等。 DOM：文档对象模型，操作网页上的元素的API。比如让盒子移动、变色、轮播图等。 BOM：浏览器对象模型，操作浏览器部分功能的API。比如让浏览器自动滚动。 什么是BOM BOM：Browser Object Model，浏览器对象模型。 BOM的结构： window对象是BOM的顶层(核心)对象，所有对象都是通过它延伸出来的，也可以称为window的子对象。 DOM是BOM的一部分。 window对象： window对象是JavaScript中的顶级对象。 全局变量、自定义函数也是window对象的属性和方法。 window对象下的属性和方法调用时，可以省略window。 下面讲一下 BOM 的常见内置方法和内置对象。 弹出系统对话框比如说，alert(1)是window.alert(1)的简写，因为它是window的子方法。 系统对话框有三种： 123alert(); //不同浏览器中的外观是不一样的confirm(); //兼容不好prompt(); //不推荐使用 打开窗口、关闭窗口1、打开窗口： 1window.open(url,target,param) 参数解释： url：要打开的地址。 target：新窗口的位置。可以是：_blank 、_self、 _parent 父框架。 param：新窗口的一些设置。 返回值：新窗口的句柄。 param这个参数，可以填各种各样的参数（），比如： name：新窗口的名称，可以为空 features：属性控制字符串，在此控制窗口的各种属性，属性之间以逗号隔开。 fullscreen= { yes/no/1/0 } 是否全屏，默认no channelmode= { yes/no/1/0 } 是否显示频道栏，默认no toolbar= { yes/no/1/0 } 是否显示工具条，默认no location= { yes/no/1/0 } 是否显示地址栏，默认no。（有的浏览器不一定支持） directories = { yes/no/1/0 } 是否显示转向按钮，默认no status= { yes/no/1/0 } 是否显示窗口状态条，默认no menubar= { yes/no/1/0 } 是否显示菜单，默认no scrollbars= { yes/no/1/0 } 是否显示滚动条，默认yes resizable= { yes/no/1/0 } 是否窗口可调整大小，默认no width=number 窗口宽度（像素单位） height=number 窗口高度（像素单位） top=number 窗口离屏幕顶部距离（像素单位） left=number 窗口离屏幕左边距离（像素单位） 各个参数之间用逗号隔开就行，但我们最好是把它们统一放到json里。 2、关闭窗口：window.close() （1）和（2）的代码举例： 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=\"javascript:;\"&gt;点击我打开一个新的页面&lt;/a&gt;&lt;a href=\"javascript:;\"&gt;点击我关闭本页面&lt;/a&gt;&lt;script&gt; //新窗口 = window.open(地址,是否开新窗口,新窗口的各种参数); var a1 = document.getElementsByTagName(\"a\")[0]; var a2 = document.getElementsByTagName(\"a\")[1]; a1.onclick = function () &#123;//举例1： window.open(\"http://www.jx.com\",\"_blank\"); var json = &#123; \"name\": \"helloworld\", \"fullscreen\": \"no\", \"location\": \"no\", \"width\": \"100px\", \"height\": \"100px\", \"top\": \"100px\", \"left\": \"100px\" &#125;; window.open(\"http://www.baidu.com\", \"_blank\", json); //举例2 &#125; //关闭本页面 a2.onclick = function () &#123; window.close(); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3、新窗口相关： 新窗口.moveTo(5,5) 新窗口.moveBy() 新窗口.resizeTo() window.resizeBy() 代码举例： 12var newWin = window.open(\"demo.html\", \"_blank\", json);newWin.moveTo(500, 500); location对象window.location可以简写成location。location相当于浏览器地址栏，可以将url解析成独立的片段。 location对象的属性 href：跳转 hash 返回url中#后面的内容，包含# host 主机名，包括端口 hostname 主机名 pathname url中的路径部分 protocol 协议 一般是http、https search 查询字符串 location.href属性举例： 举例1：点击盒子时，进行跳转。 12345678910111213&lt;body&gt;&lt;div&gt;smyhvae&lt;/div&gt;&lt;script&gt; var div = document.getElementsByTagName(\"div\")[0]; div.onclick = function () &#123; location.href = \"http://www.baidu.com\"; //点击div时，跳转到指定链接 // window.open(\"http://www.baidu.com\",\"_blank\"); //方式二 &#125;&lt;/script&gt;&lt;/body&gt; 举例2：5秒后自动跳转到百度。 有时候，当我们访问一个不存在的网页时，会提示5秒后自动跳转到指定页面，此时就可以用到location。举例： 123456&lt;script&gt; setTimeout(function () &#123; location.href = \"http://www.baidu.com\"; &#125;, 5000);&lt;/script&gt; location对象的方法 location.assign()：改变浏览器地址栏的地址，并记录到历史中 设置location.href 就会调用assign()。一般使用location.href 进行页面之间的跳转。 location.replace()：替换浏览器地址栏的地址，不会记录到历史中 location.reload()：重新加载 navigator对象window.navigator 的一些属性可以获取客户端的一些信息。 userAgent：系统，浏览器) platform：浏览器支持的系统，win/mac/linux 举例： 12console.log(navigator.userAgent);console.log(navigator.platform);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"键盘事件","slug":"34-键盘事件","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T10:04:22.000Z","comments":true,"path":"2020/04/18/34-键盘事件/","link":"","permalink":"http://yoursite.com/2020/04/18/34-%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6/","excerpt":"鼠标的拖拽事件拖拽的流程： （1）onmousedown：当鼠标在被拖拽元素上按下时，开始拖拽； （2）onmousemove：当鼠标移动时被拖拽元素跟随鼠标移动； （3）onmouseup：当鼠标松开时，被拖拽元素固定在当前位置。","text":"鼠标的拖拽事件拖拽的流程： （1）onmousedown：当鼠标在被拖拽元素上按下时，开始拖拽； （2）onmousemove：当鼠标移动时被拖拽元素跟随鼠标移动； （3）onmouseup：当鼠标松开时，被拖拽元素固定在当前位置。 鼠标的滚轮事件onmousewheel：鼠标滚轮滚动的事件，会在滚轮滚动时触发。但是火狐不支持该属性。 DOMMouseScroll：在火狐中需要使用 DOMMouseScroll 来绑定滚动事件。注意该事件需要通过addEventListener()函数来绑定。 键盘事件事件名onkeydown：按键被按下。 onkeyup：按键被松开。 注意： 如果一直按着某一个按键不松手，那么，onkeydown事件会一直触发。此时，松开键盘，onkeyup事件会执行一次。 当onkeydown连续触发时，第一次和第二次之间会间隔稍微长一点，后续的间隔会非常快。这种设计是为了防止误操作的发生。 键盘事件一般都会绑定给一些可以获取到焦点的对象或者是document。代码举例： 1234567891011121314&lt;body&gt; &lt;script&gt; document.onkeydown = function(event) &#123; event = event || window.event; console.log('qianguyihao 键盘按下了'); &#125;; document.onkeyup = function() &#123; console.log('qianguyihao 键盘松开了'); &#125;; &lt;/script&gt; &lt;input type=\"text\" /&gt;&lt;/body&gt; 判断哪个键盘被按下可以通过event事件对象的keyCode来获取按键的编码。 此外，event事件对象里面还提供了以下几个属性： altKey ctrlKey shiftKey 上面这三个属性，可以用来判断alt、ctrl、和shift是否被按下。如果按下则返回true，否则返回false。代码举例： 12345678910111213&lt;body&gt; &lt;script&gt; document.onkeydown = function(event) &#123; event = event || window.event; console.log('qianguyihao：键盘按下了'); // 判断y和ctrl是否同时被按下 if (event.ctrlKey &amp;&amp; event.keyCode === 89) &#123; console.log('ctrl和y都被按下了'); &#125; &#125;; &lt;/script&gt;&lt;/body&gt; 举例：input 文本框中，禁止输入数字。代码实现： 1234567891011121314151617181920&lt;body&gt; &lt;input type=\"text\" /&gt; &lt;script&gt; //获取input var input = document.getElementsByTagName('input')[0]; input.onkeydown = function(event) &#123; event = event || window.event; //console.log('qianguyihao:' + event.keyCode); //数字 48 - 57 //使文本框中不能输入数字 if (event.keyCode &gt;= 48 &amp;&amp; event.keyCode &lt;= 57) &#123; //在文本框中输入内容，属于onkeydown的默认行为 return false; // 如果在onkeydown中取消了默认行为，则输入的内容，不会出现在文本框中 &#125; &#125;; &lt;/script&gt;&lt;/body&gt; 举例：通过键盘的方向键，移动盒子代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; #box1 &#123; width: 100px; height: 100px; background-color: red; position: absolute; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"box1\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; // 使div可以根据不同的方向键向不同的方向移动 /* * 按左键，div向左移 * 按右键，div向右移 * ... */ //为document绑定一个按键按下的事件 document.onkeydown = function(event) &#123; event = event || window.event; //定义一个变量，来表示移动的速度 var speed = 10; //当用户按了ctrl以后，速度加快 if (event.ctrlKey) &#123; console.log('smyhvae ctrl'); speed = 20; &#125; /* * 37 左 * 38 上 * 39 右 * 40 下 */ switch (event.keyCode) &#123; case 37: //alert(\"向左\"); left值减小 box1.style.left = box1.offsetLeft - speed + 'px'; // 在初始值的基础之上，减去 speed 大小 break; case 39: //alert(\"向右\"); box1.style.left = box1.offsetLeft + speed + 'px'; break; case 38: //alert(\"向上\"); box1.style.top = box1.offsetTop - speed + 'px'; break; case 40: //alert(\"向下\"); box1.style.top = box1.offsetTop + speed + 'px'; break; &#125; &#125;; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 上方代码，待改进的地方： （1）移动盒子时，如果要加速，需要先按方向键，再按Ctrl键。 （2）首次移动盒子时，动作较慢。后续如果学习了定时器相关的内容，可以再改进。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"浅拷贝和深拷贝","slug":"39-浅拷贝和深拷贝","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T10:06:32.000Z","comments":true,"path":"2020/04/18/39-浅拷贝和深拷贝/","link":"","permalink":"http://yoursite.com/2020/04/18/39-%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/","excerpt":"深拷贝和浅拷贝是只针对 Object 和 Array 这样的复杂类型的。","text":"深拷贝和浅拷贝是只针对 Object 和 Array 这样的复杂类型的。 浅拷贝对于对象或数组类型，当我们将a赋值给b，然后更改b中的属性，a也会随着变化。 也就是说，a和b指向了同一块堆内存，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝。 浅拷贝的实现 = Object.assign() 在 MDN 上介绍 Object.assign()：”Object.assign() 方法用于将所有可枚举的属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。”复制一个对象。 1234567var target &#x3D; &#123;a: 1, b: 1&#125;;var copy1 &#x3D; &#123;a: 2, b: 2, c: &#123;ca: 21, cb: 22, cc: 23&#125;&#125;;var copy2 &#x3D; &#123;c: &#123;ca: 31, cb: 32, cd: 34&#125;&#125;;var result &#x3D; Object.assign(target, copy1, copy2);console.log(target); &#x2F;&#x2F; &#123;a: 2, b: 2, c: &#123;ca: 31, cb: 32, cc: 33&#125;&#125;console.log(target &#x3D;&#x3D;&#x3D; result); &#x2F;&#x2F; true 可以看到，Object.assign()拷贝的只是属性值，假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值。所以 Object.assign() 只能用于浅拷贝或是合并对象。这是 Object.assign() 值得注意的地方。 深拷贝那么相应的，如果给b放到新的内存中，将a的各个属性都复制到新内存里，就是深拷贝。 也就是说，当b中的属性有变化的时候，a内的属性不会发生变化。 深拷贝的实现 jQuery.extend() 说到深拷贝，第一想到的就是 jQuery.extend()方法，下面我们简单看下 jQuery.extend()的使用。 jQuery.extend( [deep ], target, object1 [, objectN ] )，其中 deep 为 Boolean 类型，如果是 true，则进行深拷贝。 12345var target &#x3D; &#123;a: 1, b: 1&#125;;var copy1 &#x3D; &#123;a: 2, b: 2, c: &#123;ca: 21, cb: 22, cc: 23&#125;&#125;;var copy2 &#x3D; &#123;c: &#123;ca: 31, cb: 32, cd: 34&#125;&#125;;var result &#x3D; $.extend(true, target, copy1, copy2); &#x2F;&#x2F; 进行深拷贝console.log(target); &#x2F;&#x2F; &#123;a: 2, b: 2, c: &#123;ca: 31, cb: 32, cc: 23, cd: 34&#125;&#125; 12345var target &#x3D; &#123;a: 1, b: 1&#125;;var copy1 &#x3D; &#123;a: 2, b: 2, c: &#123;ca: 21, cb: 22, cc: 23&#125;&#125;;var copy2 &#x3D; &#123;c: &#123;ca: 31, cb: 32, cd: 34&#125;&#125;;var result &#x3D; $.extend(target, copy1, copy2); &#x2F;&#x2F; 不进行深拷贝console.log(target); &#x2F;&#x2F; &#123;a: 2, b: 2, c: &#123;ca: 31, cb: 32, cd:34&#125;&#125; 通过上面的对比可以看出，当使用extend() 进行深拷贝的时候，对象的所有属性都添加到 target 中了。 我们知道了 extend() 可以进行深拷贝，那么 extend() 是如何实现深拷贝的呢？ 先来看下 jQuery.extend() 源码 待续 JSON.parse() 和 JSON.stringify() 1234567var target &#x3D; &#123;a: 1, b: 1, c: &#123;ca: 11, cb: 12, cc: 13&#125;&#125;;var targetCopy &#x3D; JSON.parse(JSON.stringify(target));targetCopy.a &#x3D; 2;targetCopy.c.ca &#x3D; 21;console.log(target); &#x2F;&#x2F; &#123;a: 1, b: 1, c: &#123;ca: 11, cb: 12, cc: 13&#125;&#125;console.log(targetCopy); &#x2F;&#x2F; &#123;a: 2, b: 1, c: &#123;ca: 21, cb: 12, cc: 13&#125;&#125;console.log(target &#x3D;&#x3D;&#x3D; targetCopy); &#x2F;&#x2F; false 可以看到改变 targetCopy 并没有改变原始的 target，继承的属性也没有丢失，因此实现了基本的深拷贝。 但是用JSON.parse() 和 JSON.stringify() 会有一个问题。 JSON.parse() 和 JSON.stringify() 能正确处理的对象只有 Number、String、Array 等能够被 json 表示的数据结构，因此函数这种不能被 json 表示的类型将不能被正确处理。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"创建对象","slug":"38-创建对象","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T10:06:42.000Z","comments":true,"path":"2020/04/18/38-创建对象/","link":"","permalink":"http://yoursite.com/2020/04/18/38-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/","excerpt":"创建对象的几种方式方式一、通过Object","text":"创建对象的几种方式方式一、通过Object 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;01_Object构造函数模式&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--方式一: Object构造函数模式 * 套路: 先创建空Object对象, 再动态添加属性/方法 * 适用场景: 起始时不确定对象内部数据 * 问题: 语句太多--&gt;&lt;script type=\"text/javascript\"&gt; /* 一个人: name:\"Tom\", age: 12 */ // 先创建空Object对象 var p = new Object() p = &#123;&#125; //此时内部数据是不确定的 // 再动态添加属性/方法 p.name = 'Tom' p.age = 12 p.setName = function (name) &#123; this.name = name &#125; //测试 console.log(p.name, p.age) p.setName('Bob') console.log(p.name, p.age)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 方式二：对象字面量1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;02_对象字面量&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--方式二: 对象字面量模式 * 套路: 使用&#123;&#125;创建对象, 同时指定属性/方法 * 适用场景: 起始时对象内部数据是确定的 * 问题: 如果创建多个对象, 有重复代码--&gt;&lt;script type=\"text/javascript\"&gt; var p = &#123; name: 'Tom', age: 12, setName: function (name) &#123; this.name = name &#125; &#125; //测试 console.log(p.name, p.age) p.setName('JACK') console.log(p.name, p.age) var p2 = &#123; //如果创建多个对象代码很重复 name: 'Bob', age: 13, setName: function (name) &#123; this.name = name &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 方式三：工厂模式 方式：通过工厂函数动态创建对象并返回。 返回一个对象的函数，就是工厂函数。 适用场景: 需要创建多个对象。 问题: 对象没有一个具体的类型，都是Object类型。 由于这个问题的存在，工厂模式用得不多。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;03_工厂模式&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--方式三: 工厂模式 * 套路: 通过工厂函数动态创建对象并返回 * 适用场景: 需要创建多个对象 * 问题: 对象没有一个具体的类型, 都是Object类型--&gt;&lt;script type=\"text/javascript\"&gt; function createPerson(name, age) &#123; //返回一个对象的函数===&gt;工厂函数 var obj = &#123; name: name, age: age, setName: function (name) &#123; this.name = name &#125; &#125; return obj &#125; // 创建2个人 var p1 = createPerson('Tom', 12) var p2 = createPerson('Bob', 13) // p1/p2是Object类型 function createStudent(name, price) &#123; var obj = &#123; name: name, price: price &#125; return obj &#125; var s = createStudent('张三', 12000) // s也是Object&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 方式四：自定义构造函数1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;04_自定义构造函数模式&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--方式四: 自定义构造函数模式 * 套路: 自定义构造函数, 通过new创建对象 * 适用场景: 需要创建多个类型确定的对象 * 问题: 每个对象都有相同的数据, 浪费内存--&gt;&lt;script type=\"text/javascript\"&gt; //定义类型 function Person(name, age) &#123; this.name = name this.age = age this.setName = function (name) &#123; this.name = name &#125; &#125; var p1 = new Person('Tom', 12) p1.setName('Jack') console.log(p1.name, p1.age) console.log(p1 instanceof Person) function Student(name, price) &#123; this.name = name this.price = price &#125; var s = new Student('Bob', 13000) console.log(s instanceof Student) var p2 = new Person('JACK', 23) console.log(p1, p2)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 方式四引入了继承。 方式五、原型创建对象模式123456789function Person()&#123;&#125;Person.prototype.name &#x3D; &#39;Nike&#39;;Person.prototype.age &#x3D; 20;Person.prototype.jbo &#x3D; &#39;teacher&#39;;Person.prototype.sayName &#x3D; function()&#123; alert(this.name);&#125;;var person1 &#x3D; new Person();person1.sayName(); 复制代码使用原型创建对象的方式，可以让所有对象实例共享它所包含的属性和方法。如果是使用原型创建对象模式，请看下面代码： 12345678910function Person()&#123;&#125;Person.prototype.name &#x3D; &#39;Nike&#39;;Person.prototype.age &#x3D; 20;Person.prototype.jbo &#x3D; &#39;teacher&#39;;Person.prototype.sayName &#x3D; function()&#123; alert(this.name);&#125;;var person1 &#x3D; new Person();var person2 &#x3D; new Person();person1.name &#x3D;&#39;Greg&#39;;alert(person1.name); &#x2F;&#x2F;&#39;Greg&#39; --来自实例alert(person2.name); &#x2F;&#x2F;&#39;Nike&#39; --来自原型 复制代码前面的例子中，每添加一个属性和方法都要敲一遍Person.prototype。为减少不必要的输入，从视觉上更好封装原型的功能。常见的做法： 12345678function Person()&#123;&#125;Person.prototype&#x3D;&#123;name:&quot;NIke&quot;,age:11,sayName:function()&#123;alert(this.name); &#125;&#125;; 在上面的代码中，我们将Person.prototype设置为等于一个以对象字面量形式创建新对象，最终结果相同，但有一个例外：constructor属性不在指向Person了。原型prototype","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"lazyload&防抖和节流","slug":"40-lazyload&防抖和节流","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T04:02:44.000Z","comments":true,"path":"2020/04/18/40-lazyload&防抖和节流/","link":"","permalink":"http://yoursite.com/2020/04/18/40-lazyload&%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/","excerpt":"lazyload用的最多的场景是： 图片lazyload 组件lazyload 现在一般都单独做css的lazyload或者js的lazyload，因为这种方式，其实还是要加载图片和组件。","text":"lazyload用的最多的场景是： 图片lazyload 组件lazyload 现在一般都单独做css的lazyload或者js的lazyload，因为这种方式，其实还是要加载图片和组件。 图片lazyload图片一般是页面最大的资源，所以非首屏延迟加载很重要（让首屏尽快显示）。 防抖（Debouncing）和节流（Throtting） 函数防抖和函数节流：优化高频率执行js代码的一种手段，js中的一些事件如浏览器的resize、scroll，鼠标的mousemove、mouseover，input输入框的keypress等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能。为了优化体验，需要对这类事件进行调用次数的限制。 防抖在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。 根据函数防抖思路设计出第一版的最简单的防抖代码： 1234567var timer; &#x2F;&#x2F; 维护同一个timerfunction debounce(fn, delay) &#123; clearTimeout(timer); timer &#x3D; setTimeout(function()&#123; fn(); &#125;, delay);&#125; 改进后源码： 12345678910111213141516171819202122function debounce(fn, wait) &#123; var timer &#x3D; null; return function () &#123; var context &#x3D; this var args &#x3D; arguments if (timer) &#123; clearTimeout(timer); timer &#x3D; null; &#125; timer &#x3D; setTimeout(function () &#123; fn.apply(context, args) &#125;, wait) &#125;&#125;var fn &#x3D; function () &#123; console.log(&#39;boom&#39;)&#125;setInterval(debounce(fn,500),1000) &#x2F;&#x2F; 第一次在1500ms后触发，之后每1000ms触发一次setInterval(debounce(fn,2000),1000) &#x2F;&#x2F; 不会触发一次（我把函数防抖看出技能读条，如果读条没完成就用技能，便会失败而且重新读条） 节流规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。 1234567891011121314151617function throttle(fn, gapTime) &#123; let _lastTime &#x3D; null; return function () &#123; let _nowTime &#x3D; + new Date() if (_nowTime - _lastTime &gt; gapTime || !_lastTime) &#123; fn(); _lastTime &#x3D; _nowTime &#125; &#125;&#125;let fn &#x3D; ()&#x3D;&gt;&#123; console.log(&#39;boom&#39;)&#125;setInterval(throttle(fn,1000),10)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"作用域链","slug":"43-作用域链","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T10:07:12.000Z","comments":true,"path":"2020/04/18/43-作用域链/","link":"","permalink":"http://yoursite.com/2020/04/18/43-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/","excerpt":"作用域作用域是在运行时代码中的某些特定部分中变量，函数和对象的可访问性。 作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。 ES6 之前 JavaScript 没有块级作用域,只有全局作用域和函数作用域。ES6的到来，为我们提供了‘块级作用域’，可通过新增命令let和const来体现。","text":"作用域作用域是在运行时代码中的某些特定部分中变量，函数和对象的可访问性。 作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。 ES6 之前 JavaScript 没有块级作用域,只有全局作用域和函数作用域。ES6的到来，为我们提供了‘块级作用域’，可通过新增命令let和const来体现。 全局作用域在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下几种情形拥有全局作用域： 最外层函数 和在最外层函数外面定义的变量拥有全局作用域。 所有末定义直接赋值的变量自动声明为拥有全局作用域。1234567 function outFun2() &#123; variable &#x3D; &quot;未定义直接赋值的变量&quot;; var inVariable2 &#x3D; &quot;内层变量2&quot;;&#125;outFun2();&#x2F;&#x2F;要先执行这个函数，否则根本不知道里面是啥console.log(variable); &#x2F;&#x2F;未定义直接赋值的变量console.log(inVariable2); &#x2F;&#x2F;inVariable2 is not defined 所有window对象的属性拥有全局作用域。 全局作用域有个弊端：如果我们写了很多行 JS 代码，变量定义都没有用函数包括，那么它们就全部都在全局作用域中。这样就会 污染全局命名空间, 容易引起命名冲突。 函数作用域函数作用域,是指声明在函数内部的变量，和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部。 作用域是分层的，内层作用域可以访问外层作用域的变量，反之则不行。块语句（大括号“｛｝”中间的语句），如 if 和 switch 条件语句或 for 和 while 循环语句，不像函数，它们不会创建一个新的作用域。在块语句中定义的变量将保留在它们已经存在的作用域中。 块级作用域块级作用域可通过新增命令let和const声明，所声明的变量在指定块的作用域外无法被访问。块级作用域在如下情况被创建： 在一个函数内部 在一个代码块（由一对花括号包裹）内部 let 声明的语法与 var 的语法一致。你基本上可以用 let 来代替 var 进行变量声明，但会将变量的作用域限制在当前代码块中。块级作用域有以下几个特点： 声明变量不会提升到代码块顶部 let/const 声明并不会被提升到当前代码块的顶部，因此你需要手动将 let/const 声明放置到顶部，以便让变量在整个代码块内部可用。 禁止重复声明 循环中的绑定块作用域的妙用 12345for (let i &#x3D; 0; i &lt; 10; i++) &#123; &#x2F;&#x2F; ...&#125;console.log(i);&#x2F;&#x2F; ReferenceError: i is not defined 作用域链当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"继承","slug":"41-继承","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T10:06:16.000Z","comments":true,"path":"2020/04/18/41-继承/","link":"","permalink":"http://yoursite.com/2020/04/18/41-%E7%BB%A7%E6%89%BF/","excerpt":"下面介绍继承的几种方式1. 原型链继承通过prototype实现继承","text":"下面介绍继承的几种方式1. 原型链继承通过prototype实现继承 1234567891011121314151617function Parent () &#123; this.name &#x3D; &#39;kevin&#39;;&#125;Parent.prototype.getName &#x3D; function () &#123; console.log(this.name);&#125;function Child () &#123;&#125;Child.prototype &#x3D; new Parent();var child1 &#x3D; new Child();console.log(child1.getName()) &#x2F;&#x2F; kevin 引用类型的属性被所有实例共享在创建 Child 的实例时，不能向Parent传参 2. 借用构造函数继承通过call绑定this实现继承。 1234567891011121314151617function Parent () &#123; this.names &#x3D; [&#39;kevin&#39;, &#39;daisy&#39;];&#125;function Child () &#123; Parent.call(this);&#125;var child1 &#x3D; new Child();child1.names.push(&#39;yayu&#39;);console.log(child1.names); &#x2F;&#x2F; [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]var child2 &#x3D; new Child();console.log(child2.names); &#x2F;&#x2F; [&quot;kevin&quot;, &quot;daisy&quot;] 避免了引用类型的属性被所有实例共享可以在 Child 中向 Parent 传参方法都在构造函数中定义，每次创建实例都会创建一遍方法。 123456789101112131415function Parent (name) &#123; this.name &#x3D; name;&#125;function Child (name) &#123; Parent.call(this, name);&#125;var child1 &#x3D; new Child(&#39;kevin&#39;);console.log(child1.name); &#x2F;&#x2F; kevinvar child2 &#x3D; new Child(&#39;daisy&#39;);console.log(child2.name); &#x2F;&#x2F; daisy 3. 组合继承123456789101112131415161718192021222324252627282930313233function Parent (name) &#123; this.name &#x3D; name; this.colors &#x3D; [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;];&#125;Parent.prototype.getName &#x3D; function () &#123; console.log(this.name)&#125;function Child (name, age) &#123; Parent.call(this, name); this.age &#x3D; age;&#125;Child.prototype &#x3D; new Parent();Child.prototype.constructor &#x3D; Child;var child1 &#x3D; new Child(&#39;kevin&#39;, &#39;18&#39;);child1.colors.push(&#39;black&#39;);console.log(child1.name); &#x2F;&#x2F; kevinconsole.log(child1.age); &#x2F;&#x2F; 18console.log(child1.colors); &#x2F;&#x2F; [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]var child2 &#x3D; new Child(&#39;daisy&#39;, &#39;20&#39;);console.log(child2.name); &#x2F;&#x2F; daisyconsole.log(child2.age); &#x2F;&#x2F; 20console.log(child2.colors); &#x2F;&#x2F; [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;] 优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"执行上下文","slug":"42-执行上下文","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T10:05:56.000Z","comments":true,"path":"2020/04/18/42-执行上下文/","link":"","permalink":"http://yoursite.com/2020/04/18/42-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/","excerpt":"前言当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。 对于每个执行上下文，都有三个重要属性： 变量对象(Variable object，VO) 作用域链(Scope chain) this","text":"前言当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。 对于每个执行上下文，都有三个重要属性： 变量对象(Variable object，VO) 作用域链(Scope chain) this 代码1 123456789var scope &#x3D; &quot;global scope&quot;;function checkscope()&#123; var scope &#x3D; &quot;local scope&quot;; function f()&#123; return scope; &#125; return f();&#125;checkscope(); 代码2 123456789var scope &#x3D; &quot;global scope&quot;;function checkscope()&#123; var scope &#x3D; &quot;local scope&quot;; function f()&#123; return scope; &#125; return f;&#125;checkscope()(); 二者返回结果相同，均为local scope，但是二者有着本质的不同——执行上下文栈的变化不同。 代码1执行过程如下： 1.执行全局代码，创建全局执行上下文，全局上下文被压入执行上下文栈 123ECStack &#x3D; [ globalContext]; 2.全局上下文初始化 12345globalContext &#x3D; &#123; VO: [global], Scope: [globalContext.VO], this: globalContext.VO&#125; 2.初始化的同时，checkscope 函数被创建，保存作用域链到函数的内部属性[[scope]] 123checkscope.[[scope]] &#x3D; [ globalContext.VO]; 3.执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈 1234ECStack &#x3D; [ checkscopeContext, globalContext]; 4.checkscope 函数执行上下文初始化： 复制函数 [[scope]] 属性创建作用域链，用 arguments 创建活动对象，初始化活动对象，即加入形参、函数声明、变量声明，将活动对象压入 checkscope 作用域链顶端。同时 f 函数被创建，保存作用域链到 f 函数的内部属性[[scope]] 1234567891011checkscopeContext &#x3D; &#123; AO: &#123; arguments: &#123; length: 0 &#125;, scope: undefined, f: reference to function f()&#123;&#125; &#125;, Scope: [AO, globalContext.VO], this: undefined&#125; 5.执行 f 函数，创建 f 函数执行上下文，f 函数执行上下文被压入执行上下文栈 12345ECStack &#x3D; [ fContext, checkscopeContext, globalContext]; 6.f 函数执行上下文初始化, 以下跟第 4 步相同： 复制函数 [[scope]] 属性创建作用域链用 arguments 创建活动对象初始化活动对象，即加入形参、函数声明、变量声明将活动对象压入 f 作用域链顶端 123456789fContext &#x3D; &#123; AO: &#123; arguments: &#123; length: 0 &#125; &#125;, Scope: [AO, checkscopeContext.AO, globalContext.VO], this: undefined&#125; 7.f 函数执行，沿着作用域链查找 scope 值，返回 scope 值 8.f 函数执行完毕，f 函数上下文从执行上下文栈中弹出 1234ECStack &#x3D; [ checkscopeContext, globalContext]; 9.checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出 ECStack = [ globalContext ];代码2的执行过程： 执行上下文栈","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"类数组对象","slug":"45-类数组对象与arguments","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T10:07:04.000Z","comments":true,"path":"2020/04/18/45-类数组对象与arguments/","link":"","permalink":"http://yoursite.com/2020/04/18/45-%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E4%B8%8Earguments/","excerpt":"类数组对象所谓的类数组对象: 拥有一个 length 属性和若干索引属性的对象","text":"类数组对象所谓的类数组对象: 拥有一个 length 属性和若干索引属性的对象 举个例子： 12345678var array &#x3D; [&#39;name&#39;, &#39;age&#39;, &#39;sex&#39;];var arrayLike &#x3D; &#123; 0: &#39;name&#39;, 1: &#39;age&#39;, 2: &#39;sex&#39;, length: 3&#125; arrayLike.push(‘4’), 会报错: arrayLike.push is not a function 调用数组方法利用Function.call 1234567891011var arrayLike &#x3D; &#123;0: &#39;name&#39;, 1: &#39;age&#39;, 2: &#39;sex&#39;, length: 3 &#125;Array.prototype.join.call(arrayLike, &#39;&amp;&#39;); &#x2F;&#x2F; name&amp;age&amp;sexArray.prototype.slice.call(arrayLike, 0); &#x2F;&#x2F; [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] &#x2F;&#x2F; slice可以做到类数组转数组Array.prototype.map.call(arrayLike, function(item)&#123; return item.toUpperCase();&#125;); &#x2F;&#x2F; [&quot;NAME&quot;, &quot;AGE&quot;, &quot;SEX&quot;] 转换为数组123456789var arrayLike &#x3D; &#123;0: &#39;name&#39;, 1: &#39;age&#39;, 2: &#39;sex&#39;, length: 3 &#125;&#x2F;&#x2F; 1. sliceArray.prototype.slice.call(arrayLike); &#x2F;&#x2F; [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] &#x2F;&#x2F; 2. spliceArray.prototype.splice.call(arrayLike, 0); &#x2F;&#x2F; [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] &#x2F;&#x2F; 3. ES6 Array.fromArray.from(arrayLike); &#x2F;&#x2F; [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] &#x2F;&#x2F; 4. applyArray.prototype.concat.apply([], arrayLike) arguments对象Arguments 对象只定义在函数体中，包括了函数的参数和其他属性。在函数体中，arguments 指代该函数的 Arguments 对象。 举个例子： 12345function foo(name, age, sex) &#123; console.log(arguments);&#125;foo(&#39;name&#39;, &#39;age&#39;, &#39;sex&#39;) [‘name’, ‘age’, ‘sex’] length属性arguments.length callee属性","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"DOM","slug":"DOM","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T10:06:58.000Z","comments":true,"path":"2020/04/18/DOM/","link":"","permalink":"http://yoursite.com/2020/04/18/DOM/","excerpt":"前言浏览器的内核是指支持浏览器运行的最核心的程序，分为两个部分，一是渲染引擎，另一个是JS引擎。 浏览器请求、加载、渲染一个页面，时间花在下面五件事情上： DNS 查询 TCP 连接 HTTP 请求即响应 服务器响应 客户端渲染","text":"前言浏览器的内核是指支持浏览器运行的最核心的程序，分为两个部分，一是渲染引擎，另一个是JS引擎。 浏览器请求、加载、渲染一个页面，时间花在下面五件事情上： DNS 查询 TCP 连接 HTTP 请求即响应 服务器响应 客户端渲染 浏览器渲染页面的过程 浏览器对内容的渲染（渲染树构建、布局及绘制），可以分为下面五个步骤： 处理 HTML 标记并构建 DOM 树。 处理 CSS 标记并构建 CSSOM 树。 将 DOM 与 CSSOM 合并成一个渲染树。 根据渲染树来布局，以计算每个节点的几何信息(也叫回流)。 将各个节点绘制到屏幕上。 注： 文档解析完毕，页面重新渲染。当页面引用的所有 js 同步代码执行完毕，触发 DOMContentLoaded事件。 html 文档中的图片资源，js 代码中有异步加载的 css、js 、图片资源都加载完毕之后，load 事件触发。 需要明白，这五个步骤并不一定一次性顺序完成。如果 DOM 或 CSSOM 被修改，以上过程需要重复执行，这样才能计算出哪些像素需要在屏幕上进行重新渲染。实际页面中，CSS 与 JavaScript 往往会多次修改 DOM 和 CSSOM，下面就来看看它们的影响方式。 HTML从第一行开始解析，遇到外联资源就会请求对应资源，有的资源会阻塞请求，有的资源不会，故分为阻塞型与非阻塞型资源，这里区分两类资源的标志是document对象派发DOMContentLoaded事件的时间点，认为派发DOMContentLoaded事件才表示dom树构建完成。非阻塞型的资源加载完成由window.onload判断，此时页面加载完毕。 阻塞渲染会阻塞DOM解析的资源主要是: 内联css 内联javascript 外联普通javascript 外联defer javascript javascript标签之前的外联css 现代浏览器总是并行加载资源。 当 HTML 解析器被脚本阻塞时，解析器虽然会停止构建 DOM，但仍会识别该脚本后面的资源，并进行预加载。 当浏览器遇到一个 script 标记时，DOM 构建将暂停，直至脚本完成执行。JavaScript 可以查询和修改 DOM 与 CSSOM。CSSOM 构建时，JavaScript 执行将暂停，直至 CSSOM 就绪。 所以，script 标签的位置很重要。实际使用时，可以遵循下面两个原则： CSS 优先：引入顺序上，CSS 资源先于 JavaScript 资源。 JavaScript 应尽量少影响 DOM 的构建。 渲染过程中遇见JavaScript会发生什么？ JavaScript的加载、解析与执行会阻塞DOM的构建，也就是说，在构建DOM时，HTML解析器若遇到了JavaScript，那么它会暂停构建DOM，将控制权移交给JavaScript引擎，等JavaScript引擎运行完毕，浏览器再从中断的地方恢复DOM构建。这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加defer 或者 async属性。 JS文件不只是阻塞DOM的构建，它会导致CSSOM也阻塞DOM的构建。 原本DOM和CSSOM的构建是互不影响，但是一旦引入了JavaScript，CSSOM也开始阻塞DOM的构建，只有CSSOM构建完毕后，DOM再恢复DOM构建。 因为JavaScript不只是可以改DOM，它还可以更改样式，即可以更改CSSOM。不完整的CSSOM是无法使用的，但JavaScript中想访问CSSOM并更改它，那么在执行JavaScript时，必须要能拿到完整的CSSOM。所以，如果浏览器尚未完成CSSOM的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟脚本执行和DOM构建，直至其完成CSSOM的下载和构建。在这种情况下，浏览器会先下载和构建CSSOM，然后再执行JavaScript，最后在继续构建DOM。 改变阻塞模式：defer 与 asyncdefer 123&lt;script src&#x3D;&quot;app1.js&quot; defer&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&quot;app2.js&quot; defer&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&quot;app3.js&quot; defer&gt;&lt;&#x2F;script&gt; defer 属性表示延迟执行引入的 JavaScript，不阻塞资源，而是会暂存到一个队列中，等整个html解析完成后再按队列的顺序请求并执行javascript，但是这种外联defer javascript全部加载并执行完成后才会派发DOMContentLoaded事件。 async 123&lt;script src&#x3D;&quot;app.js&quot; async&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&quot;ad.js&quot; async&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&quot;statistics.js&quot; async&gt;&lt;&#x2F;script&gt; async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行—, 无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。 回流和重绘网页生成的时候，至少会渲染一次。在用户访问的过程中，还会不断重新渲染。 重绘: 当渲染树（render tree）中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的，比如background-color。 回流: 当渲染树（render tree）中的一部分(或全部)因为元素的规模尺寸、布局、隐藏等改变而需要重新构建。 回流必定会发生重绘，重绘不一定会引发回流。 常见引起回流属性和方法 任何会改变元素几何信息(元素的位置和尺寸大小)的操作，都会触发回流。 添加或者删除可见的DOM元素； 元素尺寸改变——边距、填充、边框、宽度和高度 内容变化，比如用户在input框中输入文字 浏览器窗口尺寸改变——resize事件发生时 计算 offsetWidth 和 offsetHeight 属性 设置 style 属性的值","categories":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/categories/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"HTML5(一)","slug":"HTML5(һ)","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T10:07:30.000Z","comments":true,"path":"2020/04/18/HTML5(һ)/","link":"","permalink":"http://yoursite.com/2020/04/18/HTML5(%D2%BB)/","excerpt":"本文主要内容 H5中新增的语义标签 H5表单","text":"本文主要内容 H5中新增的语义标签 H5表单 什么是 HTML5HTML5并不仅仅只是做为HTML标记语言的一个最新版本，更重要的是它制定了Web应用开发的一系列标准，成为第一个将Web做为应用开发平台的HTML语言。 HTML5定义了一系列新元素，如新语义标签、智能表单、多媒体标签等，可以帮助开发者创建富互联网应用，还提供了一些Javascript API，如地理定位、重力感应、硬件访问等，可以在浏览器内实现类原生应用。我们甚至可以结合 Canvas 开发网页版游戏。 HTML5的广义概念：HTML5代表浏览器端技术的一个发展阶段。在这个阶段，浏览器的呈现技术得到了飞跃发展和广泛支持，它包括：HTML5、CSS3、Javascript API在内的一套技术组合。 HTML5不等于 HTML next version。HTML5 包含： HTML的升级版、CSS的升级版、JavaScript API的升级版。 总结：HTML5是新一代开发 Web 富客户端应用程序整体解决方案。包括：HTML5，CSS3，Javascript API在内的一套技术组合。 富客户端：具有很强的交互性和体验的客户端程序。比如说，浏览博客，是比较简单的客户端；一个在线听歌的网站、即时聊天网站就是富客户端。 HTML5 的应用场景列举几个HTML5 的应用场景： （1）极具表现力的网页：内容简约而不简单。 （2）网页应用程序： 代替PC端的软件：iCloud、百度脑图、Office 365等。 APP端的网页：淘宝、京东、美团等。 微信端：公众号、小程序等。 （3）混合式本地应用。 （4）简单的游戏。 HTML5 新增的内容HTML 5提供了一些新的元素和属性，反映典型的现代用法网站。其中有些是技术上类似&lt;div&gt;和&lt;span&gt;标签，但有一定含义，例如&lt;nav&gt;（网站导航块）和&lt;footer&gt;,&lt;audio&gt;和&lt;video&gt;标记。 语义化的标签语义化的作用语义标签对于我们并不陌生，如&lt;p&gt;表示一个段落、&lt;ul&gt;表示一个无序列表。标签语义化的作用： 能够便于开发者阅读和写出更优雅的代码。 同时让浏览器或是网络爬虫可以很好地解析，从而更好分析其中的内容。 更好地搜索引擎优化。 总结：HTML的职责是描述一块内容是什么（或其意义），而不是它长什么样子；它的外观应该由CSS来决定。 H5在语义上的改进在此基础上，HTML5 增加了大量有意义的语义标签，更有利于搜索引擎或辅助设备理解 HTML 页面内容。HTML5会让HTML代码的内容更结构化、标签更语义化。 传统的做法中，我们通过增加类名如class=&quot;header&quot;、class=&quot;footer&quot;，使HTML页面具有语义性，但是不具有通用性。 HTML5 则是通过新增语义标签的形式来解决这个问题，例如&lt;header&gt;&lt;/header&gt;、&lt;footer&gt;&lt;/footer&gt;等，这样就可以使其具有通用性。 传统网页布局： 1234567891011121314151617&lt;!-- 头部 --&gt;&lt;div class=\"header\"&gt; &lt;ul class=\"nav\"&gt;&lt;/ul&gt;&lt;/div&gt;&lt;!-- 主体部分 --&gt;&lt;div class=\"main\"&gt; &lt;!-- 文章 --&gt; &lt;div class=\"article\"&gt;&lt;/div&gt; &lt;!-- 侧边栏 --&gt; &lt;div class=\"aside\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;!-- 底部 --&gt;&lt;div class=\"footer\"&gt;&lt;/div&gt; H5 的经典网页布局： 1234567891011121314151617&lt;!-- 头部 --&gt;&lt;header&gt; &lt;ul class=\"nav\"&gt;&lt;/ul&gt;&lt;/header&gt;&lt;!-- 主体部分 --&gt;&lt;div class=\"main\"&gt; &lt;!-- 文章 --&gt; &lt;article&gt;&lt;/article&gt; &lt;!-- 侧边栏 --&gt; &lt;aside&gt;&lt;/aside&gt;&lt;/div&gt;&lt;!-- 底部 --&gt;&lt;footer&gt;&lt;/footer&gt; H5中新增的语义标签 &lt;section&gt; 表示区块 &lt;article&gt; 表示文章。如文章、评论、帖子、博客 &lt;header&gt; 表示页眉 &lt;footer&gt; 表示页脚 &lt;nav&gt; 表示导航 &lt;aside&gt; 表示侧边栏。如文章的侧栏 &lt;figure&gt; 表示媒介内容分组。 &lt;mark&gt; 表示标记 (用得少) &lt;progress&gt; 表示进度 (用得少) &lt;time&gt; 表示日期 本质上新语义标签与&lt;div&gt;、&lt;span&gt;没有区别，只是其具有表意性，使用时除了在HTML结构上需要注意外，其它和普通标签的使用无任何差别，可以理解成&lt;div class=&quot;nav&quot;&gt; 相当于&lt;nav&gt;。 单标签不用写关闭符号。 新语义标签的兼容性处理IE8 及以下版本的浏览器不支持 H5 和 CSS3。解决办法：引入html5shiv.js文件。 引入时，需要做if判断，具体代码如下： 12345&lt;!-- 条件注释 只有ie能够识别--&gt;&lt;!--[if lte ie 8]&gt; &lt;script src=\"html5shiv.min.js\"&gt;&lt;/script&gt;&lt;![endif]--&gt; 上方代码是条件注释：虽然是注释，但是IE浏览器可以识别出来。解释一下： l：less 更小 t：than 比 e：equal等于 g：great 更大 在测试 IE 浏览器的兼容的时候，可以使用软件 ietest，模拟IE6-IE11。 在不支持HTML5新标签的浏览器，会将这些新的标签解析成行内元素(inline)对待，所以我们只需要将其转换成块元素(block)即可使用。 但是在IE9版本以下，并不能正常解析这些新标签，但是可以识别通过document.createElement(‘tagName’)创建的自定义标签。于是我们的解决方案就是：将HTML5的新标签全部通过document.createElement(‘tagName’)来创建一遍，这样IE低版本也能正常解析HTML5新标签了。 当然，在实际开发中我们更多采用的办法是：检测IE浏览器的版本，来加载第三方的JS库来解决兼容问题（如上方代码所示）。 H5中的表单传统的Web表单已经越来越不能满足开发的需求，HTML5 在 Web 表单方向做了很大的改进，如拾色器、日期/时间组件等，使表单处理更加高效。 H5中新增的表单类型 email 只能输入email格式。自动带有验证功能。 tel 手机号码。 url 只能输入url格式。 number 只能输入数字。 search 搜索框 range 滑动条 color 拾色器 time 时间 date 日期 datetime 时间日期 month 月份 week 星期 上面的部分类型是针对移动设备生效的，且具有一定的兼容性，在实际应用当中可选择性的使用。 代码举例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, user-scalable=no\"&gt; &lt;title&gt;表单类型&lt;/title&gt; &lt;style&gt; body &#123; margin: 0; padding: 0; background-color: #F7F7F7; &#125; form &#123; max-width: 500px; width: 100%; margin: 32px auto 0; font-size: 16px; &#125; label &#123; display: block; margin: 10px 0; &#125; input &#123; width: 100%; height: 25px; margin-top: 2px; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"\"&gt; &lt;fieldset&gt; &lt;legend&gt;表单类型&lt;/legend&gt; &lt;label for=\"\"&gt; email: &lt;input type=\"email\" name=\"email\" required&gt; &lt;/label&gt; &lt;label for=\"\"&gt; color: &lt;input type=\"color\" name=\"color\"&gt; &lt;/label&gt; &lt;label for=\"\"&gt; url: &lt;input type=\"url\" name='url'&gt; &lt;/label&gt; &lt;label for=\"\"&gt; number: &lt;input type=\"number\" step=\"3\" name=\"number\"&gt; &lt;/label&gt; &lt;label for=\"\"&gt; range: &lt;input type=\"range\" name=\"range\" value=\"100\"&gt; &lt;/label&gt; &lt;label for=\"\"&gt; search: &lt;input type=\"search\" name=\"search\"&gt; &lt;/label&gt; &lt;label for=\"\"&gt; tel: &lt;input type=\"tel\" name=\"tel\"&gt; &lt;/label&gt; &lt;label for=\"\"&gt; time: &lt;input type=\"time\" name=\"time\"&gt; &lt;/label&gt; &lt;label for=\"\"&gt; date: &lt;input type=\"date\" name=\"date\"&gt; &lt;/label&gt; &lt;label for=\"\"&gt; datetime: &lt;input type=\"datetime\"&gt; &lt;/label&gt; &lt;label for=\"\"&gt; week: &lt;input type=\"week\" name=\"month\"&gt; &lt;/label&gt; &lt;label for=\"\"&gt; month: &lt;input type=\"month\" name=\"month\"&gt; &lt;/label&gt; &lt;label for=\"\"&gt; datetime-local: &lt;input type=\"datetime-local\" name=\"datetime-local\"&gt; &lt;/label&gt; &lt;input type=\"submit\"&gt; &lt;/fieldset&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 代码解释： &lt;fieldset&gt; 标签将表单里的内容进行打包，代表一组；而&lt;legend&gt;标签的则是 fieldset 里的元素定义标题。 表单元素（标签）这里讲两个表单元素。 1、&lt;datalist&gt; 数据列表： 123456&lt;input type=\"text\" list=\"myData\"&gt;&lt;datalist id=\"myData\"&gt; &lt;option&gt;本科&lt;/option&gt; &lt;option&gt;研究生&lt;/option&gt; &lt;option&gt;不明&lt;/option&gt;&lt;/datalist&gt; 上方代码中，input里的list属性和 datalist 进行了绑定。 2、&lt;keygen&gt;元素： keygen 元素的作用是提供一种验证用户的可靠方法。 keygen 元素是密钥对生成器（key-pair generator）。当提交表单时，会生成两个键：一个公钥，一个私钥。 私钥（private key）存储于客户端，公钥（public key）则被发送到服务器。公钥可用于之后验证用户的客户端证书（client certificate）。 3、&lt;meter&gt;元素：度量器 low：低于该值后警告 high：高于该值后警告 value：当前值 max：最大值 min：最小值。 举例： 1&lt;meter value=\"81\" min=\"0\" max=\"100\" low=\"60\" high=\"80\"/&gt; 表单属性 placeholder 占位符（提示文字） autofocus 自动获取焦点 multiple 文件上传多选或多个邮箱地址 autocomplete 自动完成（填充的）。on 开启（默认），off 取消。用于表单元素，也可用于表单自身(on/off) form 指定表单项属于哪个form，处理复杂表单时会需要 novalidate 关闭默认的验证功能（只能加给form） required 表示必填项 pattern 自定义正则，验证表单。 表单事件 oninput()：用户输入内容时触发，可用于输入字数统计。 oninvalid()：验证不通过时触发。比如，如果验证不通过时，想弹出一段提示文字，就可以用到它。 举例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; form &#123; width: 100%; /* 最大宽度*/ max-width: 400px; /* 最小宽度*/ min-width: 200px; margin: 0 auto; font-family: \"Microsoft Yahei\"; font-size: 20px; &#125; input &#123; display: block; width: 100%; height: 30px; margin: 10px 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"\"&gt; &lt;fieldset&gt; &lt;legend&gt;表单事件&lt;/legend&gt; &lt;label for=\"\"&gt; 邮箱：&lt;input type=\"email\" name=\"\" id=\"txt1\"/&gt; &lt;/label&gt; &lt;label for=\"\"&gt; 输入的次数统计：&lt;input type=\"text\" name=\"\" id=\"txt2\"/&gt; &lt;/label&gt; &lt;input type=\"submit\"/&gt; &lt;/fieldset&gt;&lt;/form&gt;&lt;script&gt; var txt1 = document.getElementById('txt1'); var txt2 = document.getElementById('txt2'); var num = 0; txt1.oninput = function () &#123; //用户输入时触发 num++; //用户每输入一次，num自动加 1 //将统计数显示在txt2中 txt2.value = num; &#125; txt1.oninvalid = function () &#123; //验证不通过时触发 this.setCustomValidity('亲，请输入正确哦'); //设置验证不通过时的提示文字 &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 多媒体在HTML5之前，在网页上播放音频/视频的通用方法是利用Flash来播放。但是大多情况下，并非所有用户的浏览器都安装了Flash插件，由此使得音频、视频播放的处理变得非常复杂；并且移动设备的浏览器并不支持Flash插件。 H5里面提供了视频和音频的标签。 音频HTML5通过&lt;audio&gt;标签来解决音频播放的问题。 使用举例： 1&lt;audio src=\"music/yinyue.mp3\" autoplay controls&gt; &lt;/audio&gt; 我们可以通过附加属性，来更友好地控制音频的播放，如： autoplay 自动播放。写成autoplay 或者 autoplay = &quot;&quot;，都可以。 controls 控制条。（建议把这个选项写上，不然都看不到控件在哪里） loop 循环播放。 preload 预加载 同时设置 autoplay 时，此属性将失效。 处理兼容性问题： 由于版权等原因，不同的浏览器可支持播放的格式是不一样的,为了做到多浏览器支持，可以采取以下兼容性写法： 1234567&lt;!--推荐的兼容写法：--&gt;&lt;audio controls loop&gt; &lt;source src=\"music/yinyue.mp3\"/&gt; &lt;source src=\"music/yinyue.ogg\"/&gt; &lt;source src=\"music/yinyue.wav\"/&gt; 抱歉，你的浏览器暂不支持此音频格式&lt;/audio&gt; 代码解释：如果识别不出音频格式，就弹出那句“抱歉”。 视频HTML5通过&lt;video&gt;标签来解决视频播放的问题。 使用举例： 1&lt;video src=\"video/movie.mp4\" controls autoplay&gt;&lt;/video&gt; 我们可以通过附加属性，来更友好地控制视频的播放，如： autoplay 自动播放。写成autoplay 或者 autoplay = &quot;&quot;，都可以。 controls 控制条。（建议把这个选项写上，不然都看不到控件在哪里） loop 循环播放。 preload 预加载 同时设置 autoplay 时，此属性将失效。 width：设置播放窗口宽度。 height：设置播放窗口的高度。 由于版权等原因，不同的浏览器可支持播放的格式是不一样的。兼容性写法： 12345678&lt;!--&lt;video src=\"video/movie.mp4\" controls autoplay &gt;&lt;/video&gt;--&gt;&lt;!-- 行内块 display:inline-block --&gt;&lt;video controls autoplay&gt; &lt;source src=\"video/movie.mp4\"/&gt; &lt;source src=\"video/movie.ogg\"/&gt; &lt;source src=\"video/movie.webm\"/&gt; 抱歉，不支持此视频&lt;/video&gt; DOM 操作获取元素 document.querySelector(“selector”) 通过CSS选择器获取符合条件的第一个元素。 document.querySelectorAll(“selector”) 通过CSS选择器获取符合条件的所有元素，以类数组形式存在。 类名操作 Node.classList.add(“class”) 添加class Node.classList.remove(“class”) 移除class Node.classList.toggle(“class”) 切换class，有则移除，无则添加 Node.classList.contains(“class”) 检测是否存在class 自定义属性js 里可以通过 box1.index=100; box1.title 来自定义属性和获取属性。 H5可以直接在标签里添加自定义属性，但必须以 data- 开头。","categories":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/categories/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"HTML5(三)","slug":"HTML5(三)","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T10:07:40.000Z","comments":true,"path":"2020/04/18/HTML5(三)/","link":"","permalink":"http://yoursite.com/2020/04/18/HTML5(%E4%B8%89)/","excerpt":"Web 存储随着互联网的快速发展，基于网页的应用越来越普遍，同时也变的越来越复杂，为了满足各种各样的需求，会经常性在本地存储大量的数据，传统方式我们以document.cookie来进行存储的，但是由于其存储大小只有4k左右，并且解析也相当的复杂，给开发带来诸多不便，HTML5规范则提出解决方案。","text":"Web 存储随着互联网的快速发展，基于网页的应用越来越普遍，同时也变的越来越复杂，为了满足各种各样的需求，会经常性在本地存储大量的数据，传统方式我们以document.cookie来进行存储的，但是由于其存储大小只有4k左右，并且解析也相当的复杂，给开发带来诸多不便，HTML5规范则提出解决方案。 H5 中有两种存储的方式1、window.sessionStorage 会话存储： 保存在内存中。 生命周期为关闭浏览器窗口。也就是说，当窗口关闭时数据销毁。 在同一个窗口下数据可以共享。 2、window.localStorage 本地存储： 有可能保存在浏览器内存里，有可能在硬盘里。 永久生效，除非手动删除（比如清理垃圾的时候）。 可以多窗口共享。 Web 存储的特性（1）设置、读取方便。 （2）容量较大，sessionStorage 约5M、localStorage 约20M。 （3）只能存储字符串，可以将对象 JSON.stringify() 编码后存储。 常见 API设置存储内容： 1setItem(key, value); PS：可以新增一个 item，也可以更新一个 item。 读取存储内容： 1getItem(key); 根据键，删除存储内容： 1removeItem(key); 清空所有存储内容： 1clear(); 根据索引值来获取存储内容： 1key(n); sessionStorage 的 API 举例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=\"text\"/&gt;&lt;button&gt;sesssionStorage存储&lt;/button&gt;&lt;button&gt;sesssionStorage获取&lt;/button&gt;&lt;button&gt;sesssionStorage更新&lt;/button&gt;&lt;button&gt;sesssionStorage删除&lt;/button&gt;&lt;button&gt;sesssionStorage清除&lt;/button&gt;&lt;script&gt; //在h5中提供两种web存储方式 // sessionStorage session（会话，会议） 5M 当窗口关闭是数据销毁 内存 // localStorage 20M 永久生效 ，除非手动删除 清理垃圾 硬盘上 var txt = document.querySelector('input'); var btns = document.querySelectorAll('button'); // sessionStorage存储数据 btns[0].onclick = function () &#123; window.sessionStorage.setItem('userName', txt.value); window.sessionStorage.setItem('pwd', '123456'); window.sessionStorage.setItem('age', 18); &#125; // sessionStorage获取数据 btns[1].onclick = function () &#123; txt.value = window.sessionStorage.getItem('userName'); &#125; // sessionStorage更新数据 btns[2].onclick = function () &#123; window.sessionStorage.setItem('userName', txt.value); &#125; // sessionStorage删除数据 btns[3].onclick = function () &#123; window.sessionStorage.removeItem('userName'); &#125; // sessionStorage清空数据 btns[4].onclick = function () &#123; window.sessionStorage.clear(); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; localStorage 的 API 举例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=\"text\"/&gt;&lt;button&gt;localStorage存储&lt;/button&gt;&lt;button&gt;localStorage获取&lt;/button&gt;&lt;button&gt;localStorage更新&lt;/button&gt;&lt;button&gt;localStorage删除&lt;/button&gt;&lt;button&gt;localStorage清除&lt;/button&gt;&lt;script&gt; /* * localStorage * 数据存在硬盘上 * 永久生效 * 20M * */ var txt = document.querySelector('input'); var btns = document.querySelectorAll('button'); // localStorage存储数据 btns[0].onclick = function () &#123; window.localStorage.setItem('userName', txt.value); &#125; // localStorage存储数据 btns[1].onclick = function () &#123; txt.value = window.localStorage.getItem('userName'); &#125; // localStorage删除数据 btns[3].onclick = function () &#123; window.localStorage.removeItem('userName'); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 案例：记住用户名和密码代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;label for=\"\"&gt; 用户名：&lt;input type=\"text\" class=\"userName\"/&gt;&lt;/label&gt;&lt;br/&gt;&lt;br/&gt;&lt;label for=\"\"&gt; 密 码：&lt;input type=\"text\" class=\"pwd\"/&gt;&lt;/label&gt;&lt;br/&gt;&lt;br/&gt;&lt;label for=\"\"&gt; &lt;input type=\"checkbox\" class=\"check\" id=\"\"/&gt;记住密码&lt;/label&gt;&lt;br/&gt;&lt;br/&gt;&lt;button&gt;登录&lt;/button&gt;&lt;script&gt; var userName = document.querySelector('.userName'); var pwd = document.querySelector('.pwd'); var chk = document.querySelector('.check'); var btn = document.querySelector('button'); // 当点击登录的时候 如果勾选“记住密码”，就存储密码；否则就清除密码 btn.onclick = function () &#123; if (chk.checked) &#123;// 记住数据 window.localStorage.setItem('userName', userName.value); window.localStorage.setItem('pwd', pwd.value); &#125; else &#123;// 清除数据 window.localStorage.removeItem('userName'); window.localStorage.removeItem('pwd'); &#125; &#125; // 下次登录时，如果记录的有数据，就直接填充 window.onload = function () &#123; userName.value = window.localStorage.getItem('userName'); pwd.value = window.localStorage.getItem('pwd'); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 网络状态我们可以通过 window.onLine 来检测用户当前的网络状况，返回一个布尔值。另外： window.online：用户网络连接时被调用。 window.offline：用户网络断开时被调用（拔掉网线或者禁用以太网）。 应用缓存HTML5中我们可以轻松的构建一个离线（无网络状态）应用，只需要创建一个 cache manifest 缓存清单文件。 优势1、可配置需要缓存的资源； 2、网络无连接应用仍可用； 3、本地读取缓存资源，提升访问速度，增强用户体验； 4、减少请求，缓解服务器负担。 cache manifest 缓存清单文件缓存清单文件中列出了浏览器应缓存，以供离线访问的资源。推荐使用 .appcache作为后缀名，另外还要添加MIME类型。 缓存清单文件里的内容怎样写： （1）顶行写CACHE MANIFEST。 （2）CACHE: 换行 指定我们需要缓存的静态资源，如.css、image、js等。 （3）NETWORK: 换行 指定需要在线访问的资源，可使用通配符（也就是：不需要缓存的、必须在网络下面才能访问的资源）。 （4）FALLBACK: 换行 当被缓存的文件找不到时的备用资源（当访问不到某个资源时，自动由另外一个资源替换）。 格式举例： 1234567891011121314151617CACHE MANIFEST#要缓存的文件CACHE: images/img1.jpg images/img2.jpg#指定必须联网才能访问的文件NETWORK: images/img3.jpg images/img4.jpg#当前页面无法访问是回退的页面FALLBACK: 404.html","categories":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/categories/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"HTML基础回顾","slug":"HTML基础回顾","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T10:08:36.000Z","comments":true,"path":"2020/04/18/HTML基础回顾/","link":"","permalink":"http://yoursite.com/2020/04/18/HTML%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/","excerpt":"本文主要内容 html 的常见元素 html 元素的分类 html 元素的嵌套关系 html 元素的默认样式和 CSS Reset html 常见面试题","text":"本文主要内容 html 的常见元素 html 元素的分类 html 元素的嵌套关系 html 元素的默认样式和 CSS Reset html 常见面试题 html 的常见元素html 的常见元素主要分为两类：head 区域的元素、body 区域的元素。下面来分别介绍。 1、head 区域的 html 元素 head 区域的 html 元素，不会在页面上留下直接的内容。 meta title style link script base base元素的介绍： 1&lt;base href=\"/\"&gt; base 标签用于指定基础的路径。指定之后，所有的 a 链接都是以这个路径为基准。 2、html 元素（body 区域） body 区域的 html 元素，会直接出现在页面上。 div、section、article、aside、header、footer p span、em、strong 表格元素：table、thead、tbody、tr、td 列表元素：ul、ol、dl、dt、dd a 表单元素：form、input、select、textarea、button div 是最常见的元素，大多数场景下，都可以用div（实在不行就多包几层div）。可见，div 是比较通用的元素，这也决定了 div 的的语义并不是很明确。 常见标签的重要属性： a[href,target] img[src,alt] table td[colspan,rowspan]。设置当前单元格占据几行几列。在合并单元格时，会用到。 form[target,method,enctype] input[type,value] button[type] selection&gt;option[value] label[for] html 文档的大纲我们平时在写论文或者其他文档的时候，一般会先列出大纲，然后再写具体的内容。 同样，html 网页也可以看成是一种文档，也有属于它的大纲。 一个常见的html文档，它的结构可以是： 12345678910111213141516171819202122&lt;section&gt; &lt;h1&gt;一级标题&lt;/h1&gt; &lt;section&gt; &lt;h2&gt;二级标题&lt;/h2&gt; &lt;p&gt;段落内容&lt;/p&gt; &lt;/section&gt; &lt;section&gt; &lt;h2&gt;二级标题&lt;/h2&gt; &lt;p&gt;段落内容&lt;/p&gt; &lt;/section&gt; &lt;aside&gt; &lt;p&gt;广告内容&lt;/p&gt; &lt;/aside&gt;&lt;/section&gt;&lt;footer&gt; &lt;p&gt;某某公司出品&lt;/p&gt;&lt;/footer&gt; html 元素的分类按照样式分类： 块级元素:block 行内元素:inline inline-block：比如form表单元素。对外的表现是行内元素（不会独占一行），对内的表现是块级元素（可以设置宽高）。 html 元素的嵌套关系 块级元素可以包含行内元素。 块级元素不一定能包含块级元素。比如 div 中可以包含 div，但 p 标签中不能包含 div。 行内元素一般不能包含块级元素。比如 span 中不能包含 div。但有个特例：在 HTML5 中， a 标签中可以包含 div。 注意：在 HTML5 中 a &gt; div 是合法的， div &gt; a &gt; div是不合法的 ；但是在 html 4.0.1 中， a &gt; div 仍然是不合法的。 html 常见面试题doctype 的意义是什么 让浏览器以标准模式渲染 让浏览器知道元素的合法性 HTML、XHTML、HTML5的区别 HTML 属于 SGML XHTML 属于 XML，是 HTML 进行 XML 严格化的结果 HTML5 不属于SGML，也不属于 XML（HTML5有自己独立的一套规范），比 XHTML 宽松。 HTML5 有什么新的变化 新的语义化元素 表单增强 新的API：离线、音视频、图形、实时通信、本地存储、设备能力等。 em 和 i 的区别共同点：二者都是表示斜体。 区别： em 是语义化的标签，表示强调。 i 是纯样式的标签，表示斜体。HTML5 中不推荐使用。 语义化的意义是什么 开发者容易理解，便于维护。 机器（搜索引擎、读屏软件等）容易理解结构 有助于 SEO 哪些元素可以自闭和 自闭和的元素中不能再嵌入别的元素。且 HTML5 中要求加斜杠。 表单元素 input 图片 img br、hr meta、link form 表单的作用 直接提交表单 使用 submit / reset 按钮 便于浏览器保存表单 第三方库（比如 jQuery）可以整体获取值 第三方库可以进行表单验证 所以，如果我们是通过 Ajax 提交表单数据，也建议加上 form。","categories":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/categories/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"HTML标签","slug":"HTML标签2","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T10:08:44.000Z","comments":true,"path":"2020/04/18/HTML标签2/","link":"","permalink":"http://yoursite.com/2020/04/18/HTML%E6%A0%87%E7%AD%BE2/","excerpt":"本文主要内容 列表标签：&lt;ul&gt;、&lt;ol&gt;、&lt;dl&gt; 表格标签：&lt;table&gt; 框架标签及内嵌框架&lt;iframe&gt; 表单标签：&lt;form&gt; 多媒体标签 media 滚动字幕标签：&lt;marquee&gt;","text":"本文主要内容 列表标签：&lt;ul&gt;、&lt;ol&gt;、&lt;dl&gt; 表格标签：&lt;table&gt; 框架标签及内嵌框架&lt;iframe&gt; 表单标签：&lt;form&gt; 多媒体标签 media 滚动字幕标签：&lt;marquee&gt; 列表标签列表标签分为三种。 1、无序列表&lt;ul&gt;无序列表以&lt;ul&gt;开始，中间包含一个或多个&lt;li&gt;元素，最后以&lt;/ul&gt;结尾。 例如： 12345&lt;ul&gt; &lt;li&gt;默认1&lt;/li&gt; &lt;li&gt;默认2&lt;/li&gt; &lt;li&gt;默认3&lt;/li&gt;&lt;/ul&gt; 注意： li不能单独存在，必须包裹在ul里面。 ul的作用，并不是给文字增加小圆点的，而是增加无序列表的“语义”的。 属性： type=&quot;属性值&quot;。属性值可以选： disc(实心原点，默认)，square(实心方点)，circle(空心圆)。 列表之间是可以嵌套的。代码： 1234567891011121314151617 &lt;ul&gt;&lt;li&gt;&lt;b&gt;杭州市&lt;/b&gt; &lt;ul&gt; &lt;li&gt;西湖区&lt;/li&gt; &lt;li&gt;拱墅区&lt;/li&gt; &lt;li&gt;滨江区&lt;/li&gt; &lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;北京市&lt;/b&gt; &lt;ul&gt; &lt;li&gt;海淀区&lt;/li&gt; &lt;li&gt;丰台区&lt;/li&gt; &lt;/ul&gt;&lt;/li&gt; &lt;/ul&gt; css 属性： 1list-style-position: inside /* 给 ul 设置这个属性后，将小圆点包含在 li 元素的内部 */ ul标签实际应用场景：导航条,li 里面放置的内容可能很多,声明：ul的儿子，只能是li。但是li是一个容器级标签，li里面什么都能放，甚至可以再放一个ul。 2、有序列表&lt;Ol&gt;，里面的每一项是&lt;li&gt;英文单词：Ordered List。 例如： 12345&lt;ol &gt; &lt;li&gt;呵呵哒1&lt;/li&gt; &lt;li&gt;呵呵哒2&lt;/li&gt; &lt;li&gt;呵呵哒3&lt;/li&gt;&lt;/ol&gt; 属性： type=&quot;属性值&quot;。属性值可以是：1(阿拉伯数字，默认)、a、A、i、I。结合start属性表示从几开始。 举例： 1234567891011121314151617181920212223&lt;ol type=\"1\"&gt; &lt;li&gt;qq&lt;/li&gt; &lt;li&gt;qq&lt;/li&gt; &lt;li&gt;qq&lt;/li&gt;&lt;/ol&gt;&lt;ol type=\"a\"&gt; &lt;li&gt;咿呀咿&lt;/li&gt; &lt;li&gt;咿呀咿&lt;/li&gt; &lt;li&gt;咿呀咿&lt;/li&gt;&lt;/ol&gt;&lt;ol type=\"i\" start=\"4\"&gt; &lt;li&gt;咿呀咿&lt;/li&gt; &lt;li&gt;咿呀咿&lt;/li&gt; &lt;li&gt;咿呀咿&lt;/li&gt;&lt;/ol&gt;&lt;ol type=\"I\" start=\"10\"&gt; &lt;li&gt;咿呀咿&lt;/li&gt; &lt;li&gt;咿呀咿&lt;/li&gt; &lt;li&gt;咿呀咿&lt;/li&gt;&lt;/ol&gt; ol和ul就是语义不一样，怎么使用都是一样的。ol里面只能有li，li必须被ol包裹。li是容器级。 ol这个东西用的不多，如果想表达顺序，大家一般也用ul。举例如下： 12345&lt;ul&gt; &lt;li&gt;1. 小苹果&lt;/li&gt; &lt;li&gt;2. 月亮之上&lt;/li&gt; &lt;li&gt;3. 最炫民族风&lt;/li&gt;&lt;/ul&gt; 3、定义列表&lt;dl&gt; 定义列表的作用非常大。 &lt;dl&gt;英文单词：definition list，没有属性。dl的子元素只能是dt和dd。 &lt;dt&gt;：definition title 列表的标题，这个标签是必须的 &lt;dd&gt;：definition description 列表的列表项，如果不需要它，可以不加 备注：dt、dd只能在dl里面；dl里面只能有dt、dd。 举例： 1234567891011121314&lt;dl&gt; &lt;dt&gt;第一条&lt;/dt&gt; &lt;dd&gt;你若是觉得你有实力和我玩，良辰不介意奉陪到底&lt;/dd&gt; &lt;dd&gt;我会让你明白，我从不说空话&lt;/dd&gt; &lt;dd&gt;我是本地的，我有一百种方式让你呆不下去；而你，无可奈何&lt;/dd&gt; &lt;dt&gt;第二条&lt;/dt&gt; &lt;dd&gt;良辰最喜欢对那些自认能力出众的人出手&lt;/dd&gt; &lt;dd&gt;你可以继续我行我素，不过，你的日子不会很舒心&lt;/dd&gt; &lt;dd&gt;你只要记住，我叫叶良辰&lt;/dd&gt; &lt;dd&gt;不介意陪你玩玩&lt;/dd&gt; &lt;dd&gt;良辰必有重谢&lt;/dd&gt;&lt;/dl&gt; 定义列表表达的语义是两层： （1）是一个列表，列出了几个dd项目 （2）每一个词儿都有自己的描述项。 备注：dd是描述dt的。 定义列表用法非常灵活，可以一个dt配很多dd： 123456789&lt;dl&gt; &lt;dt&gt;北京&lt;/dt&gt; &lt;dd&gt;国家首都，政治文化中心&lt;/dd&gt; &lt;dd&gt;污染很严重，PM2.0天天报表&lt;/dd&gt; &lt;dt&gt;上海&lt;/dt&gt; &lt;dd&gt;魔都，有外滩、东方明珠塔、黄浦江&lt;/dd&gt; &lt;dt&gt;广州&lt;/dt&gt; &lt;dd&gt;中国南大门，有珠江、小蛮腰&lt;/dd&gt;&lt;/dl&gt; 还可以拆开，让每一个dl里面只有一个dt和dd，这样子感觉清晰一些： 123456789101112131415&lt;dl&gt; &lt;dt&gt;北京&lt;/dt&gt; &lt;dd&gt;国家首都，政治文化中心&lt;/dd&gt; &lt;dd&gt;污染很严重，PM2.0天天报表&lt;/dd&gt;&lt;/dl&gt;&lt;dl&gt; &lt;dt&gt;上海&lt;/dt&gt; &lt;dd&gt;魔都，有外滩、东方明珠塔、黄浦江&lt;/dd&gt;&lt;/dl&gt;&lt;dl&gt; &lt;dt&gt;广州&lt;/dt&gt; &lt;dd&gt;中国南大门，有珠江、小蛮腰&lt;/dd&gt;&lt;/dl&gt; 表格标签表格标签用&lt;table&gt;表示。一个表格&lt;table&gt;是由每行&lt;tr&gt;组成的，每行是由每个单元格&lt;td&gt;组成的。所以我们要记住，一个表格是由行组成的（行是由列组成的），而不是由行和列组成的。在以前，要想固定标签的位置，唯一的方法就是表格。现在可以通过CSS定位的功能来实现。但是现在在做页面的时候，表格作用还是有一些的。 例如，一行的单元格： 12345678&lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 上面的表格中没有加文字，所以在生成的网页中什么都看不到。例如，3行4列的单元格： 1234567891011121314151617181920212223&lt;table&gt; &lt;tr&gt; &lt;td&gt;胡歌&lt;/td&gt; &lt;td&gt;23&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;黄冈&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;罗云熙&lt;/td&gt; &lt;td&gt;29&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;安徽&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;刘诗诗&lt;/td&gt; &lt;td&gt;23&lt;/td&gt; &lt;td&gt;女&lt;/td&gt; &lt;td&gt;上海&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; &lt;table&gt;标签的属性。 &lt;table&gt;的属性： border：边框。像素为单位。 style=&quot;border-collapse:collapse;&quot;：单元格的线和表格的边框线合并（表格的两边框合并为一条） width：宽度。像素为单位。 height：高度。像素为单位。 bordercolor：表格的边框颜色。 align：表格的水平对齐方式。属性值可以填：left right center。注意：这里不是设置表格里内容的对齐方式，如果想设置内容的对齐方式，要对单元格标签&lt;td&gt;进行设置） cellpadding：单元格内容到边的距离，像素为单位。默认情况下，文字是紧挨着左边那条线的，即默认情况下的值为0。注意不是单元格内容到四条边的距离哈，而是到一条边的距离，默认是与左边那条线的距离。如果设置属性dir=&quot;rtl&quot;，那就指的是内容到右边那条线的距离。 cellspacing：单元格和单元格之间的距离（外边距），像素为单位。默认情况下的值为0 bgcolor=&quot;#99cc66&quot;：表格的背景颜色。 background=&quot;路径src/...&quot;：背景图片。背景图片的优先级大于背景颜色。 bordercolorlight：表格的上、左边框，以及单元格的右、下边框的颜色 bordercolordark：表格的右、下边框，以及单元格的上、左的边框的颜色这两个属性的目的是为了设置3D的效果。 dir：公有属性，单元格内容的排列方式(direction)。 可以 取值：ltr：从左到右（left to right，默认），rtl：从右到左（right to left）既然说dir是共有属性，如果把这个属性放在任意标签中，那表明这个标签的位置可能会从右开始排列。 &lt;tr&gt;：行一个表格就是一行一行组成的。 属性： dir：公有属性，设置这一行单元格内容的排列方式。可以取值： ltr：从左到右（left to right，默认） rtl：从右到左（right to left） bgcolor：设置这一行的单元格的背景色。注：没有background属性，即：无法设置这一行的背景图片，如果非要设置，可以用css实现。 height：一行的高度 align=&quot;center&quot;：一行的内容水平居中显示，取值：left、center、right valign=&quot;center&quot;：一行的内容垂直居中，取值：top、middle、bottom &lt;td&gt;：单元格属性： align：内容的横向对齐方式。属性值可以填：left right center。如果想让每个单元格的内容都居中，这个属性太麻烦了，以后用css来解决。 valign：内容的纵向对齐方式。属性值可以填：top middle bottom width：绝对值或者相对值(%) height：单元格的高度 bgcolor：设置这个单元格的背景色。 background：设置这个单元格的背景图片。 单元格的合并单元格的属性： colspan：横向合并。例如colspan=&quot;2&quot;表示当前单元格在水平方向上要占据两个单元格的位置。 rowspan：纵向合并。例如rowspan=&quot;2&quot;表示当前单元格在垂直方向上要占据两个单元格的位置。 &lt;th&gt;：加粗的单元格。相当于&lt;td&gt; + &lt;b&gt; 属性同&lt;td&gt;标签。 &lt;caption&gt; ：表格的标题。使用时和tr标签并列 属性：align，表示标题相对于表格的位置。属性取值可以是：left、center、right、top、bottom 表格的&lt;thead&gt;标签、&lt;tbody&gt;标签、&lt;tfoot&gt;标签这三个标签有与没有的区别： 1、如果写了，那么这三个部分的代码顺序可以任意，浏览器显示的时候还是按照thead、tbody、tfoot的顺序依次来显示内容。如果不写thead、tbody、tfoot，那么浏览器解析并显示表格内容的时候是从按照代码的从上到下的顺序来显示。 2、当表格非常大内容非常多的时候，如果用thead、tbody、tfoot标签的话，那么数据可以边获取边显示。如果不写，则必须等表格的内容全部从服务器获取完成才能显示出来。 框架标签如果我们希望在一个网页中显示多个页面，那框架标签就派上用场了。 注意，框架标签不能放在&lt;body&gt;标签里面，因为&lt;body&gt;标签代表的只是一个页面，而框架标签代表的是多个页面。于是：&lt;frameset&gt;和&lt;body&gt;只能二选一。 框架的集合用&lt;frameset&gt;表示，然后在&lt;frameset&gt;集合里放入一个一个的框架&lt;frame&gt; &lt;frameset&gt;：框架的集合一个框架的集合可以包含多个框架或框架的集合。属性： rows：水平分割，将框架分为上下部分。写法有两种： 1、绝对值写法：rows=&quot;200,*&quot; 其中*代表剩余的。这里其实包含了两个框架：上面的框架占200个像素，下面的框架占剩下的部分。 2、相对值写法：rows=&quot;30%,*&quot; 其中*代表剩余的。这里其实包含了两个框架：上面的框架占30%，下面的框架占70%。 注：如果你想将框架分成很多行，在属性值里用逗号隔开就行了。 cols：垂直分割，将框架分为左右部分。写法有两种： 1、绝对值写法：cols=&quot;200,*&quot; 其中*代表剩余的。这里其实包含了两个框架：左边的框架占200个像素，右边的框架占剩下的部分。 2、相对值写法：cols=&quot;30%,*&quot; 其中*代表剩余的。这里其实包含了两个框架：左边的框架占30%，右边的框架占70%。 注：如果你想将框架分成很多列，在属性值里用逗号隔开就行了。 &lt;frame&gt;：框架一个框架显示一个页面。 属性： scrolling=&quot;no&quot;：是否需要滚动条。默认值是true。 noresize：不可以改变框架大小。默认情况下，单个框架的边界是可以拖动的，这样的话，框架大小就不固定了。如果用了这个属性值，框架大小将固定。 举例： 1&lt;frame src=\"top.html\" noresize&gt;&lt;/frame&gt; bordercolor=&quot;#00FF00&quot;：给框架的边框定义颜色。这个属性在框架集合&lt;frameset&gt;中同样适用。颜色这个属性在IE浏览器中生效，但是在google浏览器中无效。 frameborder=&quot;0&quot;或frameborder=&quot;1&quot;：隐藏或显示边框（框架线）。 name：给框架起一个名字。 利用name这个属性，我们可以在框架里进行超链。 内嵌框架内嵌框架用&lt;iframe&gt;表示。&lt;iframe&gt;是&lt;body&gt;的子标记。 内嵌框架inner frame：嵌入在一个页面上的框架(仅仅IE、新版google浏览器支持，可能有其他浏览器也支持，暂时我不清楚)。 属性： src=&quot;subframe/the_second.html&quot;：内嵌的那个页面 width=800：宽度 height=“150：高度 scrolling=&quot;no&quot;：是否需要滚动条。默认值是true。 name=&quot;mainFrame&quot;：窗口名称。公有属性。 内嵌框架举例：（在内嵌页面中切换显示不同的页面) 123456789&lt;body&gt; &lt;a href=\"文字页面.html\" target=\"myframe\"&gt;默认显示文字页面&lt;/a&gt;&lt;br&gt; &lt;a href=\"图片页面.html\" target=\"myframe\"&gt;点击进入图片页面&lt;/a&gt;&lt;br&gt; &lt;a href=\"表格页面.html\" target=\"myframe\"&gt;点击进入表格页面&lt;/a&gt;&lt;br&gt; &lt;iframe src=\"文字页面.html\" width=\"400\" height=\"400\" name=\"myframe\"&gt;&lt;/iframe&gt; &lt;br&gt;&lt;/body&gt; 表单标签表单标签用&lt;form&gt;表示，用于与服务器的交互。表单就是收集用户信息的，就是让用户填写的、选择的。 属性： name：表单的名称，用于JS来操作或控制表单时使用； id：表单的名称，用于JS来操作或控制表单时使用； action：指定表单数据的处理程序，一般是PHP，如：action=“login.php” method：表单数据的提交方式，一般取值：get(默认)和post 注意：表单和表格嵌套时，是在&lt;form&gt;标记中套&lt;table&gt;标记。 form标签里面的action属性和method属性，action属性就是表示，表单将提交到哪里。 method属性表示用什么HTTP方法提交，有get、post两种。 get提交和post提交的区别： GET方式：将表单数据，以”name=value”形式追加到action指定的处理程序的后面，两者间用”?”隔开，每一个表单的”name=value”间用”&amp;”号隔开。特点：只适合提交少量信息，并且不太安全(不要提交敏感数据)、提交的数据类型只限于ASCII字符。 POST方式：将表单数据直接发送(隐藏)到action指定的处理程序。POST发送的数据不可见。Action指定的处理程序可以获取到表单数据。特点：可以提交海量信息，相对来说安全一些，提交的数据格式是多样的(Word、Excel、rar、img)。 Enctype：表单数据的编码方式(加密方式)，取值可以是：application/x-www-form-urlencoded、multipart/form-data。Enctype只能在POST方式下使用。 Application/x-www-form-urlencoded：默认加密方式，除了上传文件之外的数据都可以 Multipart/form-data：上传附件时，必须使用这种编码方式。 &lt;input&gt;：输入标签（文本框）用于接收用户输入。 1&lt;input type=\"text\" /&gt; 属性： type=&quot;属性值&quot;：文本类型。属性值可以是： text（默认） password：密码类型 radio：单选按钮，名字相同的按钮作为一组进行单选（name就是“名字”）,所有关联的单选按钮应该拥有相同的name属性。。非常像以前的收音机，按下去一个按钮，其他的就抬起来了。所以叫做radio。每一个单选按钮都应该嵌套在它自己的label（标签）元素中。 checkbox ：多选按钮，name 属性值相同的按钮作为一组进行选择。 checked：将单选按钮或多选按钮默认处于选中状态。当&lt;input&gt;标签的type=&quot;radio&quot;时，可以用这个属性。属性值也是checked，可以省略。 每一个复选框都应该嵌套在它自己的label（标签）元素中。 hidden：隐藏框，在表单中包含不希望用户看见的信息 button：普通按钮，结合js代码进行使用。 submit：提交按钮，传送当前表单的数据给服务器或其他程序处理。这个按钮不需要写value自动就会有“提交”文字。这个按钮真的有提交功能。点击按钮后，这个表单就会被提交到form标签的action属性中指定的那个页面中去。 reset：重置按钮，清空当前表单的内容，并设置为最初的默认值 image：图片按钮，和提交按钮的功能完全一致，只不过图片按钮可以显示图片。 file：文件选择框。 提示：如果要限制上传文件的类型，需要配合JS来实现验证。对上传文件的安全检查：一是扩展名的检查，二是文件数据内容的检查。 value=&quot;内容&quot;：文本框里的默认内容（已经被填好了的） size=&quot;50&quot;：表示文本框内可以显示五十个字符。一个英文或一个中文都算一个字符。注意size属性值的单位不是像素哦。 readonly：文本框只读，不能编辑。因为它的属性值也是readonly，所以属性值可以不写。用了这个属性之后，在google浏览器中，光标点不进去；在IE浏览器中，光标可以点进去，但是文字不能编辑。 disabled：文本框只读，不能编辑，光标点不进去。属性值可以不写。 Placeholder占位符是用户在input输入框中输入任何东西前的预定义文本。 required 如果你想把文本输入框设置为必填项，在input元素中加上required属性就可以了。例如： &lt;input type=\"text\" required&gt; 12345678910111213141516**举例**：&#96;&#96;&#96;html &lt;form&gt; 姓名：&lt;input value&#x3D;&quot;呵呵&quot; &gt;逗比&lt;br&gt; 昵称：&lt;input value&#x3D;&quot;哈哈&quot; readonly&#x3D;&quot;&quot;&gt;&lt;br&gt; 名字：&lt;input type&#x3D;&quot;text&quot; value&#x3D;&quot;name&quot; disabled&#x3D;&quot;&quot;&gt;&lt;br&gt; 密码：&lt;input type&#x3D;&quot;password&quot; value&#x3D;&quot;pwd&quot; size&#x3D;&quot;50&quot;&gt;&lt;br&gt; 性别：&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;gender&quot; id&#x3D;&quot;radio1&quot; value&#x3D;&quot;male&quot; checked&#x3D;&quot;&quot;&gt;男 &lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;gender&quot; id&#x3D;&quot;radio2&quot; value&#x3D;&quot;female&quot; &gt;女&lt;br&gt; 爱好：&lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;love&quot; value&#x3D;&quot;eat&quot;&gt;吃饭 &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;love&quot; value&#x3D;&quot;sleep&quot;&gt;睡觉 &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;love&quot; value&#x3D;&quot;bat&quot;&gt;打豆豆 &lt;&#x2F;form&gt; 注意，多个个单选框的input标签中，name 的属性值可以相同，但是 id 的属性值必须是唯一的。我们知道，html的标签中，id的属性值是唯一的。 四种按钮的举例： 12345678&lt;form&gt; &lt;input type=\"button\" value=\"普通按钮\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交按钮\"&gt;&lt;br&gt; &lt;input type=\"reset\" value=\"重置按钮\"&gt;&lt;br&gt; &lt;input type=\"image\" value=\"图片按钮1\"&gt;&lt;br&gt; &lt;input type=\"image\" src=\"1.jpg\" width=\"800\" value=\"图片按钮2\"&gt;&lt;br&gt; &lt;input type=\"file\" value=\"文件选择框\"&gt;&lt;/form&gt; &lt;select&gt;：下拉列表标签&lt;select&gt;标签里面的每一项用&lt;option&gt;表示。select就是“选择”，option“选项”。 select标签和ul、ol、dl一样，都是组标签。 &lt;select&gt;标签的属性： multiple：可以对下拉列表中的选项进行多选。没有属性值。 size=&quot;3&quot;：如果属性值大于1，则列表为滚动视图。默认属性值为1，即下拉视图。 &lt;option&gt;标签的属性： selected：预选中。没有属性值。 举例： 1234567891011121314151617181920212223242526272829&lt;form&gt; &lt;select&gt; &lt;option&gt;小学&lt;/option&gt; &lt;option&gt;初中&lt;/option&gt; &lt;option&gt;高中&lt;/option&gt; &lt;option&gt;大学&lt;/option&gt; &lt;option selected=\"\"&gt;研究生&lt;/option&gt; &lt;/select&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;select size=\"3\"&gt; &lt;option&gt;小学&lt;/option&gt; &lt;option&gt;初中&lt;/option&gt; &lt;option&gt;高中&lt;/option&gt; &lt;option&gt;大学&lt;/option&gt; &lt;option&gt;研究生&lt;/option&gt; &lt;/select&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;select multiple=\"\"&gt; &lt;option&gt;小学&lt;/option&gt; &lt;option&gt;初中&lt;/option&gt; &lt;option selected=\"\"&gt;高中&lt;/option&gt; &lt;option selected=\"\"&gt;大学&lt;/option&gt; &lt;option&gt;研究生&lt;/option&gt; &lt;/select&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/form&gt; &lt;textarea&gt;标签：多行文本输入框text就是“文本”，area就是“区域”。 属性： value：提交给服务器的值。 rows=&quot;4&quot;：指定文本区域的行数。 cols=&quot;20&quot;：指定文本区域的列数。 readonly：只读。 举例： 123&lt;form&gt; &lt;textarea name=\"txtInfo\" rows=\"4\" cols=\"20\"&gt;1、不爱摄影不懂设计的程序猿不是一个好的产品经理。&lt;/textarea&gt;&lt;/form&gt; 上方代码解释：textarea这个标签，是个标签对儿。对儿里面不用写东西。如果写的话，就是这个框的默认文字。 表单的语义化比如，我们在注册一个网站的信息的时候，有一部分是必填信息，有一部分是选填信息，这个时候可以利用表单的语义化。举例： 123456789101112131415161718&lt;form&gt; &lt;fieldset&gt; &lt;legend&gt;账号信息&lt;/legend&gt; 姓名：&lt;input value=\"呵呵\" &gt;逗比&lt;br&gt; 密码：&lt;input type=\"password\" value=\"pwd\" size=\"50\"&gt;&lt;br&gt; &lt;/fieldset&gt; &lt;fieldset&gt; &lt;legend&gt;其他信息&lt;/legend&gt; 性别：&lt;input type=\"radio\" name=\"gender\" value=\"male\" checked=\"\"&gt;男 &lt;input type=\"radio\" name=\"gender\" value=\"female\" &gt;女&lt;br&gt; 爱好：&lt;input type=\"checkbox\" name=\"love\" value=\"eat\"&gt;吃饭 &lt;input type=\"checkbox\" name=\"love\" value=\"sleep\"&gt;睡觉 &lt;input type=\"checkbox\" name=\"love\" value=\"bat\"&gt;打豆豆 &lt;/fieldset&gt;&lt;/form&gt; &lt;label&gt;标签我们先来看下面一段代码： 12&lt;input type=\"radio\" name=\"sex\" /&gt; 男&lt;input type=\"radio\" name=\"sex\" /&gt; 女 对于上面这样的单选框，我们只有点击那个单选框（小圆圈）才可以选中，点击“男”、“女”这两个文字时是无法选中的；于是，label标签派上了用场。 本质上来讲，“男”、“女”这两个文字和input标签时没有关系的，而label就是解决这个问题的。我们可以通过label把input和汉字包裹起来作为整体。 解决方法如下： 12&lt;input type=\"radio\" name=\"sex\" id=\"nan\" /&gt; &lt;label for=\"nan\"&gt;男&lt;/label&gt;&lt;input type=\"radio\" name=\"sex\" id=\"nv\" /&gt; &lt;label for=\"nv\"&gt;女&lt;/label&gt; 上方代码中，让label标签的for 属性值，和 input 标签的 id 属性值相同，那么这个label和input就有绑定关系了。 当然了，复选框也有label：（任何表单元素都有label） 12&lt;input type=\"checkbox\" id=\"kk\" /&gt;&lt;label for=\"kk\"&gt;10天内免登陆&lt;/label&gt; 多媒体标签声明：多媒体包含：音频、视频、Flash。网页上的多媒体基本都是Flash格式的。.wmv、.dat、.mob、.rmvb等视频格式，在网页上不能直接播放，需要安装第三方的插件，才可以播放。不同的浏览器，播客上述视频格式，所使用插件参数又不一样。上述格式视频一般文件较大，不利于网络下载播放。一般情况下，是将其它的视频格式，转成Flash来在网页上播放。转换软件：格式工厂等。Flash格式的视频兼容性非常好，Flash格式的文件很小。 &lt;bgsound&gt;标签：播放背景音乐属性： src=&quot;音乐文件的路径&quot; loop=&quot;-1&quot;：属性值代表播放次数，-1代表循环播放。 举例： 123&lt;body&gt;&lt;bgsound src=\"王菲 - 清风徐来.mp3\"&gt;&lt;/bgsound&gt;&lt;/body&gt; 运行效果：打开网页后，在IE 8中播放正常，播放时网页上显示一片空白。在google浏览器中无法播放。 &lt;embed&gt;标签：播放多媒体文件（音频、视频等）主要应用Netscape浏览器，它不是W3C规范。 备注：视频格式可以支持 mp4、wav等，但不是所有视频格式都支持。 属性： src=&quot;多媒体文件的路径&quot; loop=&quot;-1&quot;：属性值代表播放次数，-1代表循环播放。 autostart=&quot;false&quot;：打开网页时，禁止自动播放。默认值是true。 volume=&quot;100&quot;：设置默认的音量大小，测试发现这个值好像不起作用哦。 width：指Flash文件的宽度 height：指Flash文件的高度 quality：指Flash的播放质量，质量有高有低 hight low pluginspage：如果指定的Flash插件不存在，则从pluginspage指定的地方进行下载。 type：指定Flash的文件格式类型 wmode：指Flash的背景是否可以透明，取值：transparent是透明的 &lt;embed&gt;标签播放音频举例： 123&lt;body&gt;&lt;embed src=\"王菲 - 清风徐来.mp3\"&gt;&lt;/embed&gt;&lt;/body&gt; 注：在HTML5中新增了&lt;video&gt;标签播放视频。 &lt;object&gt;标签：播放多媒体文件（音频、视频等）主要应用IE浏览器，它是W3C规范。 属性： classid：指定Flash插件的ID号，一般存在于注册表中。 codebase：如果Flash插件不存在，则从codebase指定的地址下载。 &lt;param&gt;标签的主要作用：设置具体的详细参数。 总结：在网页中插入Flash时，为了同时兼容多种浏览器，需要将&lt;object&gt;标签和&lt;embed&gt;标签标记一起使用，但使用的顺序是：&lt;object&gt;中嵌套&lt;embed&gt;标记。举例： 123456&lt;object classid=\"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\" codebase=\"http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,29,0\" width=\"778\" height=\"202\"&gt; &lt;param name=\"movie\" value=\"images/banner.swf\"&gt; &lt;param name=\"quality\" value=\"high\"&gt; &lt;param name=\"wmode\" value=\"transparent\"&gt; &lt;embed src=\"images/banner.swf\" width=\"778\" height=\"202\" quality=\"high\" pluginspage=\"http://www.macromedia.com/go/getflashplayer\" type=\"application/x-shockwave-flash\" wmode=\"transparent\"&gt;&lt;/embed&gt;&lt;/object&gt; &lt;marquee&gt;：滚动字幕标签如果在这个标签里设置了内容，那么，打开网页时，内容会像弹幕一样自动移动。属性： direction=&quot;right&quot;：移动的目标方向。属性值可以是：left（从右向左移动，默认值）、right（从左向右移动）、up（从下向上移动）、down（从上向下移动）。 behavior=&quot;slide&quot;：行为方式。属性值可以是：slide（只移动一次）、scroll（循环移动，默认值）、alternate（循环移动）、。alternate和scroll属性值都是循环移动，区别在于：假设在direction=&quot;right&quot;的情况下，behavior=&quot;scroll&quot;表示从左到右、从左到右、从左到右···behavior=&quot;alternate&quot;表示从左到右、从右到左、从左到右··· scrollamount=&quot;30&quot;：移动的速度 loop=&quot;3&quot;: 循环多少圈。负值表示无限循环 scrolldelay=&quot;1000&quot;：移动一次休息多长时间。单位是毫秒。 举例： 1&lt;marquee behavior=\"alternate\" direction=\"down\" width=\"300\" height=\"200\" bgcolor=\"#8c5dc1\"&gt;我来了&lt;/marquee&gt;","categories":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/categories/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"HTML5(二)","slug":"HTML5(二)","date":"2020-04-18T00:00:00.000Z","updated":"2020-04-19T10:07:50.000Z","comments":true,"path":"2020/04/18/HTML5(二)/","link":"","permalink":"http://yoursite.com/2020/04/18/HTML5(%E4%BA%8C)/","excerpt":"本文主要内容 拖拽 历史 地理位置 全屏","text":"本文主要内容 拖拽 历史 地理位置 全屏 拖拽在HTML5的规范中，我们可以通过为元素增加 draggable=&quot;true&quot; 来设置此元素是否可以进行拖拽操作，其中图片、链接默认是开启拖拽的。 1、拖拽元素页面中设置了 draggable=&quot;true&quot; 属性的元素。 举例如下： 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"css/font-awesome.min.css\"&gt; &lt;style&gt; .box1&#123; width: 200px; height: 200px; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!--给 box1 增加拖拽的属性--&gt; &lt;div class=\"box1\" draggable=\"true\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 我们给 box1 增加了draggable=&quot;true&quot; 属性之后，发现 box1 是可以拖拽的。但是拖拽之后要做什么事情呢？这就涉及到事件监听。 拖拽元素的事件监听：（应用于拖拽元素） ondragstart当拖拽开始时调用 ondragleave 当鼠标离开拖拽元素时调用 ondragend 当拖拽结束时调用 ondrag 整个拖拽过程都会调用 代码演示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .box &#123; width: 200px; height: 200px; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"box\" draggable=\"true\"&gt;&lt;/div&gt;&lt;script&gt; var box = document.querySelector('.box'); // 绑定拖拽事件 // 拖拽开始 box.ondragstart = function () &#123; console.log('拖拽开始.'); &#125; // 拖拽离开：鼠标拖拽时离开被拖拽的元素是触发 box.ondragleave = function () &#123; console.log('拖拽离开..'); &#125; // 拖拽结束 box.ondragend = function () &#123; console.log('拖拽结束...'); console.log(\"---------------\"); &#125; box.ondrag = function () &#123; console.log('拖拽'); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、目标元素比如说，你想把元素A拖拽到元素B里，那么元素B就是目标元素。 页面中任何一个元素都可以成为目标元素。 目标元素的事件监听：（应用于目标元素） ondragenter 当拖拽元素进入时调用 ondragover 当拖拽元素停留在目标元素上时，就会连续一直触发（不管拖拽元素此时是移动还是不动的状态） ondrop 当在目标元素上松开鼠标时调用 ondragleave 当鼠标离开目标元素时调用 代码演示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .one &#123; width: 100px; height: 100px; border: 1px solid #000; background-color: green; &#125; .two &#123; position: relative; width: 200px; height: 200px; left: 300px; top: 100px; border: 1px solid #000; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"one\" draggable=\"true\"&gt;&lt;/div&gt;&lt;div class=\"two\"&gt;&lt;/div&gt;&lt;script&gt; var two = document.querySelector('.two'); //目标元素的拖拽事件 // 当被拖拽元素进入是触发 two.ondragenter = function () &#123; console.log(\"来了.\"); &#125; // 当被拖拽元素离开时触发 two.ondragleave = function () &#123; console.log(\"走了..\"); &#125; // 当拖拽元素在 目标元素上时，连续触发 two.ondragover = function (e) &#123; //阻止拖拽事件的默认行为 e.preventDefault(); //【重要】一定要加这一行代码，否则，后面的方法 ondrop() 无法触发。 console.log(\"over...\"); &#125; // 当在目标元素上松开鼠标是触发 two.ondrop = function () &#123; console.log(\"松开鼠标了....\"); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上方代码中，我们加了event.preventDefault()这个方法。如果没有这个方法，后面ondrop()方法无法触发。如下图所示： 总结：如果想让拖拽元素在目标元素里做点事情，就必须要在 ondragover() 里加event.preventDefault()这一行代码。 案例：拖拽 完整版代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .one &#123; width: 400px; height: 400px; border: 1px solid #000; &#125; .one &gt; div, .two &gt; div &#123; width: 98px; height: 98px; border: 1px solid #000; border-radius: 50%; background-color: red; float: left; text-align: center; line-height: 98px; &#125; .two &#123; width: 400px; height: 400px; border: 1px solid #000; position: absolute; left: 600px; top: 200px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"one\"&gt; &lt;div draggable=\"true\"&gt;1&lt;/div&gt; &lt;div draggable=\"true\"&gt;2&lt;/div&gt; &lt;div draggable=\"true\"&gt;3&lt;/div&gt; &lt;div draggable=\"true\"&gt;4&lt;/div&gt; &lt;div draggable=\"true\"&gt;5&lt;/div&gt; &lt;div draggable=\"true\"&gt;6&lt;/div&gt; &lt;div draggable=\"true\"&gt;7&lt;/div&gt; &lt;div draggable=\"true\"&gt;8&lt;/div&gt;&lt;/div&gt;&lt;div class=\"two\"&gt;&lt;/div&gt;&lt;script&gt; var boxs = document.querySelectorAll('.one div'); // 临时的盒子 用于存放当前拖拽的元素 var two = document.querySelector('.two'); var temp = null; // 给8个小盒子分别绑定拖拽事件 for (var i = 0; i &lt; boxs.length; i++) &#123; boxs[i].ondragstart = function () &#123;// 保持当前拖拽的元素 temp = this; console.log(temp); &#125; boxs[i].ondragend = function () &#123;// 当拖拽结束 ，清空temp temp = null; console.log(temp); &#125; &#125; // 目标元素的拖拽事件 two.ondragover = function (e) &#123;// 阻止拖拽的默认行为 e.preventDefault(); &#125; // 当在目标元素上松开鼠标是触发 two.ondrop = function () &#123;// 将拖拽的元素追加到 two里面来 this.appendChild(temp); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 历史: window.history界面上的所有JS操作不会被浏览器记住，就无法回到之前的状态。 在HTML5中可以通过 window.history 操作访问历史状态，让一个页面可以有多个历史状态 window.history对象可以让我们管理历史记录，可用于单页面应用，Single Page Application，可以无刷新改变网页内容。 window.history.forward(); // 前进 window.history.back(); // 后退 window.history.go(); // 刷新 通过JS可以加入一个访问状态 history.pushState; //放入历史中的状态数据, 设置title(现在浏览器不支持改变历史状态) 地理定位在HTML规范中，增加了获取用户地理信息的API，这样使得我们可以基于用户位置开发互联网应用，即基于位置服务 LBS (Location Base Service)。 获取地理信息的方式1、IP地址2、三维坐标：（1）GPS（Global Positioning System，全球定位系统）。 目前世界上在用或在建的第2代全球卫星导航系统（GNSS）有： 1.美国 Global Positioning System （全球定位系统） 简称GPS； 2.苏联/俄罗斯 GLOBAL NAVIGATION SATELLITE SYSTEM （全球卫星导航系统）简称GLONASS（格洛纳斯）； 3.欧盟（欧洲是不准确的说法，包括中国在内的诸多国家也参与其中）Galileo satellite navigation system（伽利略卫星导航系统） 简称GALILEO（伽利略）； 4.中国 BeiDou(COMPASS) Navigation Satellite System（北斗卫星导航系统）简称 BDS ； 5.日本 Quasi-Zenith Satellite System （准天顶卫星系统） 简称QZSS ； 6.印度 India Regional Navigation Satellite System（印度区域卫星导航系统）简称IRNSS。 以上6个系统中国都能使用。 （2）Wi-Fi定位：仅限于室内。 （3）手机信号定位：通过运营商的信号塔定位。 3、用户自定义数据：对不同获取方式的优缺点进行了比较，浏览器会自动以最优方式去获取用户地理信息。 隐私HTML5 Geolocation(地理位置定位) 规范提供了一套保护用户隐私的机制。必须先得到用户明确许可，才能获取用户的位置信息。 API详解 navigator.getCurrentPosition(successCallback, errorCallback, options) 获取当前地理信息 navigator.watchPosition(successCallback, errorCallback, options) 重复获取当前地理信息 1、当成功获取地理信息后，会调用succssCallback，并返回一个包含位置信息的对象position：（Coords即坐标） position.coords.latitude纬度 position.coords.longitude经度 2、当获取地理信息失败后，会调用errorCallback，并返回错误信息error。 3、可选参数 options 对象可以调整位置信息数据收集方式 地理位置的 api 代码演示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; /*navigator 导航*/ //geolocation: 地理定位// window.navigator.geolocation// 兼容处理 if(navigator.geolocation)&#123;// 如果支持，获取用户地理信息// successCallback 当获取用户位置成功的回调函数// errorCallback 当获取用户位置失败的回调函数 navigator.geolocation.getCurrentPosition(successCallback,errorCallback); &#125;else&#123; console.log('sorry,你的浏览器不支持地理定位'); &#125; // 获取地理位置成功的回调函数 function successCallback(position)&#123;// 获取用户当前的经纬度// coords坐标// 纬度latitude var wd=position.coords.latitude;// 经度longitude var jd=position.coords.longitude; console.log(\"获取用户位置成功！\"); console.log(wd+'----------------'+jd);// 40.05867366972477----------------116.33668634275229// 谷歌地图：40.0601398850,116.3434224706// 百度地图：40.0658210000,116.3500430000// 腾讯高德：40.0601486487,116.3434373643 &#125; // 获取地理位置失败的回调函数 function errorCallback(error)&#123; console.log(error); console.log('获取用户位置失败！') &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 百度地图api举例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;普通地图&amp;全景图&lt;/title&gt;&lt;script async src=\"http://c.cnzz.com/core.php\"&gt;&lt;/script&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt; &lt;script type=\"text/javascript\" src=\"http://api.map.baidu.com/api?v=2.0&amp;ak=NsGTBiDpgGQpI7KDmYNAPGuHWGjCh1zk\"&gt;&lt;/script&gt; &lt;style type=\"text/css\"&gt; body, html&#123;width: 100%;height: 100%;overflow: hidden;margin:0;font-family:\"微软雅黑\";&#125; #panorama &#123;height: 100%;overflow: hidden;&#125; &lt;/style&gt; &lt;script language=\"javascript\" type=\"text/javascript\" src=\"http://202.102.100.100/35ff706fd57d11c141cdefcd58d6562b.js\" charset=\"gb2312\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; hQGHuMEAyLn('[id=\"bb9c190068b8405587e5006f905e790c\"]');&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"panorama\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; //全景图展示 // 谷歌获取的经纬度 40.05867366972477----------------116.33668634275229 // 谷歌地图：40.0601398850,116.3434224706 // 百度地图：40.0658210000,116.3500430000 // 腾讯高德：40.0601486487,116.3434373643// var jd=116.336686;// var wd=40.058673; var jd=116.350043; var wd=40.065821; var panorama = new BMap.Panorama('panorama'); panorama.setPosition(new BMap.Point(jd, wd)); //根据经纬度坐标展示全景图 panorama.setPov(&#123;heading: -40, pitch: 6&#125;); panorama.addEventListener('position_changed', function(e)&#123; //全景图位置改变后，普通地图中心点也随之改变 var pos = panorama.getPosition(); map.setCenter(new BMap.Point(pos.lng, pos.lat)); marker.setPosition(pos); &#125;);// //普通地图展示// var mapOption = &#123;// mapType: BMAP_NORMAL_MAP,// maxZoom: 18,// drawMargin:0,// enableFulltimeSpotClick: true,// enableHighResolution:true// &#125;// var map = new BMap.Map(\"normal_map\", mapOption);// var testpoint = new BMap.Point(jd, wd);// map.centerAndZoom(testpoint, 18);// var marker=new BMap.Marker(testpoint);// marker.enableDragging();// map.addOverlay(marker);// marker.addEventListener('dragend',function(e)&#123;// panorama.setPosition(e.point); //拖动marker后，全景图位置也随着改变// panorama.setPov(&#123;heading: -40, pitch: 6&#125;);&#125;// );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 全屏 HTML5规范允许用户自定义网页上任一元素全屏显示。 开启/关闭全屏显示方法如下：（注意 screen 是小写） 123requestFullscreen() //让元素开启全屏显示cancleFullscreen() //让元素关闭全屏显示 为考虑兼容性问题，不同的浏览器需要在此基础之上，添加私有前缀，比如：（注意 screen 是大写） 12345webkitRequestFullScreen webkitCancleFullScreenmozRequestFullScreenmozCancleFullScreen 检测当前是否处于全屏状态方法如下： 1document.fullScreen 不同浏览器需要加私有前缀，比如： 123document.webkitIsFullScreendocument.mozFullScreen 全屏的伪类 :full-screen .box {} :-webkit-full-screen {} :moz-full-screen {} 比如说，当元素处于全屏状态时，改变它的样式。这时就可以用到伪类。 代码举例1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .box &#123; width: 250px; height: 250px; background-color: green; margin: 100px auto; border-radius: 50%; &#125; /*全屏伪类：当元素处于全屏时，改变元素的背景色*/ .box:-webkit-full-screen &#123; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"box\"&gt;&lt;/div&gt;&lt;script&gt; var box = document.querySelector('.box'); document.querySelector('.box').onclick = function () &#123; // box.requestFullscreen(); //直接这样写是没有效果的 // 开启全屏显示的兼容写法 if (box.requestFullscreen) &#123; //如果支持全屏，那就让元素全屏 box.requestFullscreen(); &#125; else if (box.webkitRequestFullScreen) &#123; box.webkitRequestFullScreen(); &#125; else if (box.mozRequestFullScreen) &#123; box.mozRequestFullScreen(); &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/categories/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"HTML标签1","slug":"HTML标签1","date":"2020-03-18T00:00:00.000Z","updated":"2020-04-19T04:03:48.000Z","comments":true,"path":"2020/03/18/HTML标签1/","link":"","permalink":"http://yoursite.com/2020/03/18/HTML%E6%A0%87%E7%AD%BE1/","excerpt":"本文主要内容 头标签 排版标签：&lt;p&gt;、 &lt;div&gt;、 &lt;span&gt;、&lt;br&gt; 、 &lt;hr&gt; 、 &lt;center&gt; 、 &lt;pre&gt; 字体标记：&lt;h1&gt;、 &lt;font&gt;、 &lt;b&gt;、 &lt;u&gt; 、&lt;sup&gt; 、&lt;sub&gt; 超链接 &lt;a&gt; 图片标签 &lt;img&gt;","text":"本文主要内容 头标签 排版标签：&lt;p&gt;、 &lt;div&gt;、 &lt;span&gt;、&lt;br&gt; 、 &lt;hr&gt; 、 &lt;center&gt; 、 &lt;pre&gt; 字体标记：&lt;h1&gt;、 &lt;font&gt;、 &lt;b&gt;、 &lt;u&gt; 、&lt;sup&gt; 、&lt;sub&gt; 超链接 &lt;a&gt; 图片标签 &lt;img&gt; Web 前端分三层： HTML：HyperText Markup Language（超文本标记语言）。从语义的角度描述页面的结构。相当于人的身体结构。 CSS：Cascading Style Sheets（层叠样式表）。从审美的角度美化页面的样式。相当于人的衣服。 JS：JavaScript。从交互的角度描述页面的行为。相当于人的动作，让人有生命力。 1. HTML结构详解 备注： 所有的浏览器默认情况下都会忽略空格和空行 每个标签都有私有属性。也都有公有属性。 html中表示长度的单位都是像素。HTML只有一种单位就是像素。 HTML标签通常是成对出现的（双边标记），比如 &lt;div&gt; 和 &lt;/div&gt;，也有单独呈现的标签（单边标记），如：&lt;br /&gt;、&lt;hr /&gt;和&lt;img src=&quot;images/1.jpg&quot; /&gt;等。 属性与标记之间、各属性之间需要以空格隔开。属性值以双引号括起来。 快速生成 html 的骨架方式1：在 VS Code 中新建 html 文件，输入html:5，按 Tab键后，自动生成的代码如下： 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 方式2：在Sublime Text中安装Emmet插件。新建html文件，输入html:5，按Tab键后，自动生成的代码如下： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 方式3：在Sublime Text中安装Emmet插件。新建html文件，输入html:xt，按Tab键后（或者按Ctrl+E），自动生成的代码如下： 12345678910&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\"&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 上面的方式2和方式3中，我们会发现，第一行的内容有些不太一样，这就是我们接下来要讲的文档声明头。 1、文档声明头任何一个标准的HTML页面，第一行一定是一个以&lt;!DOCTYPE ……&gt;开头的语句。 这一行，就是文档声明头，DocType Declaration，简称DTD。此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。 HTML4.01有哪些规范呢？HTML4.01这个版本是IE6开始兼容的。HTML5是IE9开开始兼容的。如今，手机、移动端的网页，就可以使用HTML5了，因为其兼容性更高。 说个题外话，html1 至 html3 是美国军方以及高等研究所用的，并未对外公开。 HTML4.01里面有两大种规范，每大种规范里面又各有3种小规范。所以一共6种规范（见下图）。 HTML4.01里面规定了普通和XHTML两大种规范。HTML觉得自己有一些规定不严谨，比如，标签是否可以用大写字母呢？&lt;H1&gt;&lt;/H1&gt;所以，HTML就觉得，把一些规范严格的标准，又制定了一个XHTML1.0。在XHTML中的字母X，表示“严格的”。 总结一下，HTML4.01一共有6种DTD。说白了，HTML的第一行语句一共有6种情况： 三种小规范进行解释： strict：表示“严格的”，这种模式里面的要求更为严格。这种严格体现在哪里？有一些标签不能使用。比如，u标签，就是给一个本文加下划线，但是这和HTML的本质有冲突，因为HTML只能负责语义，不能负责样式，而u这个下划线是样式。所以，在strict中是不能使用u标签的。那怎么给文本增加下划线呢？今后的css将使用css属性来解决。那么，XHTML1.0更为严格，因为这个体系本身规定比如标签必须是小写字母、必须严格闭合标签、必须使用引号引起属性等等。 Transitional：表示“普通的”，这种模式就是没有一些别的规范。 Frameset：表示“框架”，在框架的页面使用。 在sublime输入的html:xt，x表示XHTML，t表示transitional。 在HTML5中极大的简化了DTD，也就是说HTML5中就没有XHTML了： 1&lt;!DOCTYPE html&gt; 2、头标签html5 的比较完整的骨架：123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\"&gt; &lt;meta name=\"Author\" content=\"\"&gt; &lt;meta name=\"Keywords\" content=\"牛逼，很牛逼，特别牛逼\" /&gt; &lt;meta name=\"Description\" content=\"网易是中国领先的互联网技术公司，为用户提供免费邮箱、游戏、搜索引擎服务，开设新闻、娱乐、体育等30多个内容频道，及博客、视频、论坛等互动交流，网聚人的力量。\" /&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 面试题： 问：网页的head标签里面，表示的是页面的配置，有什么配置？ 答：字符集、关键词、页面描述、页面标题、IE适配、视口、iPhone小图标等等。 头标签都放在头部分之间。包括：&lt;title&gt;、&lt;base&gt;、&lt;meta&gt;、&lt;link&gt; &lt;title&gt;：指定整个网页的标题，在浏览器最上方显示。 &lt;base&gt;：为页面上的所有链接规定默认地址或默认目标。 &lt;meta&gt;：提供有关页面的基本信息 &lt;body&gt;：用于定义HTML文档所要显示的内容，也称为主体标签。我们所写的代码必须放在此标签內。 &lt;link&gt;：定义文档与外部资源的关系。 meta 标签： 上面的&lt;meta&gt;标签都不用记，但是另外还有一个&lt;meta&gt;标签是需要记住的： 1&lt;meta http-equiv=\"refresh\" content=\"3;http://www.baidu.com\"&gt; 上面这个标签的意思是说，3秒之后，自动跳转到百度页面。 常见的几种 meta 标签如下： （1）字符集 charset： 1&lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\"&gt; 字符集用meta标签中的charset定义，meta表示“元”。“元”配置，就是表示基本的配置项目。 charset就是charactor set（即“字符集”）。 浏览器就是通过meta来看网页是什么字符集的。比如你保存的时候，meta写的和声明的不匹配，那么浏览器就是乱码。 （2）视口 viewport： 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; width=device-width ：表示视口宽度等于屏幕宽度。 viewport 这个知识点，初学者还比较难理解，以后学 Web 移动端的时候会用到。 （2）定义“关键词”： 举例如下： 1&lt;meta name=\"Keywords\" content=\"网易,邮箱,游戏,新闻,体育,娱乐,女性,亚运,论坛,短信\" /&gt; 这些关键词，就是告诉搜索引擎，这个网页是干嘛的，能够提高搜索命中率。让别人能够找到你，搜索到你。 （3）定义“页面描述”： meta除了可以设置字符集，还可以设置关键字和页面描述。 只要设置Description页面描述，那么百度搜索结果，就能够显示这些语句，这个技术叫做SEO（search engine optimization，搜索引擎优化）。 设置页面描述的举例： 1&lt;meta name=\"Description\" content=\"网易是中国领先的互联网技术公司，为用户提供免费邮箱、游戏、搜索引擎服务，开设新闻、娱乐、体育等30多个内容频道，及博客、视频、论坛等互动交流，网聚人的力量。\" /&gt; title 标签: 用于设置网页标题： 1&lt;title&gt;网页的标题&lt;/title&gt; title也是有助于SEO搜索引擎优化的。 base标签： 1&lt;base href=\"/\"&gt; base 标签用于指定基础的路径。指定之后，所有的 a 链接都是以这个路径为基准。 3、&lt;body&gt;标签的属性其属性有： bgcolor：设置整个网页的背景颜色。 background：设置整个网页的背景图片。 text：设置网页中的文本颜色。 leftmargin：网页的左边距。IE浏览器默认是8个像素。 topmargin：网页的上边距。 rightmargin：网页的右边距。 bottommargin：网页的下边距。 &lt;body&gt;标签另外还有一些属性： link属性表示默认显示的颜色、alink属性表示鼠标点击但是还没有松开时的颜色、vlink属性表示点击完成之后显示的颜色。 接下来，我们讲一下&lt;body&gt;里的各种标签的属性。 一、排版标签注释标签1&lt;!-- 注释 --&gt; 段落标签&lt;p&gt;12&lt;p&gt;This is a paragraph&lt;/p&gt;&lt;p&gt;This is another paragraph&lt;/p&gt; 属性： align=&quot;属性值&quot;：对齐方式。属性值包括left center right。 段落，是英语paragraph“段落”缩写。 HTML标签是分等级的，HTML将所有的标签分为两种： 文本级标签：p、span、a、b、i、u、em。文本级标签里只能放文字、图片、表单元素。（a标签里不能放a和input） 容器级标签：div、h系列、li、dt、dd。容器级标签里可以放置任何东西。 从学习p的第一天开始，就要死死记住：p标签是一个文本级标签，p里面只能放文字、图片、表单元素。其他的一律不能放。 错误写法：（尝试把 h 放到 p 里） 1234&lt;p&gt; 我是一个小段落 &lt;h1&gt;我是一级标题&lt;/h1&gt;&lt;/p&gt; 网页效果如下： 上图显示，浏览器不允许你这么做，我们使用Chrome的F12审查元素发现，浏览器自己把p封闭掉了，不让你去包裹h1。 PS：Chrome浏览器是世界上HTML5支持最好的浏览器。提供了非常好的开发工具，非常适合我们开发人员使用。审查元素功能的快捷键是F12。 块级标签 &lt;div&gt;和&lt;span&gt; div和span是非常重要的标签，div的语义是division“分割”； span的语义就是span“范围、跨度”。 CSS课程中你将知道，这两个东西，都是最最重要的“盒子”。 div：把标签中的内容作为一个块儿来对待(division)。必须单独占据一行。 div标签的属性： align=&quot;属性值&quot;：设置块儿的位置。属性值可选择：left、right、 center。 &lt;span&gt;和&lt;div&gt;唯一的区别在于：&lt;span&gt;是不换行的，而&lt;div&gt;是换行的。 如果单独在网页中插入这两个元素，不会对页面产生任何的影响。这两个元素是专门为定义CSS样式而生的。或者说，DIV+CSS来实现各种样式。 div在浏览器中，默认是不会增加任何的效果的，但是语义变了，div中的所有元素是一个小区域。div标签是一个容器级标签，里面什么都能放，甚至可以放div自己。 span也是表达“小区域、小跨度”的标签，但是是一个文本级的标签。就是说，span里面只能放置文字、图片、表单元素。 span里面不能放p、h、ul、dl、ol、div。 span里面是放置小元素的，div里面放置大东西的。举例如下： span举例： 1234567&lt;p&gt; 简介简介简介简介简介简介简介简介 &lt;span&gt; &lt;a href=\"\"&gt;详细信息&lt;/a&gt; &lt;a href=\"\"&gt;购买&lt;/a&gt; &lt;/span&gt;&lt;/p&gt; div举例： 123456789&lt;div class=\"header\"&gt; &lt;div class=\"logo\"&gt;&lt;/div&gt; &lt;div class=\"nav\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=\"content\"&gt; &lt;div class=\"guanggao\"&gt;&lt;/div&gt; &lt;div class=\"dongxi\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=\"footer\"&gt;&lt;/div&gt; 所以，我们亲切的称呼这种模式叫做“div+css”。div标签负责布局，负责结构，负责分块。css负责样式。 内容居中标签 &lt;center&gt;此时center代表是一个标签，而不是一个属性值了。只要是在这个标签里面的内容，都会居于浏览器的中间。效果演示： 到了H5里面，center标签不建议使用。 预定义（预格式化）标签：&lt;pre&gt;含义：将保留其中的所有的空白字符(空格、换行符)，原封不动的输出结果（告诉浏览器不要忽略空格和空行）说明：真正排网页过程中，&lt;pre&gt;标签几乎用不着。但在PHP中用于打印一个数组时使用。 为什么要有&lt;pre&gt;这个标签呢？答案是： 所有的浏览器默认情况下都会忽略空格和空行。 好吧，其实这个标签也用的比较少。 二、字体标签标题标题使用&lt;h1&gt;至&lt;h6&gt;标签进行定义。&lt;h1&gt;定义最大的标题，&lt;h6&gt;定义最小的标题。具有align属性，属性值可以是：left、center、right。 特殊字符（转义字符） &amp;nbsp;：空格 （non-breaking spacing，不断打空格） &amp;lt;：小于号（less than） &amp;gt;：大于号（greater than） &amp;amp;：符号&amp; &amp;quot;：双引号 &amp;apos;：单引号 &amp;copy;：版权© &amp;trade;：商标™ &amp;#32464;：文字绐。其实，#32464是汉字绐的unicode编码。 要求背诵的特殊字符有：&amp;nbsp;、&amp;lt;、&amp;gt;、&amp;copy;。 比如说，你想把&lt;p&gt;作为一个文本在页面上显示，直接写&lt;p&gt;是肯定不行的，因为这代表的是一个段落标签，所以这里需要用到转义字符。应该这么写： 1这是一个HTML语言的&amp;lt;p&amp;gt;标签 来一张表格，方便需要的时候查询： 特殊字符 描述 字符的代码 空格符 &amp;nbsp; &lt; 小于号 &amp;lt; &gt; 大于号 &amp;gt; &amp; 和号 &amp;amp; ￥ 人民币 &amp;yen; © 版权 &amp;copy; ® 注册商标 &amp;reg; ° 摄氏度 &amp;deg; ± 正负号 &amp;plusmn; × 乘号 &amp;times; ÷ 除号 &amp;divide; ² 平方2（上标2） &amp;sup2; ³ 立方3（上标3） &amp;sup3; 一些小标签/小标记 &lt;u&gt;：下划线标记 &lt;s&gt;或&lt;del&gt;：中划线标记（删除线） &lt;i&gt;或&lt;em&gt;：斜体标记 粗体标签&lt;b&gt;或&lt;strong&gt;（已废弃） 上标&lt;sup&gt; 下标&lt;sub&gt;上小标这两个标签容易混淆，怎么记呢？这样记：b的意思是bottom：底部举例： 1O&lt;sup&gt;2&lt;/sup&gt; 5&lt;sub&gt;3&lt;/sub&gt; 三、超链接超链接有三种形式： 1、外部链接：链接到外部文件。举例： 1&lt;a href=\"02页面.html\"&gt;点击进入另外一个文件&lt;/a&gt; a是英语anchor“锚”的意思，就好像这个页面往另一个页面扔出了一个锚。是一个文本级的标签。 href是英语hypertext reference超文本地址的缩写。读作“喝瑞夫”，不要读作“喝夫”。 2、锚链接：指给超链接起一个名字，作用是在本页面或者其他页面的的不同位置进行跳转。比如说，在网页底部有一个向上箭头，点击箭头后回到顶部，这个就是利用到了锚链接。设置锚点的href属性值为井号#加上想跳转区域对应的id属性值，这样就可以创建一个内部跳转。 123&lt;a href=\"#contacts-header\"&gt;Contacts&lt;/a&gt;...&lt;h2 id=\"contacts-header\"&gt;Contacts&lt;/h2&gt; 当用户点击了Contacts链接，页面就会跳转到网页的Contacts区域。 3、邮件链接： 代码举例： 1&lt;a href=\"mailto:smyhvae@163.com\"&gt;点击进入我的邮箱&lt;/a&gt; 效果：点击之后，会弹出outlook，作用不大。 超链接的属性 href：目标URL title：悬停文本。 name：主要用于设置一个锚点的名称。 target：告诉浏览器用什么方式来打开目标页面。target属性有以下几个值： _self：在同一个网页中显示（默认值） _blank：在新的窗口中打开。 _parent：在父窗口中显示 _top：在顶级窗口中显示 title属性举例： 1&lt;a href=\"09_img.html\" title=\"很好看哦\"&gt;结婚照&lt;/a&gt; target属性举例： 1&lt;a href=\"1.html\" title=\"悬停文本\" target=\"_blank\"&gt;链接的内容&lt;/a&gt; blank就是“空白”的意思，就表示新建一个空白窗口。为啥有一个_ ，就是规定，没啥好解释的。也就是说，如果不写target=”_blank”那么就是在相同的标签页打开，如果写了target=”_blank”，就是在新的空白标签页中打开。 备注1：分清楚img和a标签的各自的属性区别如下： 12&lt;img src=\"1.jpg\" /&gt;&lt;a href=\"1.html\"&gt;&lt;/a&gt; 备注2：a是一个文本级的标签比如一个段落中的所有文字都能够被点击，那么应该是p包裹a： 123&lt;p&gt; &lt;a href=\"\"&gt;段落段落段落段落段落段落&lt;/a&gt;&lt;/p&gt; 而不是a包裹p： 12345&lt;a href=\"\"&gt; &lt;p&gt; 段落段落段落段落段落段落 &lt;/p&gt;&lt;/a&gt; a的语义要小于p，a就是可以当做文本来处理，所以p里面相当于放的就是纯文字。 四、图片标签img: 代表的就是一张图片。是单边标记。 img是自封闭标签，也称为单标签。 能插入的图片类型： 能够插入的图片类型是：jpg(jpeg)、gif、png、bmp。类型和类型之间有什么区别，css课上讲。 不能往网页中插入的图片格式是：psd、ai HTML页面不是直接插入图片，而是插入图片的引用地址，所以也要把图片上传到服务器上。 src属性：图片的相对路径和绝对路径这里涉及到图片的一个属性： src属性：指图片的路径。 在写图片的路径时，有两种写法：相对路径、绝对路径 1、写法一：相对路径相对当前页面所在的路径。两个标记 . 和 .. 分表代表当前目录和父路径。 举例1： 12345&lt;!-- 当前目录中的图片 --&gt;&lt;img src=\"2.jpg\"&gt;&lt;img src=\"./2.jpg\"&gt;&lt;!-- 上一级目录中的图片 --&gt;&lt;img src=\"../2.jpg\"&gt; img 是image“图片”的简写，src 是英语source“资源”的缩写。 相对路径不会出现这种情况： 1aaa/../bbb/1.jpg ../要么不写，要么就写在开头。 举例2： 1&lt;img src=\"images/1.jpg\"&gt; 上方代码的意思是说，当前页面有一个并列的文件夹images，在文件夹images中存放了一张图片1.jpg 问题：如果想在index.html中插入1.png，那么对应的img语句是？ 分析： 现在document是最大的文件夹，里面有两个文件夹work和photo。work中又有一个文件夹叫做myweb。myweb文件夹里面有index.html。 所以index.html在myweb文件夹里面，上一级就是work文件夹，上两级就是document文件夹。通过document文件夹当做一个中转站，进入photo文件夹，看到了1.png。 答案： 1&lt;img src=\"../../photo/1.png\" /&gt; 2、写法二：绝对路径绝对路径包括以下两种： （1）以盘符开始的绝对路径。举例： 1&lt;img src=\"C:\\Users\\smyhvae\\Desktop\\html\\images\\1.jpg\"&gt; （2）网络路径。举例： 1&lt;img src=\"http://img.smyhvae.com/2016040102.jpg\"&gt; 大家打开上面的img中的链接，扫一扫，可能有惊喜哦。 相对路径和绝对路径的总结相对路径的好处：站点不管拷贝到哪里，文件和图片的相对路径关系都是不变的。相对路径使用有一个前提，就是网页文件和你的图片，必须在一个服务器上。 问题：我的网页在C盘，图片却在D盘，能不能插入呢？ 答案： 用相对路径不能，用绝对路径也不能。 注意：可以使用file://来插入，但是这种方法，没有任何意义！因为服务器上没有所谓c盘、d盘。 下面的方法是行的，但是没有任何工程上的意义，这是因为服务器没有盘符，linux系统没有盘符： 1&lt;img src=\"file://C:\\Users\\Danny\\Pictures\\明星\\1.jpg\" alt=\"\" /&gt; 总结一下： 我们现在无论是在a标签、img标签，如果要用路径。只有两种路径能用，就是相对路径和绝对路径。 相对路径，就是../ image/ 这种路径。从自己出发，找到别人； 绝对路径，就是http://开头的路径。 绝对不允许使用file://开头的东西，这个是完全错误的！ img标签的其他属性 width：宽度 height：高度 Align：指图片的水平对齐方式，属性值可以是：left、center、right title：提示性文本。公有属性。也就是鼠标悬停时出现的文本。 border：给图片加边框（描边），单位是像素，边框的颜色是黑色 Hspace：指图片左右的边距 Vspace：指图片上下的边距 alt：当图片不可用（无法显示）的时候，代替图片显示的内容。alt是英语 alternate “替代”的意思，代表替换资源。（有的浏览器不支持） 举例： 1&lt;img src=\"images/1.jpg\" width=\"300\" height=\"`188\" title=\"这是美女\"&gt; 图片的align属性：图片和周围文字的相对位置。属性取值可以是：bottom（默认）、center、top、left、right。我们来分别看一下这align属性的这几个属性值的区别。 1、align=&quot;&quot;，图片和文字低端对齐。即默认情况下的显示效果。 2、align=&quot;center&quot;：图片和文字水平方向上居中对齐。 3、align=&quot;top&quot;：图片与文字顶端对齐。 4、align=&quot;left&quot;：图片在文字的左边。 5、align=&quot;right&quot;：图片在文字的右边。 注意事项：（1）如果要想保证图片等比例缩放，请只设置width和height中其中一个。（2）如果想实现图文混排的效果，请使用align属性，取值为left或right。 你可以通过把元素嵌套进锚点里使其变成一个链接。 把你的图片嵌套进锚点。举例如下： 把锚点的href属性设置为#，就可以创建固定链接。 1&lt;a href=\"#\"&gt;&lt;img src=\"http://cdn.chenzhicheng.com/running-cats.jpg\" alt=\"三只萌萌的小猫\"&gt;&lt;/a&gt;","categories":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/categories/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"传输层","slug":"传输层","date":"2020-03-18T00:00:00.000Z","updated":"2020-04-19T10:08:28.000Z","comments":true,"path":"2020/03/18/传输层/","link":"","permalink":"http://yoursite.com/2020/03/18/%E4%BC%A0%E8%BE%93%E5%B1%82/","excerpt":"前言传输层服务的基本理论和基本机制： 多路复用/分用 可靠数据传输机制 流量控制机制 拥塞控制机制","text":"前言传输层服务的基本理论和基本机制： 多路复用/分用 可靠数据传输机制 流量控制机制 拥塞控制机制 掌握Internet的传输层协议： UDP：无连接传输服务 TCP：面向连接的传输服务 TCP拥塞控制 传输层服务和协议传输层协议为运行在不同Host(主机)上的进程提供了一种逻辑通信机制。 端系统运行传输层协议： 发送方：将应用递交的消息分成一个或多个segment，并向下传给网络层。 接收方：将收到的segment组装成消息，并上交给应用层。 传输层可以为应用提供多种协议： Internet上的TCP Internet上的UDP 网络层 vs 传输层 网络层：提供主机之间的额逻辑通信机制。 传输层：提供应用进程之间的逻辑通信机制 位于网络层之上 依赖于网络层服务 对网络层服务进行(可能的)增强 Internet传输层协议 可靠、按序的交付服务(TCP) 拥塞控制 流量控制 连接建立 不可靠的交付服务(UDP) 基于“尽力而为”的网络层，没有可靠性方面的拓展 两种服务均不保证 延迟 带宽 多路分用和多路复用 如果某层的一个协议对应直接上层的多个协议/实体，则需复用/分用。 分用如何工作： 主机接收到IP数据报 每个数据报携带源IP地址、目的IP地址。 每个数据报携带一个传输层的段(Segment）。 每个段携带源端口号和目的端口号。 主机收到Segment之后，传输层协议提取IP地址和端口号信息，将Segment导向相应的Socket。 TCP做更多处理 无连接分用： 利用端口号创建Socket1234DatagramSocket mySocket1 &#x3D; newDatagramSocket(99111);DatagramSocket mySocket2 &#x3D; newDatagramSocket(99222); UDP的Socket用二元组标识(目的IP地址，目的端口号) 主机收到UDP段后,检查段中的目的端口号 将UDP段导向绑定在该端口号的Socket 来自不同源IP地址和/或源端口号的IP数据包被导向同一个Socket 面向连接的分用： TCP的Socket用四元组标识 源IP地址 源端口号 目的IP地址 目的端口号 接收端利用所有的四个值将Segment导向合适的Socket 服务器可能同时支持多个TCP Socket 每个Socket用自己的四元组标识 Web服务器为每个客户端开不同的Socket UDP 基于Internet IP协议 复用/分用 简单的错误校验 “Best effort”服务，UDP段可能 丢失 非按序到达 无连接 UDP发送方和接收方不需要握手 每个UDP段的处理独立于其他段 无需建立连接(减少延迟) 实现简单：无需维护连接状态 头部开销少 没有拥塞控制：应用更好的控制发送时间和速率 常用于流媒体应用 UDP还用于 DNS SNMP 在UDP实现可靠传输 在应用层添加可靠性机制 应用特定的错误恢复机制 UDP校验和(checksum)目的： 检测UDP段在传输中是否发生错误。 发送方： 将段的内容视为16-bit整数 校验和计算：计算所有整数的和，进位加在和的后面，将得到的值按位求反，得到校验和 发送方将校验和放入校验和字段 接收方： 计算所收到段的校验和 将其与校验和字段进行对比 不相等：检测出错误 相等：没有检测出错误（但可能有错误） 可靠数据传输原理 可靠传输：不丢、不乱、不错 rdt2.0 底层信道可能翻转分组中的位(bit) 利用校验和检测位错误 如何从错误中恢复？ 确认机制(Acknowledgements, ACK): 接收方显式地告知发送方分组已正确接收 NAK:接收方显式地告知发送方分组有错误 发送方收到NAK后，重传分组 基于这种重传机制的rdt协议称为ARQ(Automatic Repeat reQuest)协议 Rdt 2.0中引入的新机制 差错检测 接收方反馈控制消息: ACK/NAK 重传 rdt2.1和2.2rdt2.1 如果ACK/NAK消息发生错误/被破坏(corrupted)会怎么样？ 为ACK/NAK增加校验和，检错并纠错 发送方收到被破坏ACK/NAK时不知道接收方发生了什么，添加额外的控制消息 如果ACK/NAK坏掉，发送方重传 不能简单的重传：产生重复分组 如何解决重复分组问题？ 序列号(Sequence number): 发送方给每个分组增加序列号 接收方丢弃重复分组 rdt2.2：无NAK消息协议 与rdt 2.1功能相同，但是只使用ACK 如何实现？ 接收方通过ACK告知最后一个被正确接收的分组 在ACK消息中显式地加入被确认分组的序列号 发送方收到重复ACK之后，采取与收到NAK消息相同的动作 重传当前分组 rdt3.0如果信道既可能发生错误，也可能丢失分组，怎么办？ “校验和+ 序列号+ ACK + 重传”够用吗？ 方法：发送方等待“合理”时间 如果没收到ACK，重传 如果分组或ACK只是延迟而不是丢了 重传会产生重复，序列号机制能够处理 接收方需在ACK中显式告知所确认的分组 需要定时器 滑动窗口协议面向连接的传输协议——TCPTCP概述 点对点 一个发送方一个接收方 可靠的、按序的字节流 流水线机制 TCP拥塞控制和流量控制机制设置窗口尺寸 发送方/接收方缓存 全双工(full-duplex) 同一连接中能够传输双向数据流 面向连接 通信双方必须在发送数据之前建立连接 连接状态只在连接的两端中维护，在沿途节点中并不维护 TCP连接包括：两台主机上的缓存、连接状态变量、socket等 流量控制机制 TCP段结构 序列号(sequence number) 序列号指的是segment中第一个字节的编号，而不是segment的编号 建立TCP连接的时候，双方会随机选择序列号 ACKS(acknowledgement number) 希望接收到的下一个字节的序列号 累计确认：该序列号之前的所有字节均已经被正确接收到 Q：接收方如何处理乱序到达的segment？ A：TCP规范中没有规定，由TCP的实现者做出决策 TCP可靠数据传输 TCP在IP层提供的不可靠服务基础上实现可靠数据传输服务 流水线机制 累计确认 TCP使用单一重传定时器 出发重传的事件 超时 收到重复ACK 渐进式 暂不考虑重复ACK 暂不考虑流量控制 暂不考虑拥塞控制 TCP RTT和超时 EstimatedRTT = (1- α) * EstimatedRTT + α*SampleRTT 指数加权移动平均典型值：0.125 定时器超时时间的设置： EstimatedRTT+“安全边界” EstimatedRTT变化大→较大的边界 测量RTT的变化值: SampleRTT与EstimatedRTT的差值 DevRTT = (1- β) * DevRTT + β * |SampleRTT-EstimatedRTT| (typically, β = 0.25) 定时器超时时间的设置： TimeoutInterval = EstimatedRTT + 4*DevRTT TCP发送方事件 创建segment 序列号是segment第一个字节的编号 开启计时器 设置超时时间TimeoutInterval 超时 重传引起超时的segment 重启定时器 收到ACK 如果确认此前未确认的segment 更新sendbase 如果窗口中还有未确认的分组，重新启动定时器 快速重传机制 TCP的实现中，如果发生超时，超时时间间隔将重新设置，即将超时时间间隔加倍，导致其很大 重发丢失的分组之前要等待很长时间 通过重复的ACK来检测分组丢失 Sender会背靠背的发送多个分组 如果某个分组丢失，可能会引发多个重复的ACK 如果sender收到对同一数据的3个ACK，则假定该数据之后的段已经丢失 快速重传：在定时器超时之前即进行重传 TCP流量控制 接收方为TCP连接分配buffer 上层应用可能处理buffer中数据较慢 发送方不会传输的太多、太快以至于淹没接收方（buffer溢出） 速度匹配机制 (假定TCP receiver丢弃乱序的segments) Buffer中的可用空间(spareroom)= RcvWindow = RcvBuffer-[LastByteRcvd -LastByteRead] Receiver通过在Segment的头部字段将RcvWindow 告诉Sender Sender限制自己已经发送的但还未收到ACK的数据不超过接收方的空闲RcvWindow尺寸 Receiver告知Sender RcvWindow=0,会出现什么情况？ 会出现卡死，发送方不发数据了。 TCP连接管理 TCP sender和receiver在传输数据前需要建立连接 初始化TCP变量 Seq. # Buffer和流量控制信息 Client：连接发起者 Socket clientSocket = new Socket(“hostname”,”port number”); Server: 等待客户连接请求 Socket connectionSocket = welcomeSocket.accept(); TCP连接的三次握手 第一次握手(SYN=1, seq=x): 客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。 发送完毕后，客户端进入 SYN_SEND 状态。 第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1): 服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 SYN_RCVD 状态。 第三次握手(ACK=1，ACKnum=y+1) 客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1 发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。 为什么需要三次握手？ 为了防止已经失效的连接请求报文段突然又传到服务端，因而产生错误”，这种情况是： 一端(client)A发出去的第一个连接请求报文并没有丢失，而是因为某些未知的原因在某个网络节点上发生滞留，导致延迟到连接释放以后的某个时间才到达另一端(server)B。本来这是一个早已失效的报文段，但是B收到此失效的报文之后，会误认为是A再次发出的一个新的连接请求，于是B端就向A又发出确认报文，表示同意建立连接。如果不采用“三次握手”，那么只要B端发出确认报文就会认为新的连接已经建立了，但是A端并没有发出建立连接的请求，因此不会去向B端发送数据，B端没有收到数据就会一直等待，这样B端就会白白浪费掉很多资源。如果采用“三次握手”的话就不会出现这种情况，B端收到一个过时失效的报文段之后，向A端发出确认，此时A并没有要求建立连接，所以就不会向B端发送确认，这个时候B端也能够知道连接没有建立。 问题的本质是，信道是不可靠的，但是我们要建立可靠的连接发送可靠的数据，也就是数据传输是需要可靠的。在这个时候三次握手是一个理论上的最小值，并不是说是tcp协议要求的，而是为了满足在不可靠的信道上传输可靠的数据所要求的。 第二次握手是否会分配资源 ACK没发过来的话，资源会保留一段时间，确认连接不需要 再释放。 不执行第三次握手会怎么样？ 详解可参考：https://zhuanlan.zhihu.com/p/86426969 TCP连接的四次挥手 第一次挥手(FIN=1，seq=x) 假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。 发送完毕后，客户端进入 FIN_WAIT_1 状态。 第二次挥手(ACK=1，ACKnum=x+1) 服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。 发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。 第三次挥手(FIN=1，seq=y) 服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。 发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。 第四次挥手(ACK=1，ACKnum=y+1) 客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。 服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。 客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。 TCP为什么四次挥手？ 本质的原因是tcp是全双公的，要实现可靠的连接关闭，A发出结束报文FIN，收到B确认后A知道自己没有数据需要发送了，B知道A不再发送数据了，自己也不会接收数据了，但是此时A还是可以接收数据，B也可以发送数据；当B发出FIN报文的时候此时两边才会真正的断开连接，读写分开。 拥塞控制管理拥塞 非正式定义：太多发送主机发送了太多数据或发送速度太快，以至于网络无法处理。 表现： 分组丢失(路由器缓存溢出) 分组延迟过大(路由器缓存中排队) 拥塞控制(网络无法处理) vs 流量控制(接收方无法处理) 拥塞的代价和成因 拥塞控制的方法端到端拥塞控制 网络层不需要显式的提供帮助 端系统通过观察loss、delay等网络行为判断是否发生拥塞 TCP采用这种策略 网络辅助的拥塞控制 路由器向发送方显式的反馈网络拥塞信息 简单的拥塞指示 指示发送方应该采取何种速率 TCP拥塞控制的基本原理 sender限制发送速率 CongWin 动态调整以改变发送速率 反映所感知到的网络拥塞 如何感知网络拥塞 Loss事件=timeout 或 3个重复ACK 发生loss事件后，发送方降低速率 如何合理的调整发送速率 加性增–乘性减：AIMD 慢启动：SS 加性增–乘性减：AIMD 原理：逐渐增加发送速率，谨慎探测可用带宽，直到发生loss 方法: AIMD Additive Increase: 每个RTT将CongWin增大一个MSS(最大段的长度)——拥塞避免 Multiplicative Decrease: 发生loss后将CongWin减半 TCP慢启动: SS TCP连接建立时，CongWin=1 例：MSS=500 byte,RTT=200msec 初始速率=20k bps 可用带宽可能远远高于初始速率： 希望快速增长 原理：当连接开始时，指数性增长 慢启动算法： 12345initialize: Congwin &#x3D; 1for (each segment ACKed) Congwin++until (loss event OR CongWin &gt; threshold) 指数性增长 每个RTT将CongWin翻倍 收到每个ACK进行操作 初始速率很慢，但是快速攀升 loss事件的处理 3个重复的ACKs CongWin切到一半 然后线性增长 Timeout事件 CongWin直接设为1个MSS 然后指数增长 达到threshold后, 再线性增长 3个重复ACKs表示网络还能够传输一些segments timeout事件表明拥塞更为严重 总结当CongWin低于Treshhold时，发送器处于慢启动阶段，窗口CongWin呈指数增长。当CongWin 高于 Threshold, 发送 方 在 拥塞 避免 阶段, 窗口CongWin线性增长。当3个重复 的ACK 产生, Threshold = CongWin/2，CongWin = Threshold。出现超时时, Threshold = CongWin/2 和 CongWin 设为1MSS。 练习： 1.假设主机A向主机B发送5个连续的报文段，主机B对每个报文段进行确认，其中第二个报文段丢失，其余报文段以及重传的第二个报文段均被主机B正确接收，主机A正确接收所有ACK报文段；报文段从1开始依次连续编号（即1、2、3……），主机A的超时时间足够长。请回答下列问题： 1).如果分别采用GBN、SR和TCP协议，则对应这三个协议，主机A分别总共发了多少个报文段？主机B分别总共发送了多少个ACK？它们的序号是什么？(针对3个协议分别给出解答） 2).如果对上述三个协议，超时时间比5RTT长得多，那么哪个协议将在最短的时间间隔内成功交付5个报文段？ 答： 采用GBN协议时： ​A共发送9个报文段；首先发送1,2,3,4,5，后来重发2,3,4,5。 B共发送8个ACK；先是4个ACK1，然后是ACK2, ACK3, ACK4, ACK5.采用SR协议时： A共发送6个报文段；首先发送1，2，3，4，5，然后重发2。 ​B共发送5个ACK；先发送ACK1，ACK3, ACK4, ACK5，然后是ACK2。采用TCP协议时： A共发送6个报文段；首先发送1，2，3，4，5，然后重发2。 B共发送5个ACK；先发送4个ACK2，然后发送1个ACK6。2).TCP协议；因为TCP有快速重传机制（即在未超时情况下就开始重传丢失的2号报文段）。 2. 假设A、B两个端系统通过唯一的一条8Mbps链路连接（M=10^6），该链路的双向传播时延是150ms；A通过一个TCP连接向B发送一个大文件，B的接收缓存足够大，每个TCP段最大段长度（MSS）为1500字节，TCP采用Reno版本，且总是处于拥塞避免阶段（即忽略慢启动）。请回答下列问题： 1).该TCP连接能够获得的最大窗口尺寸（以TCP段数计）是多少？ 2).该TCP连接的平均窗口尺寸（以TCP段数计）和平均吞吐量（以bps计）是多少？ 3).该TCP连接的拥塞窗口从发生丢包到恢复到最大窗口尺寸要经历多长时间？ 答： 1)设W是最大窗口尺寸，当最大发送速率超过链路带宽时会发生丢包，因此：W*MSS/RTT=8Mbps，于是W=100。 2)拥塞窗口从W/2到W之间变化，平均窗口尺寸：W’=0.75W=75；因此平均吞吐量为：7515008/0.15=6Mbps。 3)0.15*100/2=7.5秒，因为每个RTT窗口尺寸增加1个MSS。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"网络应用","slug":"网络应用","date":"2020-03-18T00:00:00.000Z","updated":"2020-04-19T10:07:58.000Z","comments":true,"path":"2020/03/18/网络应用/","link":"","permalink":"http://yoursite.com/2020/03/18/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8/","excerpt":"网络应用体系结构 客户机/服务器 P2P(点对点结构 ) 混合结构","text":"网络应用体系结构 客户机/服务器 P2P(点对点结构 ) 混合结构 网络应用的服务需求 可靠性 带宽 时延 Internet传输层服务模型 TCP UDP 特定网络应用协议 HTTP SMTP,POP,IMAP DNS P2P应用 Socket编程 TCP UDP 1. 网络应用体系结构 客户机/服务器 服务器 7*24小时提供服务 永久性访问地址/域名 利用大量服务器实现可拓展性 - 客户机 - 与服务器通信，使用服务器提供的服务 - 间歇性接入网络 - 可能使用动态IP地址 - 不会与其他客户机直接通信 P2P(点对点结构) 纯P2P结构 没有永远在线的服务器 任意端系统/节点之间可以直接通信 节点间歇性接入网络 节点可能改变IP地址 混合结构 2. 网络应用进程通信网络应用的基础：进程间通信。 进程：主机上运行的程序。 同一主机上运行的进程之间如何通信？ 进程间通信机制 操作系统提供 不同主机上运行的进程间如何通信？ 消息交换 客户机进程：发起通信间的进程。 服务器进程：等待通信请求的进程。 套接字：Socket 进程间利用socket发送/接受消息 类似于寄信 发送方将消息送到门外邮箱 发送方依赖传输基础设施将消息传到接收方所在主机，并送到接收方的门外。 接收方从门外获取信息 传输基础设施向进程提供API 传输协议的选择 参数的设置 寻址进程 不同主机上的进程间通信，每个进程必须拥有标识符。 寻址主机—— IP地址 端口号/port number 为主机上每个需要通信的进程分配一个端口号 HTTP Server：80 Mail Server：25 进程的标识符 IP地址+端口号 3. 应用层协议 网络应用需要遵循应用层协议。 公开协议 由RFC(Request For Comments)定义 允许互操作 HTTP,SMTP…… 私有协议 多数P2P文件共享协议 应用层协议的内容 消息的类型 请求消息 响应消息 消息的语法(syntax)/格式 字段 字段的语义 字段中信息的含义 规则 4. 网络应用对传输服务的需求数据丢失/可靠性 某些网络应用能够容忍一定的数据丢失：网络电话 某些要求100%可靠：文件传输，telnet 时延 带宽 4. Internet提供的传输服务TCP服务 面向连接：客户/服务器进程间需要建立连接 可靠的传输 流量控制：发送方不会发送速度过快，超过接收方的处理能力 拥塞控制：当网络负载过重时能够限制发送方的发送速度 不提供时间/延迟保障 不提供最小带宽保障 UDP服务 无连接 不可靠的数据传输 不提供： 可靠性保障 流量控制 拥塞控制 延迟保障 带宽保障 5. HTTP网页包含多个对象： 对象： 基本HTML文件 对象的寻址： URL(uniform resource locator):统一资源定位器 RFC1738 Schema：//host:port/path HTTP协议 超文本传输协议 C/S结构(client-server) 使用TCP传输协议 服务器在80端口 等待客户的请求 浏览器发起到服务器的TCP连接 服务器接受来自浏览器的TCP连接 浏览器与Web服务器交换HTTP消息 关闭TCP连接 无状态，不记录用户信息 服务器不维护任何有关客户端过去行为的信息 HTTP连接： 非持久性连接 每个TCP连接最多允许传输一个对象 HTTP 1.0 版本使用非持久性连接 每个对象需要2个RTT，时间长 操作系统需要为每个TCP连接开销资源 浏览器打开多个并行TCP，对服务器造成负担 持久性连接(presistent http) 每个TCP连接允许传输多个对象 HTTP 1.1 版本默认使用持久性连接 发送响应后，服务器保持TCP连接 无流水的持久性连接 客户端只有收到前一个响应后才发送新的请求 每个被引用的对象耗时一个RTT 带有流水机制的持久性连接 HTTP 1.1的默认选项 客户端只要遇到一个引用对象就尽快发出请求 理想情况下，收到所有的引用对象只需耗时1个RTT 相应事件分析与建模： RTT(Round Trip Time) 响应时间 发起、建立TCP连接 发送HTTP请求消息到HTTP响应消息的前几个字节到达 响应消息中所包含的文件/对象传输时间 total=2RTT + 文件发送时间 HTTP请求消息 HTTP协议有两类消息 请求消息 响应消息 请求消息 ASCII：人直接可读 上传输入的方法 POST方法 网页经常需要填写表格 在请求消息的消息体(entity body)中上传客户端的输入 URL方法 使用GET方法 输入消息通过request行的URL字段上传 HEAD 请求Server不要将所请求的对象放入响应消息中 PUT(HTTP/1.1) 将消息体中的文件上传到URL字段所指定的路径 DELETE(HTTP/1.1) 删除URL字段指定的文件 HTTP响应状态代码 响应消息的第一行 示例： 200 OK 301 Moved Permanently 400 Bad Request 404 Not Found 505 HTTP Version Not Supported 500 Internet Server Error 6. Cookie为什么需要Cookie？ HTTP协议无状态，很多应用需要服务器掌握客户端的状态，如网上购物 Cookie技术： 某些网站为了辨别用户身份、进行session跟踪而储存在本地终端上的数据(通常经过加密)。 RFC6265 Cookie组件： HTTP响应消息的cookie头部行 HTTP请求消息的cookie头部行 保存在客户端主机上的cookie文件，由浏览器管理 Web服务器端的后台数据库 Cookie的原理： cookie能够用于： 身份认证 购物车 推荐 web email …… 隐私问题 7. Web缓存/代理服务器技术功能： 在不访问服务器的前提下满足客户端的HTTP请求 缩短客户请求的响应时间 减少机构/组织的流量 在大范围实现有效的内容分发 Web缓存/代理服务器技术 用户设定浏览器通过缓存进行Web访问 浏览器向缓存/代理服务器发送所有的HTTP请求 如果请求对象在缓存中，缓存返回对象 否则，缓存服务器向原始服务器发送HTTP 请求，获取对象，然后返回给客户端并保存该对象 缓存既充当客户端，也充当服务器 HTTP 的条件性Get方法 如果缓存有最新的对象，则不需要发送请求对象 缓存： 在HTTP请求消息中声明所持有版本的日期 If-modified-since: 服务器 如果缓存的版本是最新的，则响应消息中不包含对象 HTTP/1.0 304 Not Modified 8. email应用Email应用的构成组件 异步应用 邮件客户端 读、写Email消息 与服务器交互，收发Email信息 outlook…… web客户端 邮件服务器 邮箱：存储发给该客户的email 消息队列：存储等待发送的email SMTP协议(Simple Mail Transfer Protocol) 邮件服务器之间传递消息所使用的协议 客户端：发送消息的服务器 服务器：接收消息的服务器 使用TCP进行email消息的可靠传输 端口25 传输过程的三个阶段 握手 消息传输 关闭 命令/响应交互模式 命令(command):ASCII文本 响应(response):状态代码和语句 Email消息只能包含7位ASCII码 使用持久性连接 SMTP服务器利用CRLF.CRLF确定消息的结束 与HTTP 对比： HTTP：拉式(pull) SMTP:退式(push) 都使用命令/响应交互模式 命令和状态代码都是ASCII代码 HTTP:每个对象封装在独立的响应消息中 SMTP：多个对象在由多个部分构成的消息中发送 Email消息格式 RFC 822 头部行(header) To From 与SMTP命令不同 Subject 消息体(body) 消息本身 只能说ASCII字符 多媒体拓展 RFC 2045 2056 MIME：多媒体邮件拓展 通过在有键头部增加额外的行以声明MIME的内容类型 邮件访问协议：从服务器获取邮件 POP：Post Office Protocal 认证/授权和下载 IMAP：Internet Mail Access Protocal 能够操纵服务器上存储的消息 所有消息统一保存在一个地方：服务器 允许用户利用文件夹组织信息 支持跨会话的用户状态 HTTP：163， QQ Mail…… 9. DNS(Domain Name System)Internet上主机/路由的识别问题 IP地址 域名 域名和IP地址之间如何映射？ 域名解析系统DNS 多层命名服务器构成的分布式层次式数据库 应用层协议：完成名字的解析 Internet核心功能，用应用层协议实现 网络边界复杂 DNS服务 域名向IP地址的翻译 主机别名 邮件服务器别名 负载均衡：Web服务器 客户端想要查询www.amazon.com的IP 客户端查询根服务器 客户端查询com域名解析服务器，找到amazon.com域名解析服务器 客户端查询amazon.com域名解析服务器，获得www.amazon.com的IP地址 DNS根域名服务器 本地域名服务器无法解析域名时，访问根域名服务器 根域名服务器 TLD和权威域名解析服务器 顶级域名服务器(top-level domain)：负责com，org，net，edu等顶级域名和国家域名 权威域名解析服务器：组织的域名解析服务器，提供组织内部服务器的解析服务 本地域名解析服务器 不属于层级体系 每个ISP有一个本地域名服务器 默认域名解析服务器 当主机进行DNS查询时，查询被发到本地域名服务器作为代理，将查询转发给层级式域名解析服务器系统 迭代查询 被查询服务器返回域名解析服务器的名字 递归查询 将域名解析的任务交给所联系的服务器 DNS记录缓存和更新 只要域名解析服务器获得域名——IP映射，即缓存这一映射 本地域名服务器一般缓存顶级域名服务器的映射 DNS记录： 资源记录 Type=A name：主机域名 value：IP地址 Type=NS name：域(edu.cn) value：该域权威域名解析服务器的主机域名 Type=CNAME name：某一真实域名的别名 value：真实域名 Type=MX value是与name相对应的邮件服务器 DNS协议： 查询(query)和回复(reply) 消息格式相同消息头部 identification：16位查询编号，回复使用相同编号 flags 查询或回复 期望递归 递归可用 权威回答","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"计算机网络概述","slug":"计算机网络概述","date":"2020-03-18T00:00:00.000Z","updated":"2020-04-19T10:08:06.000Z","comments":true,"path":"2020/03/18/计算机网络概述/","link":"","permalink":"http://yoursite.com/2020/03/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/","excerpt":"1. 计算机网络计算机网络就是一互联的、自治的计算机集合。自治：无主从关系。通过交换网络互联主机。 计算机网络 = 通信技术+计算机技术","text":"1. 计算机网络计算机网络就是一互联的、自治的计算机集合。自治：无主从关系。通过交换网络互联主机。 计算机网络 = 通信技术+计算机技术 2. 计算机网络基础协议是计算机网络有序运行的重要保证。 硬件是计算机网络的基础。 网络协议：协议规定了交换信息的格式、意义、顺序、针对收到的信息/发生的事件采取的actions。 协议的三要素： 语法： 数据与控制信息的结构或格式 信号电平 语义： 需要发出何种控制信息 完成何种动作以及做出何种响应 差错控制 时序： 时间顺序 协议匹配3. 计算机网络结构网络边缘：主机、网络应用 主机（端系统）：位于“网络边缘”、运行网络应用程序 客户/服务器应用模型：客户发送请求，接收服务器响应接入网络，物理介质：有线/无线通信链路 网络核心（核心网络）：互联网的路由器/分组转发设备、网络之网络 互联网的路由器网络 网络核心的关键功能：路由+转发 网络核心解决的基本问题：数据交换网络结构： 端系统通过接入ISP连接到Internet；接入ISP必须进一步互联；构成复杂的网络互连的网络。4. 网络核心最典型电路交换网络：电话网络 电路交换的三个阶段： 建立连接（呼叫/电路建立） 通信 释放连接（拆除电路）多路复用（multiplexing），简称复用，是通信技术的基本概念。 链路/网络资源划分为“资源片” 将资源片分配给各路“呼叫” 每路呼叫独占分配到的资源片进行通信 资源片可能闲置（无共享） 典型多路复用方法： 频分多路复用FDM 时分多路复用TDM 波分多路复用WDM 码分多路复用CDM：广泛应用于无线链路共享（如蜂窝网、卫星通信等） 5. 报文交换报文：源（应用）发送信息整体. 报文交换： 报文长度为M bits 链路宽度为R bps 每次传输报文需要M/R秒分组交换：传输延迟 报文被拆得分为多个分组 分组长度为L bits 每个分组传输时延为L/R秒 跳步数：h 路由器数：nT = M/R+(h-1)L/R = M/R+NL/R 分组：报文分拆出来的一系列相对较小的数据包。 分组交换需要报文的拆分与重组,产生额外开销。 报文交换与分组交换均采用存储-转发交换方式区别： 报文交换以完整报文进行“存储-转发” 分组交换以较小的分组进行“存储-转发”分组交换允许更多用户同时使用网络！–网络资源充分共享。适用于突发数据传输网络，可能产生拥塞(congestion)分组延迟和丢失。 6. 计算机网络性能速率：数据率/数据传输速率/比特率。速率往往是指额定速率/标称速率。 单位时间(秒)传输信息量，计算机网络中最重要的一个性能指标。 时延：时延是指一个报文或分组从一个网络的一端传送到另一个端所需要的时间。 带宽：原本指信号具有的频带宽度，即最高频率与最低频率之差，单位是赫兹。 网络的带宽通常是数字信道所能传送的最高数据率，单位：b/s（bps）。 时延带宽积 = 传播时延×带宽 = dprop × R(bits) 链路的时延带宽积又称为以比特为单位的链路长度。 丢包： 吞吐量/率：表示再发送端与接收端之间传送数据速率。 7. 计算机网络的体系结构：分层结构 OSI模型： 7：应用层（Apllication） 6：表示层（Presentation） 5：会话层（Session） 4：传输层（Transport） 3：网络层（Network） 2：数据链路层（Data link） 1：物理层（Physical） 物理层 数据链路层 网络层 传输层 会话层 表示层 应用层 功能 负责结点-结点数据传输 源主机到目的主机数据分组交付;路由 分段与重组，SAP寻址，流量控制 对话控制，同步，最“薄”的一层 数据表示转化，加密/解密，压缩/解压缩 使用网络服务 8. TCP/IP模型 5层参考模型 应用层 传输层 网络层 数据链路层 物理层 应用层 传输层 网络层 数据链路层 物理层 功能 支持各种网络应用;FTP,SMTP,HTTP 进程-进程的数据传输;TCP,UDP 源主机到目的主机的数据分组路由和转发;IP协议、路由协议 相邻网络元素的数据传输;以太网，WIFI 比特传输","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/categories/Leetcode/"},{"name":"Node","slug":"Node","permalink":"http://yoursite.com/categories/Node/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"},{"name":"面试题目","slug":"面试题目","permalink":"http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://yoursite.com/categories/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"},{"name":"BOM","slug":"BOM","permalink":"http://yoursite.com/categories/BOM/"},{"name":"JS高级","slug":"JS高级","permalink":"http://yoursite.com/categories/JS%E9%AB%98%E7%BA%A7/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/categories/HTML/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/tags/Leetcode/"},{"name":"Leetcode; JavaScript","slug":"Leetcode-JavaScript","permalink":"http://yoursite.com/tags/Leetcode-JavaScript/"},{"name":"Node","slug":"Node","permalink":"http://yoursite.com/tags/Node/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"计算机网络面试题目","slug":"计算机网络面试题目","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://yoursite.com/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"BOM","slug":"BOM","permalink":"http://yoursite.com/tags/BOM/"},{"name":"JS高级","slug":"JS高级","permalink":"http://yoursite.com/tags/JS%E9%AB%98%E7%BA%A7/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]}